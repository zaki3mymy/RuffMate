{
  "version": {
    "version": "0.14.10",
    "fetchedAt": "2025-12-31T13:47:31.614Z"
  },
  "rules": [
    {
      "code": "AIR001",
      "name": "airflow-variable-name-task-id-mismatch",
      "summary": "Checks that the task variable name matches the `task_id` value for\nAirflow Operators.",
      "category": "Airflow",
      "categoryCode": "AIR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/airflow-variable-name-task-id-mismatch/",
      "whyBad": "When initializing an Airflow Operator, for consistency, the variable\nname should match the `task_id` value. This makes it easier to\nfollow the flow of the DAG.",
      "example": "```python\nfrom airflow.operators import PythonOperator\n\n\nincorrect_name = PythonOperator(task_id=\"my_task\")\n```\n\nUse instead:\n```python\nfrom airflow.operators import PythonOperator\n\n\nmy_task = PythonOperator(task_id=\"my_task\")\n```"
    },
    {
      "code": "AIR002",
      "name": "airflow-dag-no-schedule-argument",
      "summary": "Checks for a `DAG()` class or `@dag()` decorator without an explicit\n`schedule` (or `schedule_interval` for Airflow 1) parameter.",
      "category": "Airflow",
      "categoryCode": "AIR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/airflow-dag-no-schedule-argument/",
      "whyBad": "The default value of the `schedule` parameter on Airflow 2 and\n`schedule_interval` on Airflow 1 is `timedelta(days=1)`, which is almost\nnever what a user is looking for. Airflow 3 changed the default value to `None`,\nand would break existing dags using the implicit default.\n\nIf your dag does not have an explicit `schedule` / `schedule_interval` argument,\nAirflow 2 schedules a run for it every day (at the time determined by `start_date`).\nSuch a dag will no longer be scheduled on Airflow 3 at all, without any\nexceptions or other messages visible to the user.",
      "example": "```python\nfrom airflow import DAG\n\n\n# Using the implicit default schedule.\ndag = DAG(dag_id=\"my_dag\")\n```\n\nUse instead:\n```python\nfrom datetime import timedelta\n\nfrom airflow import DAG\n\n\ndag = DAG(dag_id=\"my_dag\", schedule=timedelta(days=1))\n```"
    },
    {
      "code": "AIR301",
      "name": "airflow3-removal",
      "summary": "Checks for uses of deprecated Airflow functions and values.",
      "category": "Airflow",
      "categoryCode": "AIR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/airflow3-removal/",
      "whyBad": "Airflow 3.0 removed various deprecated functions, members, and other\nvalues. Some have more modern replacements. Others are considered too niche\nand not worth continued maintenance in Airflow.",
      "example": "```python\nfrom airflow.utils.dates import days_ago\n\n\nyesterday = days_ago(today, 1)\n```\n\nUse instead:\n```python\nfrom datetime import timedelta\n\n\nyesterday = today - timedelta(days=1)\n```"
    },
    {
      "code": "AIR302",
      "name": "airflow3-moved-to-provider",
      "summary": "Checks for uses of Airflow functions and values that have been moved to its providers\n(e.g., `apache-airflow-providers-fab`).",
      "category": "Airflow",
      "categoryCode": "AIR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/airflow3-moved-to-provider/",
      "whyBad": "Airflow 3.0 moved various deprecated functions, members, and other\nvalues to its providers. The user needs to install the corresponding provider and replace\nthe original usage with the one in the provider.",
      "example": "```python\nfrom airflow.auth.managers.fab.fab_auth_manager import FabAuthManager\n\nfab_auth_manager_app = FabAuthManager().get_fastapi_app()\n```\n\nUse instead:\n```python\nfrom airflow.providers.fab.auth_manager.fab_auth_manager import FabAuthManager\n\nfab_auth_manager_app = FabAuthManager().get_fastapi_app()\n```"
    },
    {
      "code": "AIR311",
      "name": "airflow3-suggested-update",
      "summary": "Checks for uses of deprecated Airflow functions and values that still have\na compatibility layer.",
      "category": "Airflow",
      "categoryCode": "AIR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/airflow3-suggested-update/",
      "whyBad": "Airflow 3.0 removed various deprecated functions, members, and other\nvalues. Some have more modern replacements. Others are considered too niche\nand not worth continued maintenance in Airflow.\nEven though these symbols still work fine on Airflow 3.0, they are expected to be removed in a future version.\nWhere available, users should replace the removed functionality with the new alternatives.",
      "example": "```python\nfrom airflow import Dataset\n\n\nDataset(uri=\"test://test/\")\n```\n\nUse instead:\n```python\nfrom airflow.sdk import Asset\n\n\nAsset(uri=\"test://test/\")\n```"
    },
    {
      "code": "AIR312",
      "name": "airflow3-suggested-to-move-to-provider",
      "summary": "Checks for uses of Airflow functions and values that have been moved to its providers\nbut still have a compatibility layer (e.g., `apache-airflow-providers-standard`).",
      "category": "Airflow",
      "categoryCode": "AIR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/airflow3-suggested-to-move-to-provider/",
      "whyBad": "Airflow 3.0 moved various deprecated functions, members, and other\nvalues to its providers. Even though these symbols still work fine on Airflow 3.0,\nthey are expected to be removed in a future version. The user is suggested to install\nthe corresponding provider and replace the original usage with the one in the provider.",
      "example": "```python\nfrom airflow.operators.python import PythonOperator\n\n\ndef print_context(ds=None, **kwargs):\n    print(kwargs)\n    print(ds)\n\n\nprint_the_context = PythonOperator(\n    task_id=\"print_the_context\", python_callable=print_context\n)\n```\n\nUse instead:\n```python\nfrom airflow.providers.standard.operators.python import PythonOperator\n\n\ndef print_context(ds=None, **kwargs):\n    print(kwargs)\n    print(ds)\n\n\nprint_the_context = PythonOperator(\n    task_id=\"print_the_context\", python_callable=print_context\n)\n```"
    },
    {
      "code": "ERA001",
      "name": "commented-out-code",
      "summary": "Checks for commented-out Python code.",
      "category": "eradicate",
      "categoryCode": "ERA",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/commented-out-code/",
      "whyBad": "Commented-out code is dead code, and is often included inadvertently.\nIt should be removed.",
      "example": "```python"
    },
    {
      "code": "FAST001",
      "name": "fast-api-redundant-response-model",
      "summary": "Checks for FastAPI routes that use the optional `response_model` parameter\nwith the same type as the return type.",
      "category": "FastAPI",
      "categoryCode": "FAST",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/fast-api-redundant-response-model/",
      "whyBad": "FastAPI routes automatically infer the response model type from the return\ntype, so specifying it explicitly is redundant.\n\nThe `response_model` parameter is used to override the default response\nmodel type. For example, `response_model` can be used to specify that\na non-serializable response type should instead be serialized via an\nalternative type.\n\nFor more information, see the [FastAPI documentation](https://fastapi.tiangolo.com/tutorial/response-model/).",
      "example": "```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item) -> Item:\n    return item\n```\n\nUse instead:\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n\n\n@app.post(\"/items/\")\nasync def create_item(item: Item) -> Item:\n    return item\n```"
    },
    {
      "code": "FAST002",
      "name": "fast-api-non-annotated-dependency",
      "summary": "Identifies FastAPI routes with deprecated uses of `Depends` or similar.",
      "category": "FastAPI",
      "categoryCode": "FAST",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/fast-api-non-annotated-dependency/",
      "whyBad": "The [FastAPI documentation] recommends the use of [`typing.Annotated`][typing-annotated]\nfor defining route dependencies and parameters, rather than using `Depends`,\n`Query` or similar as a default value for a parameter. Using this approach\neverywhere helps ensure consistency and clarity in defining dependencies\nand parameters.\n\n`Annotated` was added to the `typing` module in Python 3.9; however,\nthe third-party [`typing_extensions`][typing-extensions] package\nprovides a backport that can be used on older versions of Python.",
      "example": "```python\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n\n@app.get(\"/items/\")\nasync def read_items(commons: dict = Depends(common_parameters)):\n    return commons\n```\n\nUse instead:\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\n\nasync def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n\n@app.get(\"/items/\")\nasync def read_items(commons: Annotated[dict, Depends(common_parameters)]):\n    return commons\n```"
    },
    {
      "code": "FAST003",
      "name": "fast-api-unused-path-parameter",
      "summary": "Identifies FastAPI routes that declare path parameters in the route path\nthat are not included in the function signature.",
      "category": "FastAPI",
      "categoryCode": "FAST",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/fast-api-unused-path-parameter/",
      "whyBad": "Path parameters are used to extract values from the URL path.\n\nIf a path parameter is declared in the route path but not in the function\nsignature, it will not be accessible in the function body, which is likely\na mistake.\n\nIf a path parameter is declared in the route path, but as a positional-only\nargument in the function signature, it will also not be accessible in the\nfunction body, as FastAPI will not inject the parameter.",
      "example": "```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/things/{thing_id}\")\nasync def read_thing(query: str): ...\n```\n\nUse instead:\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/things/{thing_id}\")\nasync def read_thing(thing_id: int, query: str): ...\n```"
    },
    {
      "code": "YTT101",
      "name": "sys-version-slice3",
      "summary": "Checks for uses of `sys.version[:3]`.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version-slice3/",
      "whyBad": "If the current major or minor version consists of multiple digits,\n`sys.version[:3]` will truncate the version number (e.g., `\"3.10\"` would\nbecome `\"3.1\"`). This is likely unintended, and can lead to subtle bugs if\nthe version string is used to test against a specific Python version.\n\nInstead, use `sys.version_info` to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.",
      "example": "```python\nimport sys\n\nsys.version[:3]  # Evaluates to \"3.1\" on Python 3.10.\n```\n\nUse instead:\n```python\nimport sys\n\nsys.version_info[:2]  # Evaluates to (3, 10) on Python 3.10.\n```"
    },
    {
      "code": "YTT102",
      "name": "sys-version2",
      "summary": "Checks for uses of `sys.version[2]`.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version2/",
      "whyBad": "If the current major or minor version consists of multiple digits,\n`sys.version[2]` will select the first digit of the minor number only\n(e.g., `\"3.10\"` would evaluate to `\"1\"`). This is likely unintended, and\ncan lead to subtle bugs if the version is used to test against a minor\nversion number.\n\nInstead, use `sys.version_info.minor` to access the current minor version\nnumber.",
      "example": "```python\nimport sys\n\nsys.version[2]  # Evaluates to \"1\" on Python 3.10.\n```\n\nUse instead:\n```python\nimport sys\n\nf\"{sys.version_info.minor}\"  # Evaluates to \"10\" on Python 3.10.\n```"
    },
    {
      "code": "YTT103",
      "name": "sys-version-cmp-str3",
      "summary": "Checks for comparisons that test `sys.version` against string literals,\nsuch that the comparison will evaluate to `False` on Python 3.10 or later.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version-cmp-str3/",
      "whyBad": "Comparing `sys.version` to a string is error-prone and may cause subtle\nbugs, as the comparison will be performed lexicographically, not\nsemantically. For example, `sys.version > \"3.9\"` will evaluate to `False`\nwhen using Python 3.10, as `\"3.10\"` is lexicographically \"less\" than\n`\"3.9\"`.\n\nInstead, use `sys.version_info` to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.",
      "example": "```python\nimport sys\n\nsys.version > \"3.9\"  # `False` on Python 3.10.\n```\n\nUse instead:\n```python\nimport sys\n\nsys.version_info > (3, 9)  # `True` on Python 3.10.\n```"
    },
    {
      "code": "YTT201",
      "name": "sys-version-info0-eq3",
      "summary": "Checks for equality comparisons against the major version returned by\n`sys.version_info` (e.g., `sys.version_info[0] == 3` or `sys.version_info[0] != 3`).",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version-info0-eq3/",
      "whyBad": "Using `sys.version_info[0] == 3` to verify that the major version is\nPython 3 or greater will fail if the major version number is ever\nincremented (e.g., to Python 4). This is likely unintended, as code\nthat uses this comparison is likely intended to be run on Python 2,\nbut would now run on Python 4 too. Similarly, using `sys.version_info[0] != 3`\nto check for Python 2 will also fail if the major version number is\nincremented.\n\nInstead, use `>=` to check if the major version number is 3 or greater,\nor `<` to check if the major version number is less than 3, to future-proof\nthe code.",
      "example": "```python\nimport sys\n\nif sys.version_info[0] == 3:\n    ...\nelse:\n    print(\"Python 2\")  # This will be printed on Python 4.\n```\n\nUse instead:\n```python\nimport sys\n\nif sys.version_info >= (3,):\n    ...\nelse:\n    print(\"Python 2\")  # This will not be printed on Python 4.\n```"
    },
    {
      "code": "YTT202",
      "name": "six-py3",
      "summary": "Checks for uses of `six.PY3`.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/six-py3/",
      "whyBad": "`six.PY3` will evaluate to `False` on Python 4 and greater. This is likely\nunintended, and may cause code intended to run on Python 2 to run on Python 4\ntoo.\n\nInstead, use `not six.PY2` to validate that the current Python major version is\n_not_ equal to 2, to future-proof the code.",
      "example": "```python\nimport six\n\nsix.PY3  # `False` on Python 4.\n```\n\nUse instead:\n```python\nimport six\n\nnot six.PY2  # `True` on Python 4.\n```"
    },
    {
      "code": "YTT203",
      "name": "sys-version-info1-cmp-int",
      "summary": "Checks for comparisons that test `sys.version_info[1]` against an integer.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version-info1-cmp-int/",
      "whyBad": "Comparisons based on the current minor version number alone can cause\nsubtle bugs and would likely lead to unintended effects if the Python\nmajor version number were ever incremented (e.g., to Python 4).\n\nInstead, compare `sys.version_info` to a tuple, including the major and\nminor version numbers, to future-proof the code.",
      "example": "```python\nimport sys\n\nif sys.version_info[1] < 7:\n    print(\"Python 3.6 or earlier.\")  # This will be printed on Python 4.0.\n```\n\nUse instead:\n```python\nimport sys\n\nif sys.version_info < (3, 7):\n    print(\"Python 3.6 or earlier.\")\n```"
    },
    {
      "code": "YTT204",
      "name": "sys-version-info-minor-cmp-int",
      "summary": "Checks for comparisons that test `sys.version_info.minor` against an integer.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version-info-minor-cmp-int/",
      "whyBad": "Comparisons based on the current minor version number alone can cause\nsubtle bugs and would likely lead to unintended effects if the Python\nmajor version number were ever incremented (e.g., to Python 4).\n\nInstead, compare `sys.version_info` to a tuple, including the major and\nminor version numbers, to future-proof the code.",
      "example": "```python\nimport sys\n\nif sys.version_info.minor < 7:\n    print(\"Python 3.6 or earlier.\")  # This will be printed on Python 4.0.\n```\n\nUse instead:\n```python\nimport sys\n\nif sys.version_info < (3, 7):\n    print(\"Python 3.6 or earlier.\")\n```"
    },
    {
      "code": "YTT301",
      "name": "sys-version0",
      "summary": "Checks for uses of `sys.version[0]`.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version0/",
      "whyBad": "If the current major or minor version consists of multiple digits,\n`sys.version[0]` will select the first digit of the major version number\nonly (e.g., `\"10.2\"` would evaluate to `\"1\"`). This is likely unintended,\nand can lead to subtle bugs if the version string is used to test against a\nmajor version number.\n\nInstead, use `sys.version_info.major` to access the current major version\nnumber.",
      "example": "```python\nimport sys\n\nsys.version[0]  # If using Python 10, this evaluates to \"1\".\n```\n\nUse instead:\n```python\nimport sys\n\nf\"{sys.version_info.major}\"  # If using Python 10, this evaluates to \"10\".\n```"
    },
    {
      "code": "YTT302",
      "name": "sys-version-cmp-str10",
      "summary": "Checks for comparisons that test `sys.version` against string literals,\nsuch that the comparison would fail if the major version number were\never incremented to Python 10 or higher.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version-cmp-str10/",
      "whyBad": "Comparing `sys.version` to a string is error-prone and may cause subtle\nbugs, as the comparison will be performed lexicographically, not\nsemantically.\n\nInstead, use `sys.version_info` to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.",
      "example": "```python\nimport sys\n\nsys.version >= \"3\"  # `False` on Python 10.\n```\n\nUse instead:\n```python\nimport sys\n\nsys.version_info >= (3,)  # `True` on Python 10.\n```"
    },
    {
      "code": "YTT303",
      "name": "sys-version-slice1",
      "summary": "Checks for uses of `sys.version[:1]`.",
      "category": "flake8-2020",
      "categoryCode": "YTT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-version-slice1/",
      "whyBad": "If the major version number consists of more than one digit, this will\nselect the first digit of the major version number only (e.g., `\"10.0\"`\nwould evaluate to `\"1\"`). This is likely unintended, and can lead to subtle\nbugs in future versions of Python if the version string is used to test\nagainst a specific major version number.\n\nInstead, use `sys.version_info.major` to access the current major version\nnumber.",
      "example": "```python\nimport sys\n\nsys.version[:1]  # If using Python 10, this evaluates to \"1\".\n```\n\nUse instead:\n```python\nimport sys\n\nf\"{sys.version_info.major}\"  # If using Python 10, this evaluates to \"10\".\n```"
    },
    {
      "code": "ANN001",
      "name": "missing-type-function-argument",
      "summary": "Checks that function arguments have type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-type-function-argument/",
      "whyBad": "Type annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.",
      "example": "```python\ndef foo(x): ...\n```\n\nUse instead:\n\n```python\ndef foo(x: int): ...\n```"
    },
    {
      "code": "ANN002",
      "name": "missing-type-args",
      "summary": "Checks that function `*args` arguments have type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-type-args/",
      "whyBad": "Type annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.",
      "example": "```python\ndef foo(*args): ...\n```\n\nUse instead:\n\n```python\ndef foo(*args: int): ...\n```"
    },
    {
      "code": "ANN003",
      "name": "missing-type-kwargs",
      "summary": "Checks that function `**kwargs` arguments have type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-type-kwargs/",
      "whyBad": "Type annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.",
      "example": "```python\ndef foo(**kwargs): ...\n```\n\nUse instead:\n\n```python\ndef foo(**kwargs: int): ...\n```"
    },
    {
      "code": "ANN101",
      "name": "missing-type-self",
      "summary": "Checks that instance method `self` arguments have type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-type-self/",
      "whyBad": "Type annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\nNote that many type checkers will infer the type of `self` automatically, so this\nannotation is not strictly necessary.",
      "example": "```python\nclass Foo:\n    def bar(self): ...\n```\n\nUse instead:\n\n```python\nclass Foo:\n    def bar(self: \"Foo\"): ...\n```"
    },
    {
      "code": "ANN102",
      "name": "missing-type-cls",
      "summary": "Checks that class method `cls` arguments have type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-type-cls/",
      "whyBad": "Type annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\nNote that many type checkers will infer the type of `cls` automatically, so this\nannotation is not strictly necessary.",
      "example": "```python\nclass Foo:\n    @classmethod\n    def bar(cls): ...\n```\n\nUse instead:\n\n```python\nclass Foo:\n    @classmethod\n    def bar(cls: Type[\"Foo\"]): ...\n```"
    },
    {
      "code": "ANN201",
      "name": "missing-return-type-undocumented-public-function",
      "summary": "Checks that public functions and methods have return type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-return-type-undocumented-public-function/",
      "whyBad": "Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.",
      "example": "```python\ndef add(a, b):\n    return a + b\n```\n\nUse instead:\n```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"
    },
    {
      "code": "ANN202",
      "name": "missing-return-type-private-function",
      "summary": "Checks that private functions and methods have return type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-return-type-private-function/",
      "whyBad": "Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.",
      "example": "```python\ndef _add(a, b):\n    return a + b\n```\n\nUse instead:\n```python\ndef _add(a: int, b: int) -> int:\n    return a + b\n```"
    },
    {
      "code": "ANN204",
      "name": "missing-return-type-special-method",
      "summary": "Checks that \"special\" methods, like `__init__`, `__new__`, and `__call__`, have\nreturn type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-return-type-special-method/",
      "whyBad": "Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\nNote that type checkers often allow you to omit the return type annotation for\n`__init__` methods, as long as at least one argument has a type annotation. To\nopt in to this behavior, use the `mypy-init-return` setting in your `pyproject.toml`\nor `ruff.toml` file:\n\n```toml\n[tool.ruff.lint.flake8-annotations]\nmypy-init-return = true\n```",
      "example": "```python\nclass Foo:\n    def __init__(self, x: int):\n        self.x = x\n```\n\nUse instead:\n```python\nclass Foo:\n    def __init__(self, x: int) -> None:\n        self.x = x\n```"
    },
    {
      "code": "ANN205",
      "name": "missing-return-type-static-method",
      "summary": "Checks that static methods have return type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-return-type-static-method/",
      "whyBad": "Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.",
      "example": "```python\nclass Foo:\n    @staticmethod\n    def bar():\n        return 1\n```\n\nUse instead:\n```python\nclass Foo:\n    @staticmethod\n    def bar() -> int:\n        return 1\n```"
    },
    {
      "code": "ANN206",
      "name": "missing-return-type-class-method",
      "summary": "Checks that class methods have return type annotations.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-return-type-class-method/",
      "whyBad": "Type annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.",
      "example": "```python\nclass Foo:\n    @classmethod\n    def bar(cls):\n        return 1\n```\n\nUse instead:\n```python\nclass Foo:\n    @classmethod\n    def bar(cls) -> int:\n        return 1\n```"
    },
    {
      "code": "ANN401",
      "name": "any-type",
      "summary": "Checks that function arguments are annotated with a more specific type than\n`Any`.",
      "category": "flake8-annotations",
      "categoryCode": "ANN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/any-type/",
      "whyBad": "`Any` is a special type indicating an unconstrained type. When an\nexpression is annotated with type `Any`, type checkers will allow all\noperations on it.\n\nIt's better to be explicit about the type of an expression, and to use\n`Any` as an \"escape hatch\" only when it is really needed.",
      "example": "```python\nfrom typing import Any\n\n\ndef foo(x: Any): ...\n```\n\nUse instead:\n\n```python\ndef foo(x: int): ...\n```"
    },
    {
      "code": "ASYNC100",
      "name": "cancel-scope-no-checkpoint",
      "summary": "Checks for timeout context managers which do not contain a checkpoint.\n\nFor the purposes of this check, `yield` is considered a checkpoint,\nsince checkpoints may occur in the caller to which we yield.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/cancel-scope-no-checkpoint/",
      "whyBad": "Some asynchronous context managers, such as `asyncio.timeout` and\n`trio.move_on_after`, have no effect unless they contain a checkpoint.\nThe use of such context managers without an `await`, `async with` or\n`async for` statement is likely a mistake.",
      "example": "```python\nimport asyncio\n\n\nasync def func():\n    async with asyncio.timeout(2):\n        do_something()\n```\n\nUse instead:\n```python\nimport asyncio\n\n\nasync def func():\n    async with asyncio.timeout(2):\n        do_something()\n        await awaitable()\n```"
    },
    {
      "code": "ASYNC105",
      "name": "trio-sync-call",
      "summary": "Checks for calls to trio functions that are not immediately awaited.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/trio-sync-call/",
      "whyBad": "Many of the functions exposed by trio are asynchronous, and must be awaited\nto take effect. Calling a trio function without an `await` can lead to\n`RuntimeWarning` diagnostics and unexpected behaviour.",
      "example": "```python\nimport trio\n\n\nasync def double_sleep(x):\n    trio.sleep(2 * x)\n```\n\nUse instead:\n```python\nimport trio\n\n\nasync def double_sleep(x):\n    await trio.sleep(2 * x)\n```"
    },
    {
      "code": "ASYNC109",
      "name": "async-function-with-timeout",
      "summary": "Checks for `async` function definitions with `timeout` parameters.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/async-function-with-timeout/",
      "whyBad": "Rather than implementing asynchronous timeout behavior manually, prefer\nbuilt-in timeout functionality, such as `asyncio.timeout`, `trio.fail_after`,\nor `anyio.move_on_after`, among others.\n\nThis rule is highly opinionated to enforce a design pattern\ncalled [\"structured concurrency\"] that allows for\n`async` functions to be oblivious to timeouts,\ninstead letting callers to handle the logic with a context manager.",
      "example": "```python\nasync def long_running_task(timeout): ...\n\n\nasync def main():\n    await long_running_task(timeout=2)\n```\n\nUse instead:\n\n```python\nasync def long_running_task(): ...\n\n\nasync def main():\n    async with asyncio.timeout(2):\n        await long_running_task()\n```"
    },
    {
      "code": "ASYNC110",
      "name": "async-busy-wait",
      "summary": "Checks for the use of an async sleep function in a `while` loop.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/async-busy-wait/",
      "whyBad": "Instead of sleeping in a `while` loop, and waiting for a condition\nto become true, it's preferable to `await` on an `Event` object such\nas: `asyncio.Event`, `trio.Event`, or `anyio.Event`.",
      "example": "```python\nimport asyncio\n\nDONE = False\n\n\nasync def func():\n    while not DONE:\n        await asyncio.sleep(1)\n```\n\nUse instead:\n```python\nimport asyncio\n\nDONE = asyncio.Event()\n\n\nasync def func():\n    await DONE.wait()\n```"
    },
    {
      "code": "ASYNC115",
      "name": "async-zero-sleep",
      "summary": "Checks for uses of `trio.sleep(0)` or `anyio.sleep(0)`.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/async-zero-sleep/",
      "whyBad": "`trio.sleep(0)` is equivalent to calling `trio.lowlevel.checkpoint()`.\nHowever, the latter better conveys the intent of the code.",
      "example": "```python\nimport trio\n\n\nasync def func():\n    await trio.sleep(0)\n```\n\nUse instead:\n```python\nimport trio\n\n\nasync def func():\n    await trio.lowlevel.checkpoint()\n```"
    },
    {
      "code": "ASYNC116",
      "name": "long-sleep-not-forever",
      "summary": "Checks for uses of `trio.sleep()` or `anyio.sleep()` with a delay greater than 24 hours.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/long-sleep-not-forever/",
      "whyBad": "Calling `sleep()` with a delay greater than 24 hours is usually intended\nto sleep indefinitely. Instead of using a large delay,\n`trio.sleep_forever()` or `anyio.sleep_forever()` better conveys the intent.",
      "example": "```python\nimport trio\n\n\nasync def func():\n    await trio.sleep(86401)\n```\n\nUse instead:\n```python\nimport trio\n\n\nasync def func():\n    await trio.sleep_forever()\n```"
    },
    {
      "code": "ASYNC210",
      "name": "blocking-http-call-in-async-function",
      "summary": "Checks that async functions do not contain blocking HTTP calls.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blocking-http-call-in-async-function/",
      "whyBad": "Blocking an async function via a blocking HTTP call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\nHTTP response, negating the benefits of asynchronous programming.\n\nInstead of making a blocking HTTP call, use an asynchronous HTTP client\nlibrary such as `aiohttp` or `httpx`.",
      "example": "```python\nimport urllib\n\n\nasync def fetch():\n    urllib.request.urlopen(\"https://example.com/foo/bar\").read()\n```\n\nUse instead:\n```python\nimport aiohttp\n\n\nasync def fetch():\n    async with aiohttp.ClientSession() as session:\n        async with session.get(\"https://example.com/foo/bar\") as resp:\n            ...\n```"
    },
    {
      "code": "ASYNC212",
      "name": "blocking-http-call-httpx-in-async-function",
      "summary": "Checks that async functions do not use blocking httpx clients.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blocking-http-call-httpx-in-async-function/",
      "whyBad": "Blocking an async function via a blocking HTTP call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\nHTTP response, negating the benefits of asynchronous programming.\n\nInstead of using the blocking `httpx` client, use the asynchronous client.",
      "example": "```python\nimport httpx\n\n\nasync def fetch():\n    client = httpx.Client()\n    response = client.get(...)\n```\n\nUse instead:\n```python\nimport httpx\n\n\nasync def fetch():\n    async with httpx.AsyncClient() as client:\n        response = await client.get(...)\n```"
    },
    {
      "code": "ASYNC220",
      "name": "create-subprocess-in-async-function",
      "summary": "Checks that async functions do not create subprocesses with blocking methods.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/create-subprocess-in-async-function/",
      "whyBad": "Blocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function, like [`trio.run_process()`](https://trio.readthedocs.io/en/stable/reference-io.html#trio.run_process)\nor [`anyio.run_process()`](https://anyio.readthedocs.io/en/latest/api.html#anyio.run_process).",
      "example": "```python\nimport os\n\n\nasync def foo():\n    os.popen(cmd)\n```\n\nUse instead:\n```python\nimport asyncio\n\n\nasync def foo():\n    asyncio.create_subprocess_shell(cmd)\n```"
    },
    {
      "code": "ASYNC221",
      "name": "run-process-in-async-function",
      "summary": "Checks that async functions do not run processes with blocking methods.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/run-process-in-async-function/",
      "whyBad": "Blocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function, like [`trio.run_process()`](https://trio.readthedocs.io/en/stable/reference-io.html#trio.run_process)\nor [`anyio.run_process()`](https://anyio.readthedocs.io/en/latest/api.html#anyio.run_process).",
      "example": "```python\nimport subprocess\n\n\nasync def foo():\n    subprocess.run(cmd)\n```\n\nUse instead:\n```python\nimport asyncio\n\n\nasync def foo():\n    asyncio.create_subprocess_shell(cmd)\n```"
    },
    {
      "code": "ASYNC222",
      "name": "wait-for-process-in-async-function",
      "summary": "Checks that async functions do not wait on processes with blocking methods.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/wait-for-process-in-async-function/",
      "whyBad": "Blocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function, like [`trio.to_thread.run_sync()`](https://trio.readthedocs.io/en/latest/reference-core.html#trio.to_thread.run_sync)\nor [`anyio.to_thread.run_sync()`](https://anyio.readthedocs.io/en/latest/api.html#anyio.to_thread.run_sync).",
      "example": "```python\nimport os\n\n\nasync def foo():\n    os.waitpid(0)\n```\n\nUse instead:\n```python\nimport asyncio\nimport os\n\n\ndef wait_for_process():\n    os.waitpid(0)\n\n\nasync def foo():\n    await asyncio.loop.run_in_executor(None, wait_for_process)\n```"
    },
    {
      "code": "ASYNC230",
      "name": "blocking-open-call-in-async-function",
      "summary": "Checks that async functions do not open files with blocking methods like `open`.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blocking-open-call-in-async-function/",
      "whyBad": "Blocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function.",
      "example": "```python\nasync def foo():\n    with open(\"bar.txt\") as f:\n        contents = f.read()\n```\n\nUse instead:\n```python\nimport anyio\n\n\nasync def foo():\n    async with await anyio.open_file(\"bar.txt\") as f:\n        contents = await f.read()\n```"
    },
    {
      "code": "ASYNC240",
      "name": "blocking-path-method-in-async-function",
      "summary": "Checks that async functions do not call blocking `os.path` or `pathlib.Path`\nmethods.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blocking-path-method-in-async-function/",
      "whyBad": "Calling some `os.path` or `pathlib.Path` methods in an async function will block\nthe entire event loop, preventing it from executing other tasks while waiting\nfor the operation. This negates the benefits of asynchronous programming.\n\nInstead, use the methods' async equivalents from `trio.Path` or `anyio.Path`.",
      "example": "```python\nimport os\n\n\nasync def func():\n    path = \"my_file.txt\"\n    file_exists = os.path.exists(path)\n```\n\nUse instead:\n```python\nimport trio\n\n\nasync def func():\n    path = trio.Path(\"my_file.txt\")\n    file_exists = await path.exists()\n```\n\nNon-blocking methods are OK to use:\n```python\nimport pathlib\n\n\nasync def func():\n    path = pathlib.Path(\"my_file.txt\")\n    file_dirname = path.dirname()\n    new_path = os.path.join(\"/tmp/src/\", path)\n```"
    },
    {
      "code": "ASYNC250",
      "name": "blocking-input-in-async-function",
      "summary": "Checks that async functions do not contain blocking usage of input from user.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blocking-input-in-async-function/",
      "whyBad": "Blocking an async function via a blocking input call will block the entire\nevent loop, preventing it from executing other tasks while waiting for user\ninput, negating the benefits of asynchronous programming.\n\nInstead of making a blocking input call directly, wrap the input call in\nan executor to execute the blocking call on another thread.",
      "example": "```python\nasync def foo():\n    username = input(\"Username:\")\n```\n\nUse instead:\n```python\nimport asyncio\n\n\nasync def foo():\n    loop = asyncio.get_running_loop()\n    username = await loop.run_in_executor(None, input, \"Username:\")\n```"
    },
    {
      "code": "ASYNC251",
      "name": "blocking-sleep-in-async-function",
      "summary": "Checks that async functions do not call `time.sleep`.",
      "category": "flake8-async",
      "categoryCode": "ASYNC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blocking-sleep-in-async-function/",
      "whyBad": "Blocking an async function via a `time.sleep` call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\n`time.sleep`, negating the benefits of asynchronous programming.\n\nInstead of `time.sleep`, use `asyncio.sleep`.",
      "example": "```python\nimport time\n\n\nasync def fetch():\n    time.sleep(1)\n```\n\nUse instead:\n```python\nimport asyncio\n\n\nasync def fetch():\n    await asyncio.sleep(1)\n```"
    },
    {
      "code": "S101",
      "name": "assert",
      "summary": "Checks for uses of the `assert` keyword.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assert/",
      "whyBad": "Assertions are removed when Python is run with optimization requested\n(i.e., when the `-O` flag is present), which is a common practice in\nproduction environments. As such, assertions should not be used for runtime\nvalidation of user input or to enforce  interface constraints.\n\nConsider raising a meaningful error instead of using `assert`.",
      "example": "```python\nassert x > 0, \"Expected positive value.\"\n```\n\nUse instead:\n```python\nif not x > 0:\n    raise ValueError(\"Expected positive value.\")"
    },
    {
      "code": "S102",
      "name": "exec-builtin",
      "summary": "Checks for uses of the builtin `exec` function.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/exec-builtin/",
      "whyBad": "The `exec()` function is insecure as it allows for arbitrary code\nexecution.",
      "example": "```python\nexec(\"print('Hello World')\")\n```"
    },
    {
      "code": "S103",
      "name": "bad-file-permissions",
      "summary": "Checks for files with overly permissive permissions.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-file-permissions/",
      "whyBad": "Overly permissive file permissions may allow unintended access and\narbitrary code execution.",
      "example": "```python\nimport os\n\nos.chmod(\"/etc/secrets.txt\", 0o666)  # rw-rw-rw-\n```\n\nUse instead:\n```python\nimport os\n\nos.chmod(\"/etc/secrets.txt\", 0o600)  # rw-------\n```"
    },
    {
      "code": "S104",
      "name": "hardcoded-bind-all-interfaces",
      "summary": "Checks for hardcoded bindings to all network interfaces (`0.0.0.0`).",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hardcoded-bind-all-interfaces/",
      "whyBad": "Binding to all network interfaces is insecure as it allows access from\nunintended interfaces, which may be poorly secured or unauthorized.\n\nInstead, bind to specific interfaces.",
      "example": "```python\nALLOWED_HOSTS = [\"0.0.0.0\"]\n```\n\nUse instead:\n```python\nALLOWED_HOSTS = [\"127.0.0.1\", \"localhost\"]\n```"
    },
    {
      "code": "S105",
      "name": "hardcoded-password-string",
      "summary": "Checks for potential uses of hardcoded passwords in strings.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hardcoded-password-string/",
      "whyBad": "Including a hardcoded password in source code is a security risk, as an\nattacker could discover the password and use it to gain unauthorized\naccess.\n\nInstead, store passwords and other secrets in configuration files,\nenvironment variables, or other sources that are excluded from version\ncontrol.",
      "example": "```python\nSECRET_KEY = \"hunter2\"\n```\n\nUse instead:\n```python\nimport os\n\nSECRET_KEY = os.environ[\"SECRET_KEY\"]\n```"
    },
    {
      "code": "S106",
      "name": "hardcoded-password-func-arg",
      "summary": "Checks for potential uses of hardcoded passwords in function calls.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hardcoded-password-func-arg/",
      "whyBad": "Including a hardcoded password in source code is a security risk, as an\nattacker could discover the password and use it to gain unauthorized\naccess.\n\nInstead, store passwords and other secrets in configuration files,\nenvironment variables, or other sources that are excluded from version\ncontrol.",
      "example": "```python\nconnect_to_server(password=\"hunter2\")\n```\n\nUse instead:\n```python\nimport os\n\nconnect_to_server(password=os.environ[\"PASSWORD\"])\n```"
    },
    {
      "code": "S107",
      "name": "hardcoded-password-default",
      "summary": "Checks for potential uses of hardcoded passwords in function argument\ndefaults.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hardcoded-password-default/",
      "whyBad": "Including a hardcoded password in source code is a security risk, as an\nattacker could discover the password and use it to gain unauthorized\naccess.\n\nInstead, store passwords and other secrets in configuration files,\nenvironment variables, or other sources that are excluded from version\ncontrol.",
      "example": "```python\ndef connect_to_server(password=\"hunter2\"): ...\n```\n\nUse instead:\n\n```python\nimport os\n\n\ndef connect_to_server(password=os.environ[\"PASSWORD\"]): ...\n```"
    },
    {
      "code": "S108",
      "name": "hardcoded-temp-file",
      "summary": "Checks for the use of hardcoded temporary file or directory paths.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hardcoded-temp-file/",
      "whyBad": "The use of hardcoded paths for temporary files can be insecure. If an\nattacker discovers the location of a hardcoded path, they can replace the\ncontents of the file or directory with a malicious payload.\n\nOther programs may also read or write contents to these hardcoded paths,\ncausing unexpected behavior.",
      "example": "```python\nwith open(\"/tmp/foo.txt\", \"w\") as file:\n    ...\n```\n\nUse instead:\n```python\nimport tempfile\n\nwith tempfile.NamedTemporaryFile() as file:\n    ...\n```"
    },
    {
      "code": "S110",
      "name": "try-except-pass",
      "summary": "Checks for uses of the `try`-`except`-`pass` pattern.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/try-except-pass/",
      "whyBad": "The `try`-`except`-`pass` pattern suppresses all exceptions. Suppressing\nexceptions may hide errors that could otherwise reveal unexpected behavior,\nsecurity vulnerabilities, or malicious activity. Instead, consider logging\nthe exception.",
      "example": "```python\ntry:\n    ...\nexcept Exception:\n    pass\n```\n\nUse instead:\n```python\nimport logging\n\ntry:\n    ...\nexcept Exception as exc:\n    logging.exception(\"Exception occurred\")\n```"
    },
    {
      "code": "S112",
      "name": "try-except-continue",
      "summary": "Checks for uses of the `try`-`except`-`continue` pattern.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/try-except-continue/",
      "whyBad": "The `try`-`except`-`continue` pattern suppresses all exceptions.\nSuppressing exceptions may hide errors that could otherwise reveal\nunexpected behavior, security vulnerabilities, or malicious activity.\nInstead, consider logging the exception.",
      "example": "```python\nimport logging\n\nwhile predicate:\n    try:\n        ...\n    except Exception:\n        continue\n```\n\nUse instead:\n```python\nimport logging\n\nwhile predicate:\n    try:\n        ...\n    except Exception as exc:\n        logging.exception(\"Error occurred\")\n```"
    },
    {
      "code": "S113",
      "name": "request-without-timeout",
      "summary": "Checks for uses of the Python `requests` or `httpx` module that omit the\n`timeout` parameter.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/request-without-timeout/",
      "whyBad": "The `timeout` parameter is used to set the maximum time to wait for a\nresponse from the server. By omitting the `timeout` parameter, the program\nmay hang indefinitely while awaiting a response.",
      "example": "```python\nimport requests\n\nrequests.get(\"https://www.example.com/\")\n```\n\nUse instead:\n```python\nimport requests\n\nrequests.get(\"https://www.example.com/\", timeout=10)\n```"
    },
    {
      "code": "S201",
      "name": "flask-debug-true",
      "summary": "Checks for uses of `debug=True` in Flask.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/flask-debug-true/",
      "whyBad": "Enabling debug mode shows an interactive debugger in the browser if an\nerror occurs, and allows running arbitrary Python code from the browser.\nThis could leak sensitive information, or allow an attacker to run\narbitrary code.",
      "example": "```python\nfrom flask import Flask\n\napp = Flask()\n\napp.run(debug=True)\n```\n\nUse instead:\n```python\nimport os\n\nfrom flask import Flask\n\napp = Flask()\n\napp.run(debug=os.environ[\"ENV\"] == \"dev\")\n```"
    },
    {
      "code": "S202",
      "name": "tarfile-unsafe-members",
      "summary": "Checks for uses of `tarfile.extractall`.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/tarfile-unsafe-members/",
      "whyBad": "Extracting archives from untrusted sources without prior inspection is\na security risk, as maliciously crafted archives may contain files that\nwill be written outside of the target directory. For example, the archive\ncould include files with absolute paths (e.g., `/etc/passwd`), or relative\npaths with parent directory references (e.g., `../etc/passwd`).\n\nOn Python 3.12 and later, use `filter='data'` to prevent the most dangerous\nsecurity issues (see: [PEP 706]). On earlier versions, set the `members`\nargument to a trusted subset of the archive's members.",
      "example": "```python\nimport tarfile\nimport tempfile\n\ntar = tarfile.open(filename)\ntar.extractall(path=tempfile.mkdtemp())\ntar.close()\n```"
    },
    {
      "code": "S301",
      "name": "suspicious-pickle-usage",
      "summary": "Checks for calls to `pickle` functions or modules that wrap them.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-pickle-usage/",
      "whyBad": "Deserializing untrusted data with `pickle` and other deserialization\nmodules is insecure as it can allow for the creation of arbitrary objects,\nwhich can then be used to achieve arbitrary code execution and otherwise\nunexpected behavior.\n\nAvoid deserializing untrusted data with `pickle` and other deserialization\nmodules. Instead, consider safer formats, such as JSON.\n\nIf you must deserialize untrusted data with `pickle`, consider signing the\ndata with a secret key and verifying the signature before deserializing the\npayload, This will prevent an attacker from injecting arbitrary objects\ninto the serialized data.\n\nIn [preview], this rule will also flag references to `pickle` functions.",
      "example": "```python\nimport pickle\n\nwith open(\"foo.pickle\", \"rb\") as file:\n    foo = pickle.load(file)\n```\n\nUse instead:\n```python\nimport json\n\nwith open(\"foo.json\", \"rb\") as file:\n    foo = json.load(file)\n```"
    },
    {
      "code": "S302",
      "name": "suspicious-marshal-usage",
      "summary": "Checks for calls to `marshal` functions.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-marshal-usage/",
      "whyBad": "Deserializing untrusted data with `marshal` is insecure, as it can allow for\nthe creation of arbitrary objects, which can then be used to achieve\narbitrary code execution and otherwise unexpected behavior.\n\nAvoid deserializing untrusted data with `marshal`. Instead, consider safer\nformats, such as JSON.\n\nIf you must deserialize untrusted data with `marshal`, consider signing the\ndata with a secret key and verifying the signature before deserializing the\npayload. This will prevent an attacker from injecting arbitrary objects\ninto the serialized data.\n\nIn [preview], this rule will also flag references to `marshal` functions.",
      "example": "```python\nimport marshal\n\nwith open(\"foo.marshal\", \"rb\") as file:\n    foo = marshal.load(file)\n```\n\nUse instead:\n```python\nimport json\n\nwith open(\"foo.json\", \"rb\") as file:\n    foo = json.load(file)\n```"
    },
    {
      "code": "S303",
      "name": "suspicious-insecure-hash-usage",
      "summary": "Checks for uses of weak or broken cryptographic hash functions.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-insecure-hash-usage/",
      "whyBad": "Weak or broken cryptographic hash functions may be susceptible to\ncollision attacks (where two different inputs produce the same hash) or\npre-image attacks (where an attacker can find an input that produces a\ngiven hash). This can lead to security vulnerabilities in applications\nthat rely on these hash functions.\n\nAvoid using weak or broken cryptographic hash functions in security\ncontexts. Instead, use a known secure hash function such as SHA-256.\n\nIn [preview], this rule will also flag references to insecure hash functions.",
      "example": "```python\nfrom cryptography.hazmat.primitives import hashes\n\ndigest = hashes.Hash(hashes.MD5())\ndigest.update(b\"Hello, world!\")\ndigest.finalize()\n```\n\nUse instead:\n```python\nfrom cryptography.hazmat.primitives import hashes\n\ndigest = hashes.Hash(hashes.SHA256())\ndigest.update(b\"Hello, world!\")\ndigest.finalize()\n```"
    },
    {
      "code": "S304",
      "name": "suspicious-insecure-cipher-usage",
      "summary": "Checks for uses of weak or broken cryptographic ciphers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-insecure-cipher-usage/",
      "whyBad": "Weak or broken cryptographic ciphers may be susceptible to attacks that\nallow an attacker to decrypt ciphertext without knowing the key or\notherwise compromise the security of the cipher, such as forgeries.\n\nUse strong, modern cryptographic ciphers instead of weak or broken ones.\n\nIn [preview], this rule will also flag references to insecure ciphers.",
      "example": "```python\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms\n\nalgorithm = algorithms.ARC4(key)\ncipher = Cipher(algorithm, mode=None)\nencryptor = cipher.encryptor()\n```\n\nUse instead:\n```python\nfrom cryptography.fernet import Fernet\n\nfernet = Fernet(key)\n```"
    },
    {
      "code": "S305",
      "name": "suspicious-insecure-cipher-mode-usage",
      "summary": "Checks for uses of weak or broken cryptographic cipher modes.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-insecure-cipher-mode-usage/",
      "whyBad": "Weak or broken cryptographic ciphers may be susceptible to attacks that\nallow an attacker to decrypt ciphertext without knowing the key or\notherwise compromise the security of the cipher, such as forgeries.\n\nUse strong, modern cryptographic ciphers instead of weak or broken ones.\n\nIn [preview], this rule will also flag references to insecure cipher modes.",
      "example": "```python\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\nalgorithm = algorithms.ARC4(key)\ncipher = Cipher(algorithm, mode=modes.ECB(iv))\nencryptor = cipher.encryptor()\n```\n\nUse instead:\n```python\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\nalgorithm = algorithms.ARC4(key)\ncipher = Cipher(algorithm, mode=modes.CTR(iv))\nencryptor = cipher.encryptor()\n```"
    },
    {
      "code": "S306",
      "name": "suspicious-mktemp-usage",
      "summary": "Checks for uses of `tempfile.mktemp`.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-mktemp-usage/",
      "whyBad": "`tempfile.mktemp` returns a pathname of a file that does not exist at the\ntime the call is made; then, the caller is responsible for creating the\nfile and subsequently using it. This is insecure because another process\ncould create a file with the same name between the time the function\nreturns and the time the caller creates the file.\n\n`tempfile.mktemp` is deprecated in favor of `tempfile.mkstemp` which\ncreates the file when it is called. Consider using `tempfile.mkstemp`\ninstead, either directly or via a context manager such as\n`tempfile.TemporaryFile`.\n\nIn [preview], this rule will also flag references to `tempfile.mktemp`.",
      "example": "```python\nimport tempfile\n\ntmp_file = tempfile.mktemp()\nwith open(tmp_file, \"w\") as file:\n    file.write(\"Hello, world!\")\n```\n\nUse instead:\n```python\nimport tempfile\n\nwith tempfile.TemporaryFile() as file:\n    file.write(\"Hello, world!\")\n```"
    },
    {
      "code": "S307",
      "name": "suspicious-eval-usage",
      "summary": "Checks for uses of the builtin `eval()` function.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-eval-usage/",
      "whyBad": "The `eval()` function is insecure as it enables arbitrary code execution.\n\nIf you need to evaluate an expression from a string, consider using\n`ast.literal_eval()` instead, which will raise an exception if the\nexpression is not a valid Python literal.\n\nIn [preview], this rule will also flag references to `eval`.",
      "example": "```python\nx = eval(input(\"Enter a number: \"))\n```\n\nUse instead:\n```python\nfrom ast import literal_eval\n\nx = literal_eval(input(\"Enter a number: \"))\n```"
    },
    {
      "code": "S308",
      "name": "suspicious-mark-safe-usage",
      "summary": "Checks for uses of calls to `django.utils.safestring.mark_safe`.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-mark-safe-usage/",
      "whyBad": "Cross-site scripting (XSS) vulnerabilities allow attackers to execute\narbitrary JavaScript. To guard against XSS attacks, Django templates\nassumes that data is unsafe and automatically escapes malicious strings\nbefore rending them.\n\n`django.utils.safestring.mark_safe` marks a string as safe for use in HTML\ntemplates, bypassing XSS protection. Its usage can be dangerous if the\ncontents of the string are dynamically generated, because it may allow\ncross-site scripting attacks if the string is not properly escaped.\n\nFor dynamically generated strings, consider utilizing\n`django.utils.html.format_html`.\n\nIn [preview], this rule will also flag references to `django.utils.safestring.mark_safe`.",
      "example": "```python\nfrom django.utils.safestring import mark_safe\n\n\ndef render_username(username):\n    return mark_safe(f\"<i>{username}</i>\")  # Dangerous if username is user-provided.\n```\n\nUse instead:\n```python\nfrom django.utils.html import format_html\n\n\ndef render_username(username):\n    return format_html(\"<i>{}</i>\", username)  # username is escaped.\n```"
    },
    {
      "code": "S310",
      "name": "suspicious-url-open-usage",
      "summary": "Checks for instances where URL open functions are used with unexpected schemes.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-url-open-usage/",
      "whyBad": "Some URL open functions allow the use of `file:` or custom schemes (for use\ninstead of `http:` or `https:`). An attacker may be able to use these\nschemes to access or modify unauthorized resources, and cause unexpected\nbehavior.\n\nTo mitigate this risk, audit all uses of URL open functions and ensure that\nonly permitted schemes are used (e.g., allowing `http:` and `https:`, and\ndisallowing `file:` and `ftp:`).\n\nIn [preview], this rule will also flag references to URL open functions.",
      "example": "```python\nfrom urllib.request import urlopen\n\nurl = input(\"Enter a URL: \")\n\nwith urlopen(url) as response:\n    ...\n```\n\nUse instead:\n```python\nfrom urllib.request import urlopen\n\nurl = input(\"Enter a URL: \")\n\nif not url.startswith((\"http:\", \"https:\")):\n    raise ValueError(\"URL must start with 'http:' or 'https:'\")\n\nwith urlopen(url) as response:\n    ...\n```"
    },
    {
      "code": "S311",
      "name": "suspicious-non-cryptographic-random-usage",
      "summary": "Checks for uses of cryptographically weak pseudo-random number generators.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-non-cryptographic-random-usage/",
      "whyBad": "Cryptographically weak pseudo-random number generators are insecure, as they\nare easily predictable. This can allow an attacker to guess the generated\nnumbers and compromise the security of the system.\n\nInstead, use a cryptographically secure pseudo-random number generator\n(such as using the [`secrets` module](https://docs.python.org/3/library/secrets.html))\nwhen generating random numbers for security purposes.\n\nIn [preview], this rule will also flag references to these generators.",
      "example": "```python\nimport random\n\nrandom.randrange(10)\n```\n\nUse instead:\n```python\nimport secrets\n\nsecrets.randbelow(10)\n```"
    },
    {
      "code": "S312",
      "name": "suspicious-telnet-usage",
      "summary": "Checks for the use of Telnet-related functions.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-telnet-usage/",
      "whyBad": "Telnet is considered insecure because it does not encrypt data sent over\nthe connection and is vulnerable to numerous attacks.\n\nInstead, consider using a more secure protocol such as SSH.\n\nIn [preview], this rule will also flag references to Telnet-related functions."
    },
    {
      "code": "S313",
      "name": "suspicious-xmlc-element-tree-usage",
      "summary": "Checks for uses of insecure XML parsers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xmlc-element-tree-usage/",
      "whyBad": "Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\nConsider using the `defusedxml` package when parsing untrusted XML data,\nto protect against XML attacks.\n\nIn [preview], this rule will also flag references to insecure XML parsers.",
      "example": "```python\nfrom xml.etree.cElementTree import parse\n\ntree = parse(\"untrusted.xml\")  # Vulnerable to XML attacks.\n```\n\nUse instead:\n```python\nfrom defusedxml.cElementTree import parse\n\ntree = parse(\"untrusted.xml\")\n```"
    },
    {
      "code": "S314",
      "name": "suspicious-xml-element-tree-usage",
      "summary": "Checks for uses of insecure XML parsers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-element-tree-usage/",
      "whyBad": "Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\nConsider using the `defusedxml` package when parsing untrusted XML data,\nto protect against XML attacks.\n\nIn [preview], this rule will also flag references to insecure XML parsers.",
      "example": "```python\nfrom xml.etree.ElementTree import parse\n\ntree = parse(\"untrusted.xml\")  # Vulnerable to XML attacks.\n```\n\nUse instead:\n```python\nfrom defusedxml.ElementTree import parse\n\ntree = parse(\"untrusted.xml\")\n```"
    },
    {
      "code": "S315",
      "name": "suspicious-xml-expat-reader-usage",
      "summary": "Checks for uses of insecure XML parsers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-expat-reader-usage/",
      "whyBad": "Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\nConsider using the `defusedxml` package when parsing untrusted XML data,\nto protect against XML attacks.\n\nIn [preview], this rule will also flag references to insecure XML parsers.",
      "example": "```python\nfrom xml.sax.expatreader import create_parser\n\nparser = create_parser()\n```\n\nUse instead:\n```python\nfrom defusedxml.sax import create_parser\n\nparser = create_parser()\n```"
    },
    {
      "code": "S316",
      "name": "suspicious-xml-expat-builder-usage",
      "summary": "Checks for uses of insecure XML parsers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-expat-builder-usage/",
      "whyBad": "Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\nConsider using the `defusedxml` package when parsing untrusted XML data,\nto protect against XML attacks.\n\nIn [preview], this rule will also flag references to insecure XML parsers.",
      "example": "```python\nfrom xml.dom.expatbuilder import parse\n\nparse(\"untrusted.xml\")\n```\n\nUse instead:\n```python\nfrom defusedxml.expatbuilder import parse\n\ntree = parse(\"untrusted.xml\")\n```"
    },
    {
      "code": "S317",
      "name": "suspicious-xml-sax-usage",
      "summary": "Checks for uses of insecure XML parsers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-sax-usage/",
      "whyBad": "Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\nConsider using the `defusedxml` package when parsing untrusted XML data,\nto protect against XML attacks.\n\nIn [preview], this rule will also flag references to insecure XML parsers.",
      "example": "```python\nfrom xml.sax import make_parser\n\nmake_parser()\n```\n\nUse instead:\n```python\nfrom defusedxml.sax import make_parser\n\nmake_parser()\n```"
    },
    {
      "code": "S318",
      "name": "suspicious-xml-mini-dom-usage",
      "summary": "Checks for uses of insecure XML parsers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-mini-dom-usage/",
      "whyBad": "Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\nConsider using the `defusedxml` package when parsing untrusted XML data,\nto protect against XML attacks.\n\nIn [preview], this rule will also flag references to insecure XML parsers.",
      "example": "```python\nfrom xml.dom.minidom import parse\n\ncontent = parse(\"untrusted.xml\")\n```\n\nUse instead:\n```python\nfrom defusedxml.minidom import parse\n\ncontent = parse(\"untrusted.xml\")\n```"
    },
    {
      "code": "S319",
      "name": "suspicious-xml-pull-dom-usage",
      "summary": "Checks for uses of insecure XML parsers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-pull-dom-usage/",
      "whyBad": "Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\nConsider using the `defusedxml` package when parsing untrusted XML data,\nto protect against XML attacks.\n\nIn [preview], this rule will also flag references to insecure XML parsers.",
      "example": "```python\nfrom xml.dom.pulldom import parse\n\ncontent = parse(\"untrusted.xml\")\n```\n\nUse instead:\n```python\nfrom defusedxml.pulldom import parse\n\ncontent = parse(\"untrusted.xml\")\n```"
    },
    {
      "code": "S320",
      "name": "suspicious-xmle-tree-usage",
      "summary": "Checks for uses of insecure XML parsers.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xmle-tree-usage/",
      "whyBad": "Many XML parsers are vulnerable to XML attacks (such as entity expansion),\nwhich cause excessive memory and CPU usage by exploiting recursion. An\nattacker could use such methods to access unauthorized resources.\n\nIn [preview], this rule will also flag references to insecure XML parsers.",
      "example": "```python\nfrom lxml import etree\n\ncontent = etree.parse(\"untrusted.xml\")\n```"
    },
    {
      "code": "S321",
      "name": "suspicious-ftp-lib-usage",
      "summary": "Checks for the use of FTP-related functions.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-ftp-lib-usage/",
      "whyBad": "FTP is considered insecure as it does not encrypt data sent over the\nconnection and is thus vulnerable to numerous attacks.\n\nInstead, consider using FTPS (which secures FTP using SSL/TLS) or SFTP.\n\nIn [preview], this rule will also flag references to FTP-related functions."
    },
    {
      "code": "S323",
      "name": "suspicious-unverified-context-usage",
      "summary": "Checks for uses of `ssl._create_unverified_context`.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-unverified-context-usage/",
      "whyBad": "[PEP 476] enabled certificate and hostname validation by default in Python\nstandard library HTTP clients. Previously, Python did not validate\ncertificates by default, which could allow an attacker to perform a \"man in\nthe middle\" attack by intercepting and modifying traffic between client and\nserver.\n\nTo support legacy environments, `ssl._create_unverified_context` reverts to\nthe previous behavior that does perform verification. Otherwise, use\n`ssl.create_default_context` to create a secure context.\n\nIn [preview], this rule will also flag references to `ssl._create_unverified_context`.",
      "example": "```python\nimport ssl\n\ncontext = ssl._create_unverified_context()\n```\n\nUse instead:\n```python\nimport ssl\n\ncontext = ssl.create_default_context()\n```"
    },
    {
      "code": "S324",
      "name": "hashlib-insecure-hash-function",
      "summary": "Checks for uses of weak or broken cryptographic hash functions in\n`hashlib` and `crypt` libraries.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hashlib-insecure-hash-function/",
      "whyBad": "Weak or broken cryptographic hash functions may be susceptible to\ncollision attacks (where two different inputs produce the same hash) or\npre-image attacks (where an attacker can find an input that produces a\ngiven hash). This can lead to security vulnerabilities in applications\nthat rely on these hash functions.\n\nAvoid using weak or broken cryptographic hash functions in security\ncontexts. Instead, use a known secure hash function such as SHA256.\n\nNote: This rule targets the following weak algorithm names in `hashlib`:\n`md4`, `md5`, `sha`, and `sha1`. It also flags uses of `crypt.crypt` and\n`crypt.mksalt` when configured with `METHOD_CRYPT`, `METHOD_MD5`, or\n`METHOD_BLOWFISH`.\n\nIt does not attempt to lint OpenSSL- or platform-specific aliases and OIDs\n(for example: `\"sha-1\"`, `\"ssl3-sha1\"`, `\"ssl3-md5\"`, or\n`\"1.3.14.3.2.26\"`), nor variations with trailing spaces, as the set of\naccepted aliases depends on the underlying OpenSSL version and varies across\nplatforms and Python builds.",
      "example": "```python\nimport hashlib\n\n\ndef certificate_is_valid(certificate: bytes, known_hash: str) -> bool:\n    hash = hashlib.md5(certificate).hexdigest()\n    return hash == known_hash\n```\n\nUse instead:\n```python\nimport hashlib\n\n\ndef certificate_is_valid(certificate: bytes, known_hash: str) -> bool:\n    hash = hashlib.sha256(certificate).hexdigest()\n    return hash == known_hash\n```\n\nor add `usedforsecurity=False` if the hashing algorithm is not used in a security context, e.g.\nas a non-cryptographic one-way compression function:\n```python\nimport hashlib\n\n\ndef certificate_is_valid(certificate: bytes, known_hash: str) -> bool:\n    hash = hashlib.md5(certificate, usedforsecurity=False).hexdigest()\n    return hash == known_hash\n```"
    },
    {
      "code": "S401",
      "name": "suspicious-telnetlib-import",
      "summary": "Checks for imports of the `telnetlib` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-telnetlib-import/",
      "whyBad": "Telnet is considered insecure. It is deprecated since version 3.11, and\nwas removed in version 3.13. Instead, use SSH or another encrypted\nprotocol.",
      "example": "```python\nimport telnetlib\n```"
    },
    {
      "code": "S402",
      "name": "suspicious-ftplib-import",
      "summary": "Checks for imports of the `ftplib` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-ftplib-import/",
      "whyBad": "FTP is considered insecure. Instead, use SSH, SFTP, SCP, or another\nencrypted protocol.",
      "example": "```python\nimport ftplib\n```"
    },
    {
      "code": "S403",
      "name": "suspicious-pickle-import",
      "summary": "Checks for imports of the `pickle`, `cPickle`, `dill`, and `shelve` modules.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-pickle-import/",
      "whyBad": "It is possible to construct malicious pickle data which will execute\narbitrary code during unpickling. Consider possible security implications\nassociated with these modules.",
      "example": "```python\nimport pickle\n```"
    },
    {
      "code": "S404",
      "name": "suspicious-subprocess-import",
      "summary": "Checks for imports of the `subprocess` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-subprocess-import/",
      "whyBad": "It is possible to inject malicious commands into subprocess calls. Consider\npossible security implications associated with this module.",
      "example": "```python\nimport subprocess\n```"
    },
    {
      "code": "S405",
      "name": "suspicious-xml-etree-import",
      "summary": "Checks for imports of the `xml.etree.cElementTree` and `xml.etree.ElementTree` modules",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-etree-import/",
      "whyBad": "Using various methods from these modules to parse untrusted XML data is\nknown to be vulnerable to XML attacks. Replace vulnerable imports with the\nequivalent `defusedxml` package, or make sure `defusedxml.defuse_stdlib()` is\ncalled before parsing XML data.",
      "example": "```python\nimport xml.etree.cElementTree\n```"
    },
    {
      "code": "S406",
      "name": "suspicious-xml-sax-import",
      "summary": "Checks for imports of the `xml.sax` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-sax-import/",
      "whyBad": "Using various methods from these modules to parse untrusted XML data is\nknown to be vulnerable to XML attacks. Replace vulnerable imports with the\nequivalent `defusedxml` package, or make sure `defusedxml.defuse_stdlib()` is\ncalled before parsing XML data.",
      "example": "```python\nimport xml.sax\n```"
    },
    {
      "code": "S407",
      "name": "suspicious-xml-expat-import",
      "summary": "Checks for imports of the `xml.dom.expatbuilder` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-expat-import/",
      "whyBad": "Using various methods from these modules to parse untrusted XML data is\nknown to be vulnerable to XML attacks. Replace vulnerable imports with the\nequivalent `defusedxml` package, or make sure `defusedxml.defuse_stdlib()` is\ncalled before parsing XML data.",
      "example": "```python\nimport xml.dom.expatbuilder\n```"
    },
    {
      "code": "S408",
      "name": "suspicious-xml-minidom-import",
      "summary": "Checks for imports of the `xml.dom.minidom` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-minidom-import/",
      "whyBad": "Using various methods from these modules to parse untrusted XML data is\nknown to be vulnerable to XML attacks. Replace vulnerable imports with the\nequivalent `defusedxml` package, or make sure `defusedxml.defuse_stdlib()` is\ncalled before parsing XML data.",
      "example": "```python\nimport xml.dom.minidom\n```"
    },
    {
      "code": "S409",
      "name": "suspicious-xml-pulldom-import",
      "summary": "Checks for imports of the `xml.dom.pulldom` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xml-pulldom-import/",
      "whyBad": "Using various methods from these modules to parse untrusted XML data is\nknown to be vulnerable to XML attacks. Replace vulnerable imports with the\nequivalent `defusedxml` package, or make sure `defusedxml.defuse_stdlib()` is\ncalled before parsing XML data.",
      "example": "```python\nimport xml.dom.pulldom\n```"
    },
    {
      "code": "S410",
      "name": "suspicious-lxml-import",
      "summary": "Checks for imports of the `lxml` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-lxml-import/",
      "whyBad": "Using various methods from the `lxml` module to parse untrusted XML data is\nknown to be vulnerable to XML attacks. Replace vulnerable imports with the\nequivalent `defusedxml` package.",
      "example": "```python\nimport lxml\n```\n\n[deprecated]: https://github.com/tiran/defusedxml/blob/c7445887f5e1bcea470a16f61369d29870cfcfe1/README.md#defusedxmllxml"
    },
    {
      "code": "S411",
      "name": "suspicious-xmlrpc-import",
      "summary": "Checks for imports of the `xmlrpc` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-xmlrpc-import/",
      "whyBad": "XMLRPC is a particularly dangerous XML module, as it is also concerned with\ncommunicating data over a network. Use the `defused.xmlrpc.monkey_patch()`\nfunction to monkey-patch the `xmlrpclib` module and mitigate remote XML\nattacks.",
      "example": "```python\nimport xmlrpc\n```"
    },
    {
      "code": "S412",
      "name": "suspicious-httpoxy-import",
      "summary": "Checks for imports of `wsgiref.handlers.CGIHandler` and\n`twisted.web.twcgi.CGIScript`.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-httpoxy-import/",
      "whyBad": "httpoxy is a set of vulnerabilities that affect application code running in\nCGI or CGI-like environments. The use of CGI for web applications should be\navoided to prevent this class of attack.",
      "example": "```python\nfrom wsgiref.handlers import CGIHandler\n```"
    },
    {
      "code": "S413",
      "name": "suspicious-pycrypto-import",
      "summary": "Checks for imports of several unsafe cryptography modules.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-pycrypto-import/",
      "whyBad": "The `pycrypto` library is known to have a publicly disclosed buffer\noverflow vulnerability. It is no longer actively maintained and has been\ndeprecated in favor of the `pyca/cryptography` library.",
      "example": "```python\nimport Crypto.Random\n```"
    },
    {
      "code": "S415",
      "name": "suspicious-pyghmi-import",
      "summary": "Checks for imports of the `pyghmi` module.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suspicious-pyghmi-import/",
      "whyBad": "`pyghmi` is an IPMI-related module, but IPMI is considered insecure.\nInstead, use an encrypted protocol.",
      "example": "```python\nimport pyghmi\n```"
    },
    {
      "code": "S501",
      "name": "request-with-no-cert-validation",
      "summary": "Checks for HTTPS requests that disable SSL certificate checks.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/request-with-no-cert-validation/",
      "whyBad": "If SSL certificates are not verified, an attacker could perform a \"man in\nthe middle\" attack by intercepting and modifying traffic between the client\nand server.",
      "example": "```python\nimport requests\n\nrequests.get(\"https://www.example.com\", verify=False)\n```\n\nUse instead:\n```python\nimport requests\n\nrequests.get(\"https://www.example.com\")  # By default, `verify=True`.\n```"
    },
    {
      "code": "S502",
      "name": "ssl-insecure-version",
      "summary": "Checks for function calls with parameters that indicate the use of insecure\nSSL and TLS protocol versions.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ssl-insecure-version/",
      "whyBad": "Several highly publicized exploitable flaws have been discovered in all\nversions of SSL and early versions of TLS. The following versions are\nconsidered insecure, and should be avoided:\n- SSL v2\n- SSL v3\n- TLS v1\n- TLS v1.1\n\nThis method supports detection on the Python's built-in `ssl` module and\nthe `pyOpenSSL` module.",
      "example": "```python\nimport ssl\n\nssl.wrap_socket(ssl_version=ssl.PROTOCOL_TLSv1)\n```\n\nUse instead:\n```python\nimport ssl\n\nssl.wrap_socket(ssl_version=ssl.PROTOCOL_TLSv1_2)\n```"
    },
    {
      "code": "S503",
      "name": "ssl-with-bad-defaults",
      "summary": "Checks for function definitions with default arguments set to insecure SSL\nand TLS protocol versions.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ssl-with-bad-defaults/",
      "whyBad": "Several highly publicized exploitable flaws have been discovered in all\nversions of SSL and early versions of TLS. The following versions are\nconsidered insecure, and should be avoided:\n- SSL v2\n- SSL v3\n- TLS v1\n- TLS v1.1",
      "example": "```python\nimport ssl\n\n\ndef func(version=ssl.PROTOCOL_TLSv1): ...\n```\n\nUse instead:\n\n```python\nimport ssl\n\n\ndef func(version=ssl.PROTOCOL_TLSv1_2): ...\n```"
    },
    {
      "code": "S504",
      "name": "ssl-with-no-version",
      "summary": "Checks for calls to `ssl.wrap_socket()` without an `ssl_version`.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ssl-with-no-version/",
      "whyBad": "This method is known to provide a default value that maximizes\ncompatibility, but permits use of insecure protocols.",
      "example": "```python\nimport ssl\n\nssl.wrap_socket()\n```\n\nUse instead:\n```python\nimport ssl\n\nssl.wrap_socket(ssl_version=ssl.PROTOCOL_TLSv1_2)\n```"
    },
    {
      "code": "S505",
      "name": "weak-cryptographic-key",
      "summary": "Checks for uses of cryptographic keys with vulnerable key sizes.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/weak-cryptographic-key/",
      "whyBad": "Small keys are easily breakable. For DSA and RSA, keys should be at least\n2048 bits long. For EC, keys should be at least 224 bits long.",
      "example": "```python\nfrom cryptography.hazmat.primitives.asymmetric import dsa, ec\n\ndsa.generate_private_key(key_size=512)\nec.generate_private_key(curve=ec.SECT163K1())\n```\n\nUse instead:\n```python\nfrom cryptography.hazmat.primitives.asymmetric import dsa, ec\n\ndsa.generate_private_key(key_size=4096)\nec.generate_private_key(curve=ec.SECP384R1())\n```"
    },
    {
      "code": "S506",
      "name": "unsafe-yaml-load",
      "summary": "Checks for uses of the `yaml.load` function.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unsafe-yaml-load/",
      "whyBad": "Running the `yaml.load` function over untrusted YAML files is insecure, as\n`yaml.load` allows for the creation of arbitrary Python objects, which can\nthen be used to execute arbitrary code.\n\nInstead, consider using `yaml.safe_load`, which allows for the creation of\nsimple Python objects like integers and lists, but prohibits the creation of\nmore complex objects like functions and classes.",
      "example": "```python\nimport yaml\n\nyaml.load(untrusted_yaml)\n```\n\nUse instead:\n```python\nimport yaml\n\nyaml.safe_load(untrusted_yaml)\n```"
    },
    {
      "code": "S507",
      "name": "ssh-no-host-key-verification",
      "summary": "Checks for uses of policies disabling SSH verification in Paramiko.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ssh-no-host-key-verification/",
      "whyBad": "By default, Paramiko checks the identity of the remote host when establishing\nan SSH connection. Disabling the verification might lead to the client\nconnecting to a malicious host, without the client knowing.",
      "example": "```python\nfrom paramiko import client\n\nssh_client = client.SSHClient()\nssh_client.set_missing_host_key_policy(client.AutoAddPolicy)\n```\n\nUse instead:\n```python\nfrom paramiko import client\n\nssh_client = client.SSHClient()\nssh_client.set_missing_host_key_policy(client.RejectPolicy)\n```"
    },
    {
      "code": "S508",
      "name": "snmp-insecure-version",
      "summary": "Checks for uses of SNMPv1 or SNMPv2.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/snmp-insecure-version/",
      "whyBad": "The SNMPv1 and SNMPv2 protocols are considered insecure as they do\nnot support encryption. Instead, prefer SNMPv3, which supports\nencryption.",
      "example": "```python\nfrom pysnmp.hlapi import CommunityData\n\nCommunityData(\"public\", mpModel=0)\n```\n\nUse instead:\n```python\nfrom pysnmp.hlapi import CommunityData\n\nCommunityData(\"public\", mpModel=2)\n```"
    },
    {
      "code": "S509",
      "name": "snmp-weak-cryptography",
      "summary": "Checks for uses of the SNMPv3 protocol without encryption.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/snmp-weak-cryptography/",
      "whyBad": "Unencrypted SNMPv3 communication can be intercepted and read by\nunauthorized parties. Instead, enable encryption when using SNMPv3.",
      "example": "```python\nfrom pysnmp.hlapi import UsmUserData\n\nUsmUserData(\"user\")\n```\n\nUse instead:\n```python\nfrom pysnmp.hlapi import UsmUserData\n\nUsmUserData(\"user\", \"authkey\", \"privkey\")\n```"
    },
    {
      "code": "S601",
      "name": "paramiko-call",
      "summary": "Checks for `paramiko` calls.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/paramiko-call/",
      "whyBad": "`paramiko` calls allow users to execute arbitrary shell commands on a\nremote machine. If the inputs to these calls are not properly sanitized,\nthey can be vulnerable to shell injection attacks.",
      "example": "```python\nimport paramiko\n\nclient = paramiko.SSHClient()\nclient.exec_command(\"echo $HOME\")\n```"
    },
    {
      "code": "S602",
      "name": "subprocess-popen-with-shell-equals-true",
      "summary": "Check for method calls that initiate a subprocess with a shell.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/subprocess-popen-with-shell-equals-true/",
      "whyBad": "Starting a subprocess with a shell can allow attackers to execute arbitrary\nshell commands. Consider starting the process without a shell call and\nsanitize the input to mitigate the risk of shell injection.",
      "example": "```python\nimport subprocess\n\nsubprocess.run(\"ls -l\", shell=True)\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.run([\"ls\", \"-l\"])\n```"
    },
    {
      "code": "S603",
      "name": "subprocess-without-shell-equals-true",
      "summary": "Check for method calls that initiate a subprocess without a shell.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/subprocess-without-shell-equals-true/",
      "whyBad": "Starting a subprocess without a shell can prevent attackers from executing\narbitrary shell commands; however, it is still error-prone. Consider\nvalidating the input.",
      "example": "```python\nimport subprocess\n\ncmd = input(\"Enter a command: \").split()\nsubprocess.run(cmd)\n```"
    },
    {
      "code": "S604",
      "name": "call-with-shell-equals-true",
      "summary": "Checks for method calls that set the `shell` parameter to `true` or another\ntruthy value when invoking a subprocess.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-with-shell-equals-true/",
      "whyBad": "Setting the `shell` parameter to `true` or another truthy value when\ninvoking a subprocess can introduce security vulnerabilities, as it allows\nshell metacharacters and whitespace to be passed to child processes,\npotentially leading to shell injection attacks.\n\nIt is recommended to avoid using `shell=True` unless absolutely necessary\nand, when used, to ensure that all inputs are properly sanitized and quoted\nto prevent such vulnerabilities.",
      "example": "```python\nimport my_custom_subprocess\n\nuser_input = input(\"Enter a command: \")\nmy_custom_subprocess.run(user_input, shell=True)\n```"
    },
    {
      "code": "S605",
      "name": "start-process-with-a-shell",
      "summary": "Checks for calls that start a process with a shell, providing guidance on\nwhether the usage is safe or not.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/start-process-with-a-shell/",
      "whyBad": "Starting a process with a shell can introduce security risks, such as\ncode injection vulnerabilities. It's important to be aware of whether the\nusage of the shell is safe or not.\n\nThis rule triggers on functions like `os.system`, `popen`, etc., which\nstart processes with a shell. It evaluates whether the provided command\nis a literal string or an expression. If the command is a literal string,\nit's considered safe. If the command is an expression, it's considered\n(potentially) unsafe.",
      "example": "```python\nimport os\n\n# Safe usage (literal string)\ncommand = \"ls -l\"\nos.system(command)\n\n# Potentially unsafe usage (expression)\ncmd = get_user_input()\nos.system(cmd)\n```"
    },
    {
      "code": "S606",
      "name": "start-process-with-no-shell",
      "summary": "Checks for functions that start a process without a shell.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/start-process-with-no-shell/",
      "whyBad": "Invoking any kind of external executable via a function call can pose\nsecurity risks if arbitrary variables are passed to the executable, or if\nthe input is otherwise unsanitised or unvalidated.\n\nThis rule specifically flags functions in the `os` module that spawn\nsubprocesses *without* the use of a shell. Note that these typically pose a\nmuch smaller security risk than subprocesses that are started *with* a\nshell, which are flagged by [`start-process-with-a-shell`][S605] (`S605`).\nThis gives you the option of enabling one rule while disabling the other\nif you decide that the security risk from these functions is acceptable\nfor your use case.",
      "example": "```python\nimport os\n\n\ndef insecure_function(arbitrary_user_input: str):\n    os.spawnlp(os.P_NOWAIT, \"/bin/mycmd\", \"mycmd\", arbitrary_user_input)\n```\n\n[S605]: https://docs.astral.sh/ruff/rules/start-process-with-a-shell"
    },
    {
      "code": "S607",
      "name": "start-process-with-partial-path",
      "summary": "Checks for the starting of a process with a partial executable path.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/start-process-with-partial-path/",
      "whyBad": "Starting a process with a partial executable path can allow attackers to\nexecute an arbitrary executable by adjusting the `PATH` environment variable.\nConsider using a full path to the executable instead.",
      "example": "```python\nimport subprocess\n\nsubprocess.Popen([\"ruff\", \"check\", \"file.py\"])\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.Popen([\"/usr/bin/ruff\", \"check\", \"file.py\"])\n```"
    },
    {
      "code": "S608",
      "name": "hardcoded-sql-expression",
      "summary": "Checks for strings that resemble SQL statements involved in some form\nstring building operation.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hardcoded-sql-expression/",
      "whyBad": "SQL injection is a common attack vector for web applications. Directly\ninterpolating user input into SQL statements should always be avoided.\nInstead, favor parameterized queries, in which the SQL statement is\nprovided separately from its parameters, as supported by `psycopg3`\nand other database drivers and ORMs.",
      "example": "```python\nquery = \"DELETE FROM foo WHERE id = '%s'\" % identifier\n```"
    },
    {
      "code": "S609",
      "name": "unix-command-wildcard-injection",
      "summary": "Checks for possible wildcard injections in calls to `subprocess.Popen()`.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unix-command-wildcard-injection/",
      "whyBad": "Wildcard injections can lead to unexpected behavior if unintended files are\nmatched by the wildcard. Consider using a more specific path instead.",
      "example": "```python\nimport subprocess\n\nsubprocess.Popen([\"chmod\", \"777\", \"*.py\"], shell=True)\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.Popen([\"chmod\", \"777\", \"main.py\"], shell=True)\n```"
    },
    {
      "code": "S610",
      "name": "django-extra",
      "summary": "Checks for uses of Django's `extra` function where one or more arguments\npassed are not literal expressions.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-extra/",
      "whyBad": "Django's `extra` function can be used to execute arbitrary SQL queries,\nwhich can in turn lead to SQL injection vulnerabilities.",
      "example": "```python\nfrom django.contrib.auth.models import User\n\n# String interpolation creates a security loophole that could be used"
    },
    {
      "code": "S611",
      "name": "django-raw-sql",
      "summary": "Checks for uses of Django's `RawSQL` function.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-raw-sql/",
      "whyBad": "Django's `RawSQL` function can be used to execute arbitrary SQL queries,\nwhich can in turn lead to SQL injection vulnerabilities.",
      "example": "```python\nfrom django.db.models.expressions import RawSQL\nfrom django.contrib.auth.models import User\n\nUser.objects.annotate(val=RawSQL(\"%s\" % input_param, []))\n```"
    },
    {
      "code": "S612",
      "name": "logging-config-insecure-listen",
      "summary": "Checks for insecure `logging.config.listen` calls.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-config-insecure-listen/",
      "whyBad": "`logging.config.listen` starts a server that listens for logging\nconfiguration requests. This is insecure, as parts of the configuration are\npassed to the built-in `eval` function, which can be used to execute\narbitrary code.",
      "example": "```python\nimport logging\n\nlogging.config.listen(9999)\n```"
    },
    {
      "code": "S701",
      "name": "jinja2-autoescape-false",
      "summary": "Checks for `jinja2` templates that use `autoescape=False`.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/jinja2-autoescape-false/",
      "whyBad": "`jinja2` templates that use `autoescape=False` are vulnerable to cross-site\nscripting (XSS) attacks that allow attackers to execute arbitrary\nJavaScript.\n\nBy default, `jinja2` sets `autoescape` to `False`, so it is important to\nset `autoescape=True` or use the `select_autoescape` function to mitigate\nXSS vulnerabilities.",
      "example": "```python\nimport jinja2\n\njinja2.Environment(loader=jinja2.FileSystemLoader(\".\"))\n```\n\nUse instead:\n```python\nimport jinja2\n\njinja2.Environment(loader=jinja2.FileSystemLoader(\".\"), autoescape=True)\n```"
    },
    {
      "code": "S702",
      "name": "mako-templates",
      "summary": "Checks for uses of the `mako` templates.",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mako-templates/",
      "whyBad": "Mako templates allow HTML and JavaScript rendering by default, and are\ninherently open to XSS attacks. Ensure variables in all templates are\nproperly sanitized via the `n`, `h` or `x` flags (depending on context).\nFor example, to HTML escape the variable `data`, use `${ data |h }`.",
      "example": "```python\nfrom mako.template import Template\n\nTemplate(\"hello\")\n```\n\nUse instead:\n```python\nfrom mako.template import Template\n\nTemplate(\"hello |h\")\n```"
    },
    {
      "code": "S704",
      "name": "unsafe-markup-use",
      "summary": "Checks for non-literal strings being passed to [`markupsafe.Markup`][markupsafe-markup].",
      "category": "flake8-bandit",
      "categoryCode": "S",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unsafe-markup-use/",
      "whyBad": "[`markupsafe.Markup`][markupsafe-markup] does not perform any escaping, so passing dynamic\ncontent, like f-strings, variables or interpolated strings will potentially\nlead to XSS vulnerabilities.\n\nInstead you should interpolate the `Markup` object.\n\nUsing [`lint.flake8-bandit.extend-markup-names`] additional objects can be\ntreated like `Markup`.\n\nThis rule was originally inspired by [flake8-markupsafe] but doesn't carve\nout any exceptions for i18n related calls by default.\n\nYou can use [`lint.flake8-bandit.allowed-markup-calls`] to specify exceptions.",
      "example": "Given:\n```python\nfrom markupsafe import Markup\n\ncontent = \"<script>alert('Hello, world!')</script>\"\nhtml = Markup(f\"<b>{content}</b>\")  # XSS\n```\n\nUse instead:\n```python\nfrom markupsafe import Markup\n\ncontent = \"<script>alert('Hello, world!')</script>\"\nhtml = Markup(\"<b>{}</b>\").format(content)  # Safe\n```\n\nGiven:\n```python\nfrom markupsafe import Markup\n\nlines = [\n    Markup(\"<b>heading</b>\"),\n    \"<script>alert('XSS attempt')</script>\",\n]\nhtml = Markup(\"<br>\".join(lines))  # XSS\n```\n\nUse instead:\n```python\nfrom markupsafe import Markup\n\nlines = [\n    Markup(\"<b>heading</b>\"),\n    \"<script>alert('XSS attempt')</script>\",\n]\nhtml = Markup(\"<br>\").join(lines)  # Safe\n```"
    },
    {
      "code": "BLE001",
      "name": "blind-except",
      "summary": "Checks for `except` clauses that catch all exceptions.  This includes\n`except BaseException` and `except Exception`.",
      "category": "flake8-blind-except",
      "categoryCode": "BLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blind-except/",
      "whyBad": "Overly broad `except` clauses can lead to unexpected behavior, such as\ncatching `KeyboardInterrupt` or `SystemExit` exceptions that prevent the\nuser from exiting the program.\n\nInstead of catching all exceptions, catch only those that are expected to\nbe raised in the `try` block.",
      "example": "```python\ntry:\n    foo()\nexcept BaseException:\n    ...\n```\n\nUse instead:\n```python\ntry:\n    foo()\nexcept FileNotFoundError:\n    ...\n```\n\nExceptions that are re-raised will _not_ be flagged, as they're expected to\nbe caught elsewhere:\n```python\ntry:\n    foo()\nexcept BaseException:\n    raise\n```\n\nExceptions that are logged via `logging.exception()` or are logged via\n`logging.error()` or `logging.critical()` with `exc_info` enabled will\n_not_ be flagged, as this is a common pattern for propagating exception\ntraces:\n```python\ntry:\n    foo()\nexcept BaseException:\n    logging.exception(\"Something went wrong\")\n```"
    },
    {
      "code": "FBT001",
      "name": "boolean-type-hint-positional-argument",
      "summary": "Checks for the use of boolean positional arguments in function definitions,\nas determined by the presence of a type hint containing `bool` as an\nevident subtype - e.g. `bool`, `bool | int`, `typing.Optional[bool]`, etc.",
      "category": "flake8-boolean-trap",
      "categoryCode": "FBT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/boolean-type-hint-positional-argument/",
      "whyBad": "Calling a function with boolean positional arguments is confusing as the\nmeaning of the boolean value is not clear to the caller and to future\nreaders of the code.\n\nThe use of a boolean will also limit the function to only two possible\nbehaviors, which makes the function difficult to extend in the future.\n\nInstead, consider refactoring into separate implementations for the\n`True` and `False` cases, using an `Enum`, or making the argument a\nkeyword-only argument, to force callers to be explicit when providing\nthe argument.\n\nDunder methods that define operators are exempt from this rule, as are\nsetters and [`@override`][override] definitions.",
      "example": "```python\nfrom math import ceil, floor\n\n\ndef round_number(number: float, up: bool) -> int:\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, True)  # What does `True` mean?\nround_number(1.5, False)  # What does `False` mean?\n```\n\nInstead, refactor into separate implementations:\n\n```python\nfrom math import ceil, floor\n\n\ndef round_up(number: float) -> int:\n    return ceil(number)\n\n\ndef round_down(number: float) -> int:\n    return floor(number)\n\n\nround_up(1.5)\nround_down(1.5)\n```\n\nOr, refactor to use an `Enum`:\n\n```python\nfrom enum import Enum\n\n\nclass RoundingMethod(Enum):\n    UP = 1\n    DOWN = 2\n\n\ndef round_number(value: float, method: RoundingMethod) -> float: ...\n```\n\nOr, make the argument a keyword-only argument:\n\n```python\nfrom math import ceil, floor\n\n\ndef round_number(number: float, *, up: bool) -> int:\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, up=True)\nround_number(1.5, up=False)\n```"
    },
    {
      "code": "FBT002",
      "name": "boolean-default-value-positional-argument",
      "summary": "Checks for the use of boolean positional arguments in function definitions,\nas determined by the presence of a boolean default value.",
      "category": "flake8-boolean-trap",
      "categoryCode": "FBT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/boolean-default-value-positional-argument/",
      "whyBad": "Calling a function with boolean positional arguments is confusing as the\nmeaning of the boolean value is not clear to the caller and to future\nreaders of the code.\n\nThe use of a boolean will also limit the function to only two possible\nbehaviors, which makes the function difficult to extend in the future.\n\nInstead, consider refactoring into separate implementations for the\n`True` and `False` cases, using an `Enum`, or making the argument a\nkeyword-only argument, to force callers to be explicit when providing\nthe argument.\n\nThis rule exempts methods decorated with [`@typing.override`][override],\nsince changing the signature of a subclass method that overrides a\nsuperclass method may cause type checkers to complain about a violation of\nthe Liskov Substitution Principle.",
      "example": "```python\nfrom math import ceil, floor\n\n\ndef round_number(number, up=True):\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, True)  # What does `True` mean?\nround_number(1.5, False)  # What does `False` mean?\n```\n\nInstead, refactor into separate implementations:\n```python\nfrom math import ceil, floor\n\n\ndef round_up(number):\n    return ceil(number)\n\n\ndef round_down(number):\n    return floor(number)\n\n\nround_up(1.5)\nround_down(1.5)\n```\n\nOr, refactor to use an `Enum`:\n```python\nfrom enum import Enum\n\n\nclass RoundingMethod(Enum):\n    UP = 1\n    DOWN = 2\n\n\ndef round_number(value, method):\n    return ceil(number) if method is RoundingMethod.UP else floor(number)\n\n\nround_number(1.5, RoundingMethod.UP)\nround_number(1.5, RoundingMethod.DOWN)\n```\n\nOr, make the argument a keyword-only argument:\n```python\nfrom math import ceil, floor\n\n\ndef round_number(number, *, up=True):\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, up=True)\nround_number(1.5, up=False)\n```"
    },
    {
      "code": "FBT003",
      "name": "boolean-positional-value-in-call",
      "summary": "Checks for boolean positional arguments in function calls.\n\nSome functions are whitelisted by default. To extend the list of allowed calls\nconfigure the [`lint.flake8-boolean-trap.extend-allowed-calls`] option.",
      "category": "flake8-boolean-trap",
      "categoryCode": "FBT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/boolean-positional-value-in-call/",
      "whyBad": "Calling a function with boolean positional arguments is confusing as the\nmeaning of the boolean value is not clear to the caller, and to future\nreaders of the code.",
      "example": "```python\ndef func(flag: bool) -> None: ...\n\n\nfunc(True)\n```\n\nUse instead:\n\n```python\ndef func(flag: bool) -> None: ...\n\n\nfunc(flag=True)\n```"
    },
    {
      "code": "B002",
      "name": "unary-prefix-increment-decrement",
      "summary": "Checks for the attempted use of the unary prefix increment (`++`) or\ndecrement operator (`--`).",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unary-prefix-increment-decrement/",
      "whyBad": "Python does not support the unary prefix increment or decrement operator.\nWriting `++n` is equivalent to `+(+(n))` and writing `--n` is equivalent to\n`-(-(n))`. In both cases, it is equivalent to `n`.",
      "example": "```python\n++x\n--y\n```\n\nUse instead:\n```python\nx += 1\ny -= 1\n```"
    },
    {
      "code": "B003",
      "name": "assignment-to-os-environ",
      "summary": "Checks for assignments to `os.environ`.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assignment-to-os-environ/",
      "whyBad": "In Python, `os.environ` is a mapping that represents the environment of the\ncurrent process.\n\nHowever, reassigning to `os.environ` does not clear the environment. Instead,\nit merely updates the `os.environ` for the current process. This can lead to\nunexpected behavior, especially when running the program in a subprocess.\n\nInstead, use `os.environ.clear()` to clear the environment, or use the\n`env` argument of `subprocess.Popen` to pass a custom environment to\na subprocess.",
      "example": "```python\nimport os\n\nos.environ = {\"foo\": \"bar\"}\n```\n\nUse instead:\n```python\nimport os\n\nos.environ.clear()\nos.environ[\"foo\"] = \"bar\"\n```"
    },
    {
      "code": "B004",
      "name": "unreliable-callable-check",
      "summary": "Checks for uses of `hasattr` to test if an object is callable (e.g.,\n`hasattr(obj, \"__call__\")`).",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unreliable-callable-check/",
      "whyBad": "Using `hasattr` is an unreliable mechanism for testing if an object is\ncallable. If `obj` implements a custom `__getattr__`, or if its `__call__`\nis itself not callable, you may get misleading results.\n\nInstead, use `callable(obj)` to test if `obj` is callable.",
      "example": "```python\nhasattr(obj, \"__call__\")\n```\n\nUse instead:\n```python\ncallable(obj)\n```"
    },
    {
      "code": "B005",
      "name": "strip-with-multi-characters",
      "summary": "Checks for uses of multi-character strings in `.strip()`, `.lstrip()`, and\n`.rstrip()` calls.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/strip-with-multi-characters/",
      "whyBad": "All characters in the call to `.strip()`, `.lstrip()`, or `.rstrip()` are\nremoved from the leading and trailing ends of the string. If the string\ncontains multiple characters, the reader may be misled into thinking that\na prefix or suffix is being removed, rather than a set of characters.\n\nIn Python 3.9 and later, you can use `str.removeprefix` and\n`str.removesuffix` to remove an exact prefix or suffix from a string,\nrespectively, which should be preferred when possible.",
      "example": "```python\n\"text.txt\".strip(\".txt\")  # \"e\"\n```\n\nUse instead:\n```python\n\"text.txt\".removesuffix(\".txt\")  # \"text\"\n```"
    },
    {
      "code": "B006",
      "name": "mutable-argument-default",
      "summary": "Checks for uses of mutable objects as function argument defaults.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mutable-argument-default/",
      "whyBad": "Function defaults are evaluated once, when the function is defined.\n\nThe same mutable object is then shared across all calls to the function.\nIf the object is modified, those modifications will persist across calls,\nwhich can lead to unexpected behavior.\n\nInstead, prefer to use immutable data structures, or take `None` as a\ndefault, and initialize a new mutable object inside the function body\nfor each call.\n\nArguments with immutable type annotations will be ignored by this rule.\nTypes outside of the standard library can be marked as immutable with the\n[`lint.flake8-bugbear.extend-immutable-calls`] configuration option.",
      "example": "```python\ndef add_to_list(item, some_list=[]):\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [0, 1]\n```\n\nUse instead:\n```python\ndef add_to_list(item, some_list=None):\n    if some_list is None:\n        some_list = []\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [1]\n```"
    },
    {
      "code": "B007",
      "name": "unused-loop-control-variable",
      "summary": "Checks for unused variables in loops (e.g., `for` and `while` statements).",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-loop-control-variable/",
      "whyBad": "Defining a variable in a loop statement that is never used can confuse\nreaders.\n\nIf the variable is intended to be unused (e.g., to facilitate\ndestructuring of a tuple or other object), prefix it with an underscore\nto indicate the intent. Otherwise, remove the variable entirely.",
      "example": "```python\nfor i, j in foo:\n    bar(i)\n```\n\nUse instead:\n```python\nfor i, _j in foo:\n    bar(i)\n```"
    },
    {
      "code": "B008",
      "name": "function-call-in-default-argument",
      "summary": "Checks for function calls in default function arguments.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/function-call-in-default-argument/",
      "whyBad": "Any function call that's used in a default argument will only be performed\nonce, at definition time. The returned value will then be reused by all\ncalls to the function, which can lead to unexpected behaviour.\n\nParameters with immutable type annotations will be ignored by this rule.\nThose whose default arguments are `NewType` calls where the original type\nis immutable are also ignored.\n\nCalls and types outside of the standard library can be marked as an exception\nto this rule with the [`lint.flake8-bugbear.extend-immutable-calls`] configuration option.",
      "example": "```python\ndef create_list() -> list[int]:\n    return [1, 2, 3]\n\n\ndef mutable_default(arg: list[int] = create_list()) -> list[int]:\n    arg.append(4)\n    return arg\n```\n\nUse instead:\n\n```python\ndef better(arg: list[int] | None = None) -> list[int]:\n    if arg is None:\n        arg = create_list()\n\n    arg.append(4)\n    return arg\n```\n\nIf the use of a singleton is intentional, assign the result call to a\nmodule-level variable, and use that variable in the default argument:\n\n```python\nERROR = ValueError(\"Hosts weren't successfully added\")\n\n\ndef add_host(error: Exception = ERROR) -> None: ...\n```"
    },
    {
      "code": "B009",
      "name": "get-attr-with-constant",
      "summary": "Checks for uses of `getattr` that take a constant attribute value as an\nargument (e.g., `getattr(obj, \"foo\")`).",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/get-attr-with-constant/",
      "whyBad": "`getattr` is used to access attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over `getattr` calls, as the former is\nmore concise and idiomatic.",
      "example": "```python\ngetattr(obj, \"foo\")\n```\n\nUse instead:\n```python\nobj.foo\n```"
    },
    {
      "code": "B010",
      "name": "set-attr-with-constant",
      "summary": "Checks for uses of `setattr` that take a constant attribute value as an\nargument (e.g., `setattr(obj, \"foo\", 42)`).",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/set-attr-with-constant/",
      "whyBad": "`setattr` is used to set attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over `setattr` calls, as the former is\nmore concise and idiomatic.",
      "example": "```python\nsetattr(obj, \"foo\", 42)\n```\n\nUse instead:\n```python\nobj.foo = 42\n```"
    },
    {
      "code": "B011",
      "name": "assert-false",
      "summary": "Checks for uses of `assert False`.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assert-false/",
      "whyBad": "Python removes `assert` statements when running in optimized mode\n(`python -O`), making `assert False` an unreliable means of\nraising an `AssertionError`.\n\nInstead, raise an `AssertionError` directly.",
      "example": "```python\nassert False\n```\n\nUse instead:\n```python\nraise AssertionError\n```"
    },
    {
      "code": "B012",
      "name": "jump-statement-in-finally",
      "summary": "Checks for `break`, `continue`, and `return` statements in `finally`\nblocks.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/jump-statement-in-finally/",
      "whyBad": "The use of `break`, `continue`, and `return` statements in `finally` blocks\ncan cause exceptions to be silenced.\n\n`finally` blocks execute regardless of whether an exception is raised. If a\n`break`, `continue`, or `return` statement is reached in a `finally` block,\nany exception raised in the `try` or `except` blocks will be silenced.",
      "example": "```python\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n    finally:\n        return 299792458  # `ValueError` is silenced\n```\n\nUse instead:\n```python\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n```"
    },
    {
      "code": "B013",
      "name": "redundant-tuple-in-exception-handler",
      "summary": "Checks for single-element tuples in exception handlers (e.g.,\n`except (ValueError,):`).\n\nNote: Single-element tuples consisting of a starred expression\nare allowed.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-tuple-in-exception-handler/",
      "whyBad": "A tuple with a single element can be more concisely and idiomatically\nexpressed as a single value.",
      "example": "```python\ntry:\n    ...\nexcept (ValueError,):\n    ...\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept ValueError:\n    ...\n```"
    },
    {
      "code": "B014",
      "name": "duplicate-handler-exception",
      "summary": "Checks for exception handlers that catch duplicate exceptions.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/duplicate-handler-exception/",
      "whyBad": "Including the same exception multiple times in the same handler is redundant,\nas the first exception will catch the exception, making the second exception\nunreachable. The same applies to exception hierarchies, as a handler for a\nparent exception (like `Exception`) will also catch child exceptions (like\n`ValueError`).",
      "example": "```python\ntry:\n    ...\nexcept (Exception, ValueError):  # `Exception` includes `ValueError`.\n    ...\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept Exception:\n    ...\n```"
    },
    {
      "code": "B015",
      "name": "useless-comparison",
      "summary": "Checks for useless comparisons.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-comparison/",
      "whyBad": "Useless comparisons have no effect on the program, and are often included\nby mistake. If the comparison is intended to enforce an invariant, prepend\nthe comparison with an `assert`. Otherwise, remove it entirely.",
      "example": "```python\nfoo == bar\n```\n\nUse instead:\n```python\nassert foo == bar, \"`foo` and `bar` should be equal.\"\n```"
    },
    {
      "code": "B016",
      "name": "raise-literal",
      "summary": "Checks for `raise` statements that raise a literal value.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/raise-literal/",
      "whyBad": "`raise` must be followed by an exception instance or an exception class,\nand exceptions must be instances of `BaseException` or a subclass thereof.\nRaising a literal will raise a `TypeError` at runtime.",
      "example": "```python\nraise \"foo\"\n```\n\nUse instead:\n```python\nraise Exception(\"foo\")\n```"
    },
    {
      "code": "B017",
      "name": "assert-raises-exception",
      "summary": "Checks for `assertRaises` and `pytest.raises` context managers that catch\n`Exception` or `BaseException`.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assert-raises-exception/",
      "whyBad": "These forms catch every `Exception`, which can lead to tests passing even\nif, e.g., the code under consideration raises a `SyntaxError` or\n`IndentationError`.\n\nEither assert for a more specific exception (builtin or custom), or use\n`assertRaisesRegex` or `pytest.raises(..., match=<REGEX>)` respectively.",
      "example": "```python\nself.assertRaises(Exception, foo)\n```\n\nUse instead:\n```python\nself.assertRaises(SomeSpecificException, foo)\n```"
    },
    {
      "code": "B018",
      "name": "useless-expression",
      "summary": "Checks for useless expressions.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-expression/",
      "whyBad": "Useless expressions have no effect on the program, and are often included\nby mistake. Assign a useless expression to a variable, or remove it\nentirely.",
      "example": "```python\n1 + 1\n```\n\nUse instead:\n```python\nfoo = 1 + 1\n```"
    },
    {
      "code": "B019",
      "name": "cached-instance-method",
      "summary": "Checks for uses of the `functools.lru_cache` and `functools.cache`\ndecorators on methods.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/cached-instance-method/",
      "whyBad": "Using the `functools.lru_cache` and `functools.cache` decorators on methods\ncan lead to memory leaks, as the global cache will retain a reference to\nthe instance, preventing it from being garbage collected.\n\nInstead, refactor the method to depend only on its arguments and not on the\ninstance of the class, or use the `@lru_cache` decorator on a function\noutside of the class.\n\nThis rule ignores instance methods on enumeration classes, as enum members\nare singletons.",
      "example": "```python\nfrom functools import lru_cache\n\n\ndef square(x: int) -> int:\n    return x * x\n\n\nclass Number:\n    value: int\n\n    @lru_cache\n    def squared(self):\n        return square(self.value)\n```\n\nUse instead:\n```python\nfrom functools import lru_cache\n\n\n@lru_cache\ndef square(x: int) -> int:\n    return x * x\n\n\nclass Number:\n    value: int\n\n    def squared(self):\n        return square(self.value)\n```"
    },
    {
      "code": "B020",
      "name": "loop-variable-overrides-iterator",
      "summary": "Checks for loop control variables that override the loop iterable.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/loop-variable-overrides-iterator/",
      "whyBad": "Loop control variables should not override the loop iterable, as this can\nlead to confusing behavior.\n\nInstead, use a distinct variable name for any loop control variables.",
      "example": "```python\nitems = [1, 2, 3]\n\nfor items in items:\n    print(items)\n```\n\nUse instead:\n```python\nitems = [1, 2, 3]\n\nfor item in items:\n    print(item)\n```"
    },
    {
      "code": "B021",
      "name": "f-string-docstring",
      "summary": "Checks for docstrings that are written via f-strings.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/f-string-docstring/",
      "whyBad": "Python will interpret the f-string as a joined string, rather than as a\ndocstring. As such, the \"docstring\" will not be accessible via the\n`__doc__` attribute, nor will it be picked up by any automated\ndocumentation tooling.",
      "example": "```python\ndef foo():\n    f\"\"\"Not a docstring.\"\"\"\n```\n\nUse instead:\n```python\ndef foo():\n    \"\"\"A docstring.\"\"\"\n```"
    },
    {
      "code": "B022",
      "name": "useless-contextlib-suppress",
      "summary": "Checks for `contextlib.suppress` without arguments.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-contextlib-suppress/",
      "whyBad": "`contextlib.suppress` is a context manager that suppresses exceptions. It takes,\nas arguments, the exceptions to suppress within the enclosed block. If no\nexceptions are specified, then the context manager won't suppress any\nexceptions, and is thus redundant.\n\nConsider adding exceptions to the `contextlib.suppress` call, or removing the\ncontext manager entirely.",
      "example": "```python\nimport contextlib\n\nwith contextlib.suppress():\n    foo()\n```\n\nUse instead:\n```python\nimport contextlib\n\nwith contextlib.suppress(Exception):\n    foo()\n```"
    },
    {
      "code": "B023",
      "name": "function-uses-loop-variable",
      "summary": "Checks for function definitions that use a loop variable.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/function-uses-loop-variable/",
      "whyBad": "The loop variable is not bound in the function definition, so it will always\nhave the value it had in the last iteration when the function is called.\n\nInstead, consider using a default argument to bind the loop variable at\nfunction definition time. Or, use `functools.partial`.",
      "example": "```python\nadders = [lambda x: x + i for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [3, 3, 3]\n```\n\nUse instead:\n```python\nadders = [lambda x, i=i: x + i for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [1, 2, 3]\n```\n\nOr:\n```python\nfrom functools import partial\n\nadders = [partial(lambda x, i: x + i, i=i) for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [1, 2, 3]\n```"
    },
    {
      "code": "B024",
      "name": "abstract-base-class-without-abstract-method",
      "summary": "Checks for abstract classes without abstract methods or properties.\nAnnotated but unassigned class variables are regarded as abstract.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/abstract-base-class-without-abstract-method/",
      "whyBad": "Abstract base classes are used to define interfaces. If an abstract base\nclass has no abstract methods or properties, you may have forgotten\nto add an abstract method or property to the class,\nor omitted an `@abstractmethod` decorator.\n\nIf the class is _not_ meant to be used as an interface, consider removing\nthe `ABC` base class from the class definition.",
      "example": "```python\nfrom abc import ABC\nfrom typing import ClassVar\n\n\nclass Foo(ABC):\n    class_var: ClassVar[str] = \"assigned\"\n\n    def method(self):\n        bar()\n```\n\nUse instead:\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import ClassVar\n\n\nclass Foo(ABC):\n    class_var: ClassVar[str]  # unassigned\n\n    @abstractmethod\n    def method(self):\n        bar()\n```"
    },
    {
      "code": "B025",
      "name": "duplicate-try-block-exception",
      "summary": "Checks for `try-except` blocks with duplicate exception handlers.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/duplicate-try-block-exception/",
      "whyBad": "Duplicate exception handlers are redundant, as the first handler will catch\nthe exception, making the second handler unreachable.",
      "example": "```python\ntry:\n    ...\nexcept ValueError:\n    ...\nexcept ValueError:\n    ...\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept ValueError:\n    ...\n```"
    },
    {
      "code": "B026",
      "name": "star-arg-unpacking-after-keyword-arg",
      "summary": "Checks for function calls that use star-argument unpacking after providing a\nkeyword argument",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/star-arg-unpacking-after-keyword-arg/",
      "whyBad": "In Python, you can use star-argument unpacking to pass a list or tuple of\narguments to a function.\n\nProviding a star-argument after a keyword argument can lead to confusing\nbehavior, and is only supported for backwards compatibility.",
      "example": "```python\ndef foo(x, y, z):\n    return x, y, z\n\n\nfoo(1, 2, 3)  # (1, 2, 3)\nfoo(1, *[2, 3])  # (1, 2, 3)"
    },
    {
      "code": "B027",
      "name": "empty-method-without-abstract-decorator",
      "summary": "Checks for empty methods in abstract base classes without an abstract\ndecorator.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/empty-method-without-abstract-decorator/",
      "whyBad": "Empty methods in abstract base classes without an abstract decorator may be\nbe indicative of a mistake. If the method is meant to be abstract, add an\n`@abstractmethod` decorator to the method.",
      "example": "```python\nfrom abc import ABC\n\n\nclass Foo(ABC):\n    def method(self): ...\n```\n\nUse instead:\n\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Foo(ABC):\n    @abstractmethod\n    def method(self): ...\n```"
    },
    {
      "code": "B028",
      "name": "no-explicit-stacklevel",
      "summary": "Checks for `warnings.warn` calls without an explicit `stacklevel` keyword\nargument.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-explicit-stacklevel/",
      "whyBad": "The `warnings.warn` method uses a `stacklevel` of 1 by default, which\nwill output a stack frame of the line on which the \"warn\" method\nis called. Setting it to a higher number will output a stack frame\nfrom higher up the stack.\n\nIt's recommended to use a `stacklevel` of 2 or higher, to give the caller\nmore context about the warning.",
      "example": "```python\nimport warnings\n\nwarnings.warn(\"This is a warning\")\n```\n\nUse instead:\n```python\nimport warnings\n\nwarnings.warn(\"This is a warning\", stacklevel=2)\n```"
    },
    {
      "code": "B029",
      "name": "except-with-empty-tuple",
      "summary": "Checks for exception handlers that catch an empty tuple.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/except-with-empty-tuple/",
      "whyBad": "An exception handler that catches an empty tuple will not catch anything,\nand is indicative of a mistake. Instead, add exceptions to the `except`\nclause.",
      "example": "```python\ntry:\n    1 / 0\nexcept ():\n    ...\n```\n\nUse instead:\n```python\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    ...\n```"
    },
    {
      "code": "B030",
      "name": "except-with-non-exception-classes",
      "summary": "Checks for exception handlers that catch non-exception classes.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/except-with-non-exception-classes/",
      "whyBad": "Catching classes that do not inherit from `BaseException` will raise a\n`TypeError`.",
      "example": "```python\ntry:\n    1 / 0\nexcept 1:\n    ...\n```\n\nUse instead:\n```python\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    ...\n```"
    },
    {
      "code": "B031",
      "name": "reuse-of-groupby-generator",
      "summary": "Checks for multiple usage of the generator returned from\n`itertools.groupby()`.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/reuse-of-groupby-generator/",
      "whyBad": "Using the generator more than once will do nothing on the second usage.\nIf that data is needed later, it should be stored as a list."
    },
    {
      "code": "B032",
      "name": "unintentional-type-annotation",
      "summary": "Checks for the unintentional use of type annotations.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unintentional-type-annotation/",
      "whyBad": "The use of a colon (`:`) in lieu of an assignment (`=`) can be syntactically valid, but\nis almost certainly a mistake when used in a subscript or attribute assignment.",
      "example": "```python\na[\"b\"]: 1\n```\n\nUse instead:\n```python\na[\"b\"] = 1\n```"
    },
    {
      "code": "B033",
      "name": "duplicate-value",
      "summary": "Checks for set literals that contain duplicate items.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/duplicate-value/",
      "whyBad": "In Python, sets are unordered collections of unique elements. Including a\nduplicate item in a set literal is redundant, as the duplicate item will be\nreplaced with a single item at runtime.",
      "example": "```python\n{1, 2, 3, 1}\n```\n\nUse instead:\n```python\n{1, 2, 3}\n```"
    },
    {
      "code": "B034",
      "name": "re-sub-positional-args",
      "summary": "Checks for calls to `re.sub`, `re.subn`, and `re.split` that pass `count`,\n`maxsplit`, or `flags` as positional arguments.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/re-sub-positional-args/",
      "whyBad": "Passing `count`, `maxsplit`, or `flags` as positional arguments to\n`re.sub`, `re.subn`, or `re.split` can lead to confusion, as most methods in\nthe `re` module accept `flags` as the third positional argument, while\n`re.sub`, `re.subn`, and `re.split` have different signatures.\n\nInstead, pass `count`, `maxsplit`, and `flags` as keyword arguments.",
      "example": "```python\nimport re\n\nre.split(\"pattern\", \"replacement\", 1)\n```\n\nUse instead:\n```python\nimport re\n\nre.split(\"pattern\", \"replacement\", maxsplit=1)\n```"
    },
    {
      "code": "B035",
      "name": "static-key-dict-comprehension",
      "summary": "Checks for dictionary comprehensions that use a static key, like a string\nliteral or a variable defined outside the comprehension.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/static-key-dict-comprehension/",
      "whyBad": "Using a static key (like a string literal) in a dictionary comprehension\nis usually a mistake, as it will result in a dictionary with only one key,\ndespite the comprehension iterating over multiple values.",
      "example": "```python\ndata = [\"some\", \"Data\"]\n{\"key\": value.upper() for value in data}\n```\n\nUse instead:\n```python\ndata = [\"some\", \"Data\"]\n{value: value.upper() for value in data}\n```"
    },
    {
      "code": "B039",
      "name": "mutable-contextvar-default",
      "summary": "Checks for uses of mutable objects as `ContextVar` defaults.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mutable-contextvar-default/",
      "whyBad": "The `ContextVar` default is evaluated once, when the `ContextVar` is defined.\n\nThe same mutable object is then shared across all `.get()` method calls to\nthe `ContextVar`. If the object is modified, those modifications will persist\nacross calls, which can lead to unexpected behavior.\n\nInstead, prefer to use immutable data structures. Alternatively, take\n`None` as a default, and initialize a new mutable object inside for each\ncall using the `.set()` method.\n\nTypes outside the standard library can be marked as immutable with the\n[`lint.flake8-bugbear.extend-immutable-calls`] configuration option.",
      "example": "```python\nfrom contextvars import ContextVar\n\n\ncv: ContextVar[list] = ContextVar(\"cv\", default=[])\n```\n\nUse instead:\n```python\nfrom contextvars import ContextVar\n\n\ncv: ContextVar[list | None] = ContextVar(\"cv\", default=None)\n\n...\n\nif cv.get() is None:\n    cv.set([])\n```"
    },
    {
      "code": "B901",
      "name": "return-in-generator",
      "summary": "Checks for `return {value}` statements in functions that also contain `yield`\nor `yield from` statements.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/return-in-generator/",
      "whyBad": "Using `return {value}` in a generator function was syntactically invalid in\nPython 2. In Python 3 `return {value}` _can_ be used in a generator; however,\nthe combination of `yield` and `return` can lead to confusing behavior, as\nthe `return` statement will cause the generator to raise `StopIteration`\nwith the value provided, rather than returning the value to the caller.\n\nFor example, given:\n```python\nfrom collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        return dir_path.glob(\"*\")\n\n    for file_type in file_types:\n        yield from dir_path.glob(f\"*.{file_type}\")\n```\n\nReaders might assume that `get_file_paths()` would return an iterable of\n`Path` objects in the directory; in reality, though, `list(get_file_paths())`\nevaluates to `[]`, since the `return` statement causes the generator to raise\n`StopIteration` with the value `dir_path.glob(\"*\")`:\n\n```shell\n>>> list(get_file_paths(file_types=[\"cfg\", \"toml\"]))\n[PosixPath('setup.cfg'), PosixPath('pyproject.toml')]\n>>> list(get_file_paths())\n[]\n```\n\nFor intentional uses of `return` in a generator, consider suppressing this\ndiagnostic.",
      "example": "```python\nfrom collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        return dir_path.glob(\"*\")\n\n    for file_type in file_types:\n        yield from dir_path.glob(f\"*.{file_type}\")\n```\n\nUse instead:\n\n```python\nfrom collections.abc import Iterable\nfrom pathlib import Path\n\n\ndef get_file_paths(file_types: Iterable[str] | None = None) -> Iterable[Path]:\n    dir_path = Path(\".\")\n    if file_types is None:\n        yield from dir_path.glob(\"*\")\n    else:\n        for file_type in file_types:\n            yield from dir_path.glob(f\"*.{file_type}\")\n```"
    },
    {
      "code": "B903",
      "name": "class-as-data-structure",
      "summary": "Checks for classes that only have a public `__init__` method,\nwithout base classes and decorators.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/class-as-data-structure/",
      "whyBad": "Classes with just an `__init__` are possibly better off\nbeing a dataclass or a namedtuple, which have less boilerplate.",
      "example": "```python\nclass Point:\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n```\n\nUse instead:\n```python\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n```"
    },
    {
      "code": "B904",
      "name": "raise-without-from-inside-except",
      "summary": "Checks for `raise` statements in exception handlers that lack a `from`\nclause.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/raise-without-from-inside-except/",
      "whyBad": "In Python, `raise` can be used with or without an exception from which the\ncurrent exception is derived. This is known as exception chaining. When\nprinting the stack trace, chained exceptions are displayed in such a way\nso as make it easier to trace the exception back to its root cause.\n\nWhen raising an exception from within an `except` clause, always include a\n`from` clause to facilitate exception chaining. If the exception is not\nchained, it will be difficult to trace the exception back to its root cause.",
      "example": "```python\ntry:\n    ...\nexcept FileNotFoundError:\n    if ...:\n        raise RuntimeError(\"...\")\n    else:\n        raise UserWarning(\"...\")\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept FileNotFoundError as exc:\n    if ...:\n        raise RuntimeError(\"...\") from None\n    else:\n        raise UserWarning(\"...\") from exc\n```"
    },
    {
      "code": "B905",
      "name": "zip-without-explicit-strict",
      "summary": "Checks for `zip` calls without an explicit `strict` parameter when called with two or more iterables, or any starred argument.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/zip-without-explicit-strict/",
      "whyBad": "By default, if the iterables passed to `zip` are of different lengths, the\nresulting iterator will be silently truncated to the length of the shortest\niterable. This can lead to subtle bugs.\n\nPass `strict=True` to raise a `ValueError` if the iterables are of\nnon-uniform length. Alternatively, if the iterables are deliberately of\ndifferent lengths, pass `strict=False` to make the intention explicit.",
      "example": "```python\nzip(a, b)\n```\n\nUse instead:\n```python\nzip(a, b, strict=True)\n```"
    },
    {
      "code": "B909",
      "name": "loop-iterator-mutation",
      "summary": "Checks for mutations to an iterable during a loop iteration.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/loop-iterator-mutation/",
      "whyBad": "When iterating over an iterable, mutating the iterable can lead to unexpected\nbehavior, like skipping elements or infinite loops.",
      "example": "```python\nitems = [1, 2, 3]\n\nfor item in items:\n    print(item)\n\n    # Create an infinite loop by appending to the list.\n    items.append(item)\n```"
    },
    {
      "code": "B911",
      "name": "batched-without-explicit-strict",
      "summary": "Checks for `itertools.batched` calls without an explicit `strict` parameter.",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/batched-without-explicit-strict/",
      "whyBad": "By default, if the length of the iterable is not divisible by\nthe second argument to `itertools.batched`, the last batch\nwill be shorter than the rest.\n\nIn Python 3.13, a `strict` parameter was added which allows controlling if the batches must be of uniform length.\nPass `strict=True` to raise a `ValueError` if the batches are of non-uniform length.\nOtherwise, pass `strict=False` to make the intention explicit.",
      "example": "```python\nimport itertools\n\nitertools.batched(iterable, n)\n```\n\nUse instead if the batches must be of uniform length:\n```python\nimport itertools\n\nitertools.batched(iterable, n, strict=True)\n```\n\nOr if the batches can be of non-uniform length:\n```python\nimport itertools\n\nitertools.batched(iterable, n, strict=False)\n```"
    },
    {
      "code": "B912",
      "name": "map-without-explicit-strict",
      "summary": "Checks for `map` calls without an explicit `strict` parameter when called with two or more iterables, or any starred argument.\n\nThis rule applies to Python 3.14 and later, where `map` accepts a `strict` keyword\nargument. For details, see: [Whats New in Python 3.14](https://docs.python.org/dev/whatsnew/3.14.html).",
      "category": "flake8-bugbear",
      "categoryCode": "B",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/map-without-explicit-strict/",
      "whyBad": "By default, if the iterables passed to `map` are of different lengths, the\nresulting iterator will be silently truncated to the length of the shortest\niterable. This can lead to subtle bugs.\n\nPass `strict=True` to raise a `ValueError` if the iterables are of\nnon-uniform length. Alternatively, if the iterables are deliberately of\ndifferent lengths, pass `strict=False` to make the intention explicit.",
      "example": "```python\nmap(f, a, b)\n```\n\nUse instead:\n```python\nmap(f, a, b, strict=True)\n```"
    },
    {
      "code": "A001",
      "name": "builtin-variable-shadowing",
      "summary": "Checks for variable (and function) assignments that use the same names\nas builtins.",
      "category": "flake8-builtins",
      "categoryCode": "A",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/builtin-variable-shadowing/",
      "whyBad": "Reusing a builtin name for the name of a variable increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the variable for the\nbuiltin and vice versa.\n\nBuiltins can be marked as exceptions to this rule via the\n[`lint.flake8-builtins.ignorelist`] configuration option.",
      "example": "```python\ndef find_max(list_of_lists):\n    max = 0\n    for flat_list in list_of_lists:\n        for value in flat_list:\n            max = max(max, value)  # TypeError: 'int' object is not callable\n    return max\n```\n\nUse instead:\n```python\ndef find_max(list_of_lists):\n    result = 0\n    for flat_list in list_of_lists:\n        for value in flat_list:\n            result = max(result, value)\n    return result\n```"
    },
    {
      "code": "A002",
      "name": "builtin-argument-shadowing",
      "summary": "Checks for function arguments that use the same names as builtins.",
      "category": "flake8-builtins",
      "categoryCode": "A",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/builtin-argument-shadowing/",
      "whyBad": "Reusing a builtin name for the name of an argument increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the argument for the\nbuiltin and vice versa.\n\nFunction definitions decorated with [`@override`][override] or\n[`@overload`][overload] are exempt from this rule by default.\nBuiltins can be marked as exceptions to this rule via the\n[`lint.flake8-builtins.ignorelist`] configuration option.",
      "example": "```python\ndef remove_duplicates(list, list2):\n    result = set()\n    for value in list:\n        result.add(value)\n    for value in list2:\n        result.add(value)\n    return list(result)  # TypeError: 'list' object is not callable\n```\n\nUse instead:\n```python\ndef remove_duplicates(list1, list2):\n    result = set()\n    for value in list1:\n        result.add(value)\n    for value in list2:\n        result.add(value)\n    return list(result)\n```"
    },
    {
      "code": "A003",
      "name": "builtin-attribute-shadowing",
      "summary": "Checks for class attributes and methods that use the same names as\nPython builtins.",
      "category": "flake8-builtins",
      "categoryCode": "A",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/builtin-attribute-shadowing/",
      "whyBad": "Reusing a builtin name for the name of an attribute increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the attribute for the\nbuiltin and vice versa.\n\nSince methods and class attributes typically cannot be referenced directly\nfrom outside the class scope, this rule only applies to those methods\nand attributes that both shadow a builtin _and_ are referenced from within\nthe class scope, as in the following example, where the `list[int]` return\ntype annotation resolves to the `list` method, rather than the builtin:\n\n```python\nclass Class:\n    @staticmethod\n    def list() -> None:\n        pass\n\n    @staticmethod\n    def repeat(value: int, times: int) -> list[int]:\n        return [value] * times\n```\n\nBuiltins can be marked as exceptions to this rule via the\n[`lint.flake8-builtins.ignorelist`] configuration option, or\nconverted to the appropriate dunder method. Methods decorated with\n`@typing.override` or `@typing_extensions.override` are also\nignored.",
      "example": "```python\nclass Class:\n    @staticmethod\n    def list() -> None:\n        pass\n\n    @staticmethod\n    def repeat(value: int, times: int) -> list[int]:\n        return [value] * times\n```"
    },
    {
      "code": "A004",
      "name": "builtin-import-shadowing",
      "summary": "Checks for imports that use the same names as builtins.",
      "category": "flake8-builtins",
      "categoryCode": "A",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/builtin-import-shadowing/",
      "whyBad": "Reusing a builtin for the name of an import increases the difficulty\nof reading and maintaining the code, and can cause non-obvious errors,\nas readers may mistake the variable for the builtin and vice versa.\n\nBuiltins can be marked as exceptions to this rule via the\n[`lint.flake8-builtins.ignorelist`] configuration option.",
      "example": "```python\nfrom rich import print\n\nprint(\"Some message\")\n```\n\nUse instead:\n```python\nfrom rich import print as rich_print\n\nrich_print(\"Some message\")\n```\n\nor:\n```python\nimport rich\n\nrich.print(\"Some message\")\n```"
    },
    {
      "code": "A005",
      "name": "stdlib-module-shadowing",
      "summary": "Checks for modules that use the same names as Python standard-library\nmodules.",
      "category": "flake8-builtins",
      "categoryCode": "A",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/stdlib-module-shadowing/",
      "whyBad": "Reusing a standard-library module name for the name of a module increases\nthe difficulty of reading and maintaining the code, and can cause\nnon-obvious errors. Readers may mistake the first-party module for the\nstandard-library module and vice versa.\n\nStandard-library modules can be marked as exceptions to this rule via the\n[`lint.flake8-builtins.allowed-modules`] configuration option.\n\nBy default, the module path relative to the project root or [`src`] directories is considered,\nso a top-level `logging.py` or `logging/__init__.py` will clash with the builtin `logging`\nmodule, but `utils/logging.py`, for example, will not. With the\n[`lint.flake8-builtins.strict-checking`] option set to `true`, only the last component\nof the module name is considered, so `logging.py`, `utils/logging.py`, and\n`utils/logging/__init__.py` will all trigger the rule.\n\nThis rule is not applied to stub files, as the name of a stub module is out\nof the control of the author of the stub file. Instead, a stub should aim to\nfaithfully emulate the runtime module it is stubbing.\n\nAs of Python 3.13, errors from modules that use the same name as\nstandard-library modules now display a custom message.",
      "example": "```console\n$ touch random.py\n$ python3 -c 'from random import choice'\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\n    from random import choice\nImportError: cannot import name 'choice' from 'random' (consider renaming '/random.py' since it has the same name as the standard library module named 'random' and prevents importing that standard library module)\n```"
    },
    {
      "code": "A006",
      "name": "builtin-lambda-argument-shadowing",
      "summary": "Checks for lambda arguments that use the same names as Python builtins.",
      "category": "flake8-builtins",
      "categoryCode": "A",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/builtin-lambda-argument-shadowing/",
      "whyBad": "Reusing a builtin name for the name of a lambda argument increases the\ndifficulty of reading and maintaining the code and can cause\nnon-obvious errors. Readers may mistake the variable for the\nbuiltin, and vice versa.\n\nBuiltins can be marked as exceptions to this rule via the\n[`lint.flake8-builtins.ignorelist`] configuration option."
    },
    {
      "code": "COM812",
      "name": "missing-trailing-comma",
      "summary": "Checks for the absence of trailing commas.",
      "category": "flake8-commas",
      "categoryCode": "COM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-trailing-comma/",
      "whyBad": "The presence of a trailing comma can reduce diff size when parameters or\nelements are added or removed from function calls, function definitions,\nliterals, etc.",
      "example": "```python\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2\n}\n```\n\nUse instead:\n```python\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n}\n```"
    },
    {
      "code": "COM818",
      "name": "trailing-comma-on-bare-tuple",
      "summary": "Checks for the presence of trailing commas on bare (i.e., unparenthesized)\ntuples.",
      "category": "flake8-commas",
      "categoryCode": "COM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/trailing-comma-on-bare-tuple/",
      "whyBad": "The presence of a misplaced comma will cause Python to interpret the value\nas a tuple, which can lead to unexpected behaviour.",
      "example": "```python\nimport json\n\n\nfoo = json.dumps({\"bar\": 1}),\n```\n\nUse instead:\n```python\nimport json\n\n\nfoo = json.dumps({\"bar\": 1})\n```\n\nIn the event that a tuple is intended, then use instead:\n```python\nimport json\n\n\nfoo = (json.dumps({\"bar\": 1}),)\n```"
    },
    {
      "code": "COM819",
      "name": "prohibited-trailing-comma",
      "summary": "Checks for the presence of prohibited trailing commas.",
      "category": "flake8-commas",
      "categoryCode": "COM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/prohibited-trailing-comma/",
      "whyBad": "Trailing commas are not essential in some cases and can therefore be viewed\nas unnecessary.",
      "example": "```python\nfoo = (1, 2, 3,)\n```\n\nUse instead:\n```python\nfoo = (1, 2, 3)\n```"
    },
    {
      "code": "C400",
      "name": "unnecessary-generator-list",
      "summary": "Checks for unnecessary generators that can be rewritten as list\ncomprehensions (or with `list()` directly).",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-generator-list/",
      "whyBad": "It is unnecessary to use `list()` around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.\n\nFurther, if the comprehension can be removed entirely, as in the case of\n`list(x for x in foo)`, it's better to use `list(foo)` directly, since it's\neven more direct.",
      "example": "```python\nlist(f(x) for x in foo)\nlist(x for x in foo)\nlist((x for x in foo))\n```\n\nUse instead:\n```python\n[f(x) for x in foo]\nlist(foo)\nlist(foo)\n```"
    },
    {
      "code": "C401",
      "name": "unnecessary-generator-set",
      "summary": "Checks for unnecessary generators that can be rewritten as set\ncomprehensions (or with `set()` directly).",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-generator-set/",
      "whyBad": "It is unnecessary to use `set` around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.\n\nFurther, if the comprehension can be removed entirely, as in the case of\n`set(x for x in foo)`, it's better to use `set(foo)` directly, since it's\neven more direct.",
      "example": "```python\nset(f(x) for x in foo)\nset(x for x in foo)\nset((x for x in foo))\n```\n\nUse instead:\n```python\n{f(x) for x in foo}\nset(foo)\nset(foo)\n```"
    },
    {
      "code": "C402",
      "name": "unnecessary-generator-dict",
      "summary": "Checks for unnecessary generators that can be rewritten as dict\ncomprehensions.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-generator-dict/",
      "whyBad": "It is unnecessary to use `dict()` around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.",
      "example": "```python\ndict((x, f(x)) for x in foo)\n```\n\nUse instead:\n```python\n{x: f(x) for x in foo}\n```"
    },
    {
      "code": "C403",
      "name": "unnecessary-list-comprehension-set",
      "summary": "Checks for unnecessary list comprehensions.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-list-comprehension-set/",
      "whyBad": "It's unnecessary to use a list comprehension inside a call to `set()`,\nsince there is an equivalent comprehension for this type.",
      "example": "```python\nset([f(x) for x in foo])\n```\n\nUse instead:\n```python\n{f(x) for x in foo}\n```"
    },
    {
      "code": "C404",
      "name": "unnecessary-list-comprehension-dict",
      "summary": "Checks for unnecessary list comprehensions.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-list-comprehension-dict/",
      "whyBad": "It's unnecessary to use a list comprehension inside a call to `dict()`,\nsince there is an equivalent comprehension for this type.",
      "example": "```python\ndict([(x, f(x)) for x in foo])\n```\n\nUse instead:\n```python\n{x: f(x) for x in foo}\n```"
    },
    {
      "code": "C405",
      "name": "unnecessary-literal-set",
      "summary": "Checks for `set()` calls that take unnecessary list or tuple literals\nas arguments.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-literal-set/",
      "whyBad": "It's unnecessary to use a list or tuple literal within a call to `set()`.\nInstead, the expression can be rewritten as a set literal.",
      "example": "```python\nset([1, 2])\nset((1, 2))\nset([])\n```\n\nUse instead:\n```python\n{1, 2}\n{1, 2}\nset()\n```"
    },
    {
      "code": "C406",
      "name": "unnecessary-literal-dict",
      "summary": "Checks for unnecessary list or tuple literals.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-literal-dict/",
      "whyBad": "It's unnecessary to use a list or tuple literal within a call to `dict()`.\nIt can be rewritten as a dict literal (`{}`).",
      "example": "```python\ndict([(1, 2), (3, 4)])\ndict(((1, 2), (3, 4)))\ndict([])\n```\n\nUse instead:\n```python\n{1: 2, 3: 4}\n{1: 2, 3: 4}\n{}\n```"
    },
    {
      "code": "C408",
      "name": "unnecessary-collection-call",
      "summary": "Checks for unnecessary `dict()`, `list()` or `tuple()` calls that can be\nrewritten as empty literals.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-collection-call/",
      "whyBad": "It's unnecessary to call, e.g., `dict()` as opposed to using an empty\nliteral (`{}`). The former is slower because the name `dict` must be\nlooked up in the global scope in case it has been rebound.",
      "example": "```python\ndict()\ndict(a=1, b=2)\nlist()\ntuple()\n```\n\nUse instead:\n```python\n{}\n{\"a\": 1, \"b\": 2}\n[]\n()\n```"
    },
    {
      "code": "C409",
      "name": "unnecessary-literal-within-tuple-call",
      "summary": "Checks for `tuple` calls that take unnecessary list or tuple literals as\narguments. In [preview], this also includes unnecessary list comprehensions\nwithin tuple calls.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-literal-within-tuple-call/",
      "whyBad": "It's unnecessary to use a list or tuple literal within a `tuple()` call,\nsince there is a literal syntax for these types.\n\nIf a list literal was passed, then it should be rewritten as a `tuple`\nliteral. Otherwise, if a tuple literal was passed, then the outer call\nto `tuple()` should be removed.\n\nIn [preview], this rule also checks for list comprehensions within `tuple()`\ncalls. If a list comprehension is found, it should be rewritten as a\ngenerator expression.",
      "example": "```python\ntuple([1, 2])\ntuple((1, 2))\ntuple([x for x in range(10)])\n```\n\nUse instead:\n```python\n(1, 2)\n(1, 2)\ntuple(x for x in range(10))\n```"
    },
    {
      "code": "C410",
      "name": "unnecessary-literal-within-list-call",
      "summary": "Checks for `list()` calls that take unnecessary list or tuple literals as\narguments.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-literal-within-list-call/",
      "whyBad": "It's unnecessary to use a list or tuple literal within a `list()` call,\nsince there is a literal syntax for these types.\n\nIf a list literal is passed in, then the outer call to `list()` should be\nremoved. Otherwise, if a tuple literal is passed in, then it should be\nrewritten as a list literal.",
      "example": "```python\nlist([1, 2])\nlist((1, 2))\n```\n\nUse instead:\n```python\n[1, 2]\n[1, 2]\n```"
    },
    {
      "code": "C411",
      "name": "unnecessary-list-call",
      "summary": "Checks for unnecessary `list()` calls around list comprehensions.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-list-call/",
      "whyBad": "It is redundant to use a `list()` call around a list comprehension.",
      "example": "```python\nlist([f(x) for x in foo])\n```\n\nUse instead\n```python\n[f(x) for x in foo]\n```"
    },
    {
      "code": "C413",
      "name": "unnecessary-call-around-sorted",
      "summary": "Checks for unnecessary `list()` or `reversed()` calls around `sorted()`\ncalls.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-call-around-sorted/",
      "whyBad": "It is unnecessary to use `list()` around `sorted()`, as the latter already\nreturns a list.\n\nIt is also unnecessary to use `reversed()` around `sorted()`, as the latter\nhas a `reverse` argument that can be used in lieu of an additional\n`reversed()` call.\n\nIn both cases, it's clearer and more efficient to avoid the redundant call.",
      "example": "```python\nreversed(sorted(iterable))\n```\n\nUse instead:\n```python\nsorted(iterable, reverse=True)\n```"
    },
    {
      "code": "C414",
      "name": "unnecessary-double-cast-or-process",
      "summary": "Checks for unnecessary `list()`, `reversed()`, `set()`, `sorted()`, and\n`tuple()` call within `list()`, `set()`, `sorted()`, and `tuple()` calls.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-double-cast-or-process/",
      "whyBad": "It's unnecessary to double-cast or double-process iterables by wrapping\nthe listed functions within an additional `list()`, `set()`, `sorted()`, or\n`tuple()` call. Doing so is redundant and can be confusing for readers.",
      "example": "```python\nlist(tuple(iterable))\n```\n\nUse instead:\n```python\nlist(iterable)\n```\n\nThis rule applies to a variety of functions, including `list()`, `reversed()`,\n`set()`, `sorted()`, and `tuple()`. For example:\n\n- Instead of `list(list(iterable))`, use `list(iterable)`.\n- Instead of `list(tuple(iterable))`, use `list(iterable)`.\n- Instead of `tuple(list(iterable))`, use `tuple(iterable)`.\n- Instead of `tuple(tuple(iterable))`, use `tuple(iterable)`.\n- Instead of `set(set(iterable))`, use `set(iterable)`.\n- Instead of `set(list(iterable))`, use `set(iterable)`.\n- Instead of `set(tuple(iterable))`, use `set(iterable)`.\n- Instead of `set(sorted(iterable))`, use `set(iterable)`.\n- Instead of `set(reversed(iterable))`, use `set(iterable)`.\n- Instead of `sorted(list(iterable))`, use `sorted(iterable)`.\n- Instead of `sorted(tuple(iterable))`, use `sorted(iterable)`.\n- Instead of `sorted(sorted(iterable))`, use `sorted(iterable)`.\n- Instead of `sorted(reversed(iterable))`, use `sorted(iterable)`."
    },
    {
      "code": "C415",
      "name": "unnecessary-subscript-reversal",
      "summary": "Checks for unnecessary subscript reversal of iterable.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-subscript-reversal/",
      "whyBad": "It's unnecessary to reverse the order of an iterable when passing it\ninto `reversed()`, `set()` or `sorted()` functions as they will change\nthe order of the elements again.",
      "example": "```python\nsorted(iterable[::-1])\nset(iterable[::-1])\nreversed(iterable[::-1])\n```\n\nUse instead:\n```python\nsorted(iterable)\nset(iterable)\niterable\n```"
    },
    {
      "code": "C416",
      "name": "unnecessary-comprehension",
      "summary": "Checks for unnecessary dict, list, and set comprehension.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-comprehension/",
      "whyBad": "It's unnecessary to use a dict/list/set comprehension to build a data structure if the\nelements are unchanged. Wrap the iterable with `dict()`, `list()`, or `set()` instead.",
      "example": "```python\n{a: b for a, b in iterable}\n[x for x in iterable]\n{x for x in iterable}\n```\n\nUse instead:\n```python\ndict(iterable)\nlist(iterable)\nset(iterable)\n```"
    },
    {
      "code": "C417",
      "name": "unnecessary-map",
      "summary": "Checks for unnecessary `map()` calls with lambda functions.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-map/",
      "whyBad": "Using `map(func, iterable)` when `func` is a lambda is slower than\nusing a generator expression or a comprehension, as the latter approach\navoids the function call overhead, in addition to being more readable.\n\nThis rule also applies to `map()` calls within `list()`, `set()`, and\n`dict()` calls. For example:\n\n- Instead of `list(map(lambda num: num * 2, nums))`, use\n  `[num * 2 for num in nums]`.\n- Instead of `set(map(lambda num: num % 2 == 0, nums))`, use\n  `{num % 2 == 0 for num in nums}`.\n- Instead of `dict(map(lambda v: (v, v ** 2), values))`, use\n  `{v: v ** 2 for v in values}`.",
      "example": "```python\nmap(lambda x: x + 1, iterable)\n```\n\nUse instead:\n```python\n(x + 1 for x in iterable)\n```"
    },
    {
      "code": "C418",
      "name": "unnecessary-literal-within-dict-call",
      "summary": "Checks for `dict()` calls that take unnecessary dict literals or dict\ncomprehensions as arguments.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-literal-within-dict-call/",
      "whyBad": "It's unnecessary to wrap a dict literal or comprehension within a `dict()`\ncall, since the literal or comprehension syntax already returns a\ndictionary.",
      "example": "```python\ndict({})\ndict({\"a\": 1})\n```\n\nUse instead:\n```python\n{}\n{\"a\": 1}\n```"
    },
    {
      "code": "C419",
      "name": "unnecessary-comprehension-in-call",
      "summary": "Checks for unnecessary list or set comprehensions passed to builtin functions that take an iterable.\n\nSet comprehensions are only a violation in the case where the builtin function does not care about\nduplication of elements in the passed iterable.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-comprehension-in-call/",
      "whyBad": "Many builtin functions (this rule currently covers `any` and `all` in stable, along with `min`,\n`max`, and `sum` in [preview]) accept any iterable, including a generator. Constructing a\ntemporary list via list comprehension is unnecessary and wastes memory for large iterables.\n\n`any` and `all` can also short-circuit iteration, saving a lot of time. The unnecessary\ncomprehension forces a full iteration of the input iterable, giving up the benefits of\nshort-circuiting. For example, compare the performance of `all` with a list comprehension\nagainst that of a generator in a case where an early short-circuit is possible (almost 40x\nfaster):\n\n```console\nIn [1]: %timeit all([i for i in range(1000)])\n8.14 s  25.4 ns per loop (mean  std. dev. of 7 runs, 100,000 loops each)\n\nIn [2]: %timeit all(i for i in range(1000))\n212 ns  0.892 ns per loop (mean  std. dev. of 7 runs, 1,000,000 loops each)\n```\n\nThis performance improvement is due to short-circuiting. If the entire iterable has to be\ntraversed, the comprehension version may even be a bit faster: list allocation overhead is not\nnecessarily greater than generator overhead.\n\nApplying this rule simplifies the code and will usually save memory, but in the absence of\nshort-circuiting it may not improve performance. (It may even slightly regress performance,\nthough the difference will usually be small.)",
      "example": "```python\nany([x.id for x in bar])\nall([x.id for x in bar])\nsum([x.val for x in bar])\nmin([x.val for x in bar])\nmax([x.val for x in bar])\n```\n\nUse instead:\n```python\nany(x.id for x in bar)\nall(x.id for x in bar)\nsum(x.val for x in bar)\nmin(x.val for x in bar)\nmax(x.val for x in bar)\n```"
    },
    {
      "code": "C420",
      "name": "unnecessary-dict-comprehension-for-iterable",
      "summary": "Checks for unnecessary dict comprehension when creating a dictionary from\nan iterable.",
      "category": "flake8-comprehensions",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-dict-comprehension-for-iterable/",
      "whyBad": "It's unnecessary to use a dict comprehension to build a dictionary from\nan iterable when the value is static.\n\nPrefer `dict.fromkeys(iterable)` over `{value: None for value in iterable}`,\nas `dict.fromkeys` is more readable and efficient.",
      "example": "```python\n{a: None for a in iterable}\n{a: 1 for a in iterable}\n```\n\nUse instead:\n```python\ndict.fromkeys(iterable)\ndict.fromkeys(iterable, 1)\n```"
    },
    {
      "code": "CPY001",
      "name": "missing-copyright-notice",
      "summary": "Checks for the absence of copyright notices within Python files.\n\nNote that this check only searches within the first 4096 bytes of the file.",
      "category": "flake8-copyright",
      "categoryCode": "CPY",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-copyright-notice/",
      "whyBad": "In some codebases, it's common to have a license header at the top of every\nfile. This rule ensures that the license header is present."
    },
    {
      "code": "DTZ001",
      "name": "call-datetime-without-tzinfo",
      "summary": "Checks for `datetime` instantiations that do not specify a timezone.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-datetime-without-tzinfo/",
      "whyBad": "`datetime` objects are \"naive\" by default, in that they do not include\ntimezone information. \"Naive\" objects are easy to understand, but ignore\nsome aspects of reality, which can lead to subtle bugs. Timezone-aware\n`datetime` objects are preferred, as they represent a specific moment in\ntime, unlike \"naive\" objects.\n\nBy providing a non-`None` value for `tzinfo`, a `datetime` can be made\ntimezone-aware.",
      "example": "```python\nimport datetime\n\ndatetime.datetime(2000, 1, 1, 0, 0, 0)\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime(2000, 1, 1, 0, 0, 0, tzinfo=datetime.timezone.utc)\n```\n\nOr, on Python 3.11 and later:\n```python\nimport datetime\n\ndatetime.datetime(2000, 1, 1, 0, 0, 0, tzinfo=datetime.UTC)\n```"
    },
    {
      "code": "DTZ002",
      "name": "call-datetime-today",
      "summary": "Checks for usage of `datetime.datetime.today()`.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-datetime-today/",
      "whyBad": "`datetime` objects are \"naive\" by default, in that they do not include\ntimezone information. \"Naive\" objects are easy to understand, but ignore\nsome aspects of reality, which can lead to subtle bugs. Timezone-aware\n`datetime` objects are preferred, as they represent a specific moment in\ntime, unlike \"naive\" objects.\n\n`datetime.datetime.today()` creates a \"naive\" object; instead, use\n`datetime.datetime.now(tz=...)` to create a timezone-aware object.",
      "example": "```python\nimport datetime\n\ndatetime.datetime.today()\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime.now(tz=datetime.timezone.utc)\n```\n\nOr, for Python 3.11 and later:\n```python\nimport datetime\n\ndatetime.datetime.now(tz=datetime.UTC)\n```"
    },
    {
      "code": "DTZ003",
      "name": "call-datetime-utcnow",
      "summary": "Checks for usage of `datetime.datetime.utcnow()`.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-datetime-utcnow/",
      "whyBad": "Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n`datetime.datetime.utcnow()` returns a naive datetime object; instead, use\n`datetime.datetime.now(tz=...)` to create a timezone-aware object.",
      "example": "```python\nimport datetime\n\ndatetime.datetime.utcnow()\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime.now(tz=datetime.timezone.utc)\n```\n\nOr, for Python 3.11 and later:\n```python\nimport datetime\n\ndatetime.datetime.now(tz=datetime.UTC)\n```"
    },
    {
      "code": "DTZ004",
      "name": "call-datetime-utcfromtimestamp",
      "summary": "Checks for usage of `datetime.datetime.utcfromtimestamp()`.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-datetime-utcfromtimestamp/",
      "whyBad": "Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n`datetime.datetime.utcfromtimestamp()` returns a naive datetime\nobject; instead, use `datetime.datetime.fromtimestamp(ts, tz=...)`\nto create a timezone-aware object.",
      "example": "```python\nimport datetime\n\ndatetime.datetime.utcfromtimestamp(946684800)\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.timezone.utc)\n```\n\nOr, on Python 3.11 and later:\n```python\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.UTC)\n```"
    },
    {
      "code": "DTZ005",
      "name": "call-datetime-now-without-tzinfo",
      "summary": "Checks for usages of `datetime.datetime.now()` that do not specify a timezone.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-datetime-now-without-tzinfo/",
      "whyBad": "Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n`datetime.datetime.now()` or `datetime.datetime.now(tz=None)` returns a naive\ndatetime object. Instead, use `datetime.datetime.now(tz=<timezone>)` to create\na timezone-aware object.",
      "example": "```python\nimport datetime\n\ndatetime.datetime.now()\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime.now(tz=datetime.timezone.utc)\n```\n\nOr, for Python 3.11 and later:\n```python\nimport datetime\n\ndatetime.datetime.now(tz=datetime.UTC)\n```"
    },
    {
      "code": "DTZ006",
      "name": "call-datetime-fromtimestamp",
      "summary": "Checks for usage of `datetime.datetime.fromtimestamp()` that do not specify\na timezone.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-datetime-fromtimestamp/",
      "whyBad": "Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n`datetime.datetime.fromtimestamp(ts)` or\n`datetime.datetime.fromtimestampe(ts, tz=None)` returns a naive datetime\nobject. Instead, use `datetime.datetime.fromtimestamp(ts, tz=<timezone>)`\nto create a timezone-aware object.",
      "example": "```python\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800)\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.timezone.utc)\n```\n\nOr, on Python 3.11 and later:\n```python\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.UTC)\n```"
    },
    {
      "code": "DTZ007",
      "name": "call-datetime-strptime-without-zone",
      "summary": "Checks for uses of `datetime.datetime.strptime()` that lead to naive\ndatetime objects.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-datetime-strptime-without-zone/",
      "whyBad": "Python datetime objects can be naive or timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n`datetime.datetime.strptime()` without `%z` returns a naive datetime\nobject. Follow it with `.replace(tzinfo=<timezone>)` or `.astimezone()`.",
      "example": "```python\nimport datetime\n\ndatetime.datetime.strptime(\"2022/01/31\", \"%Y/%m/%d\")\n```\n\nInstead, use `.replace(tzinfo=<timezone>)`:\n```python\nimport datetime\n\ndatetime.datetime.strptime(\"2022/01/31\", \"%Y/%m/%d\").replace(\n    tzinfo=datetime.timezone.utc\n)\n```\n\nOr, use `.astimezone()`:\n```python\nimport datetime\n\ndatetime.datetime.strptime(\"2022/01/31\", \"%Y/%m/%d\").astimezone(datetime.timezone.utc)\n```\n\nOn Python 3.11 and later, `datetime.timezone.utc` can be replaced with\n`datetime.UTC`."
    },
    {
      "code": "DTZ011",
      "name": "call-date-today",
      "summary": "Checks for usage of `datetime.date.today()`.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-date-today/",
      "whyBad": "Python date objects are naive, that is, not timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n`datetime.date.today` returns a naive date object without taking timezones\ninto account. Instead, use `datetime.datetime.now(tz=...).date()` to\ncreate a timezone-aware object and retrieve its date component.",
      "example": "```python\nimport datetime\n\ndatetime.date.today()\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime.now(tz=datetime.timezone.utc).date()\n```\n\nOr, for Python 3.11 and later:\n```python\nimport datetime\n\ndatetime.datetime.now(tz=datetime.UTC).date()\n```"
    },
    {
      "code": "DTZ012",
      "name": "call-date-fromtimestamp",
      "summary": "Checks for usage of `datetime.date.fromtimestamp()`.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/call-date-fromtimestamp/",
      "whyBad": "Python date objects are naive, that is, not timezone-aware. While an aware\nobject represents a specific moment in time, a naive object does not\ncontain enough information to unambiguously locate itself relative to other\ndatetime objects. Since this can lead to errors, it is recommended to\nalways use timezone-aware objects.\n\n`datetime.date.fromtimestamp(ts)` returns a naive date object.\nInstead, use `datetime.datetime.fromtimestamp(ts, tz=...).date()` to\ncreate a timezone-aware datetime object and retrieve its date component.",
      "example": "```python\nimport datetime\n\ndatetime.date.fromtimestamp(946684800)\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.timezone.utc).date()\n```\n\nOr, for Python 3.11 and later:\n```python\nimport datetime\n\ndatetime.datetime.fromtimestamp(946684800, tz=datetime.UTC).date()\n```"
    },
    {
      "code": "DTZ901",
      "name": "datetime-min-max",
      "summary": "Checks for uses of `datetime.datetime.min` and `datetime.datetime.max`.",
      "category": "flake8-datetimez",
      "categoryCode": "DTZ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/datetime-min-max/",
      "whyBad": "`datetime.min` and `datetime.max` are non-timezone-aware datetime objects.\n\nAs such, operations on `datetime.min` and `datetime.max` may behave\nunexpectedly, as in:\n\n```python\nimport datetime\n\n# Timezone: UTC-14\ndatetime.datetime.min.timestamp()  # ValueError: year 0 is out of range\ndatetime.datetime.max.timestamp()  # ValueError: year 10000 is out of range\n```",
      "example": "```python\nimport datetime\n\ndatetime.datetime.max\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.datetime.max.replace(tzinfo=datetime.UTC)\n```"
    },
    {
      "code": "T100",
      "name": "debugger",
      "summary": "Checks for the presence of debugger calls and imports.",
      "category": "flake8-debugger",
      "categoryCode": "T",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/debugger/",
      "whyBad": "Debugger calls and imports should be used for debugging purposes only. The\npresence of a debugger call or import in production code is likely a\nmistake and may cause unintended behavior, such as exposing sensitive\ninformation or causing the program to hang.\n\nInstead, consider using a logging library to log information about the\nprogram's state, and writing tests to verify that the program behaves\nas expected.",
      "example": "```python\ndef foo():\n    breakpoint()\n```"
    },
    {
      "code": "DJ001",
      "name": "django-nullable-model-string-field",
      "summary": "Checks nullable string-based fields (like `CharField` and `TextField`)\nin Django models.",
      "category": "flake8-django",
      "categoryCode": "DJ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-nullable-model-string-field/",
      "whyBad": "If a string-based field is nullable, then your model will have two possible\nrepresentations for \"no data\": `None` and the empty string. This can lead to\nconfusion, as clients of the API have to check for both `None` and the\nempty string when trying to determine if the field has data.\n\nThe Django convention is to use the empty string in lieu of `None` for\nstring-based fields.",
      "example": "```python\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255, null=True)\n```\n\nUse instead:\n```python\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255, default=\"\")\n```"
    },
    {
      "code": "DJ003",
      "name": "django-locals-in-render-function",
      "summary": "Checks for the use of `locals()` in `render` functions.",
      "category": "flake8-django",
      "categoryCode": "DJ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-locals-in-render-function/",
      "whyBad": "Using `locals()` can expose internal variables or other unintentional\ndata to the rendered template.",
      "example": "```python\nfrom django.shortcuts import render\n\n\ndef index(request):\n    posts = Post.objects.all()\n    return render(request, \"app/index.html\", locals())\n```\n\nUse instead:\n```python\nfrom django.shortcuts import render\n\n\ndef index(request):\n    posts = Post.objects.all()\n    context = {\"posts\": posts}\n    return render(request, \"app/index.html\", context)\n```"
    },
    {
      "code": "DJ006",
      "name": "django-exclude-with-model-form",
      "summary": "Checks for the use of `exclude` in Django `ModelForm` classes.",
      "category": "flake8-django",
      "categoryCode": "DJ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-exclude-with-model-form/",
      "whyBad": "If a `ModelForm` includes the `exclude` attribute, any new field that\nis added to the model will automatically be exposed for modification.",
      "example": "```python\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        exclude = [\"author\"]\n```\n\nUse instead:\n```python\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = [\"title\", \"content\"]\n```"
    },
    {
      "code": "DJ007",
      "name": "django-all-with-model-form",
      "summary": "Checks for the use of `fields = \"__all__\"` in Django `ModelForm`\nclasses.",
      "category": "flake8-django",
      "categoryCode": "DJ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-all-with-model-form/",
      "whyBad": "If a `ModelForm` includes the `fields = \"__all__\"` attribute, any new\nfield that is added to the model will automatically be exposed for\nmodification.",
      "example": "```python\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = \"__all__\"\n```\n\nUse instead:\n```python\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = [\"title\", \"content\"]\n```"
    },
    {
      "code": "DJ008",
      "name": "django-model-without-dunder-str",
      "summary": "Checks that a `__str__` method is defined in Django models.",
      "category": "flake8-django",
      "categoryCode": "DJ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-model-without-dunder-str/",
      "whyBad": "Django models should define a `__str__` method to return a string representation\nof the model instance, as Django calls this method to display the object in\nthe Django Admin and elsewhere.\n\nModels without a `__str__` method will display a non-meaningful representation\nof the object in the Django Admin.",
      "example": "```python\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255)\n```\n\nUse instead:\n```python\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255)\n\n    def __str__(self):\n        return f\"{self.field}\"\n```"
    },
    {
      "code": "DJ012",
      "name": "django-unordered-body-content-in-model",
      "summary": "Checks for the order of Model's inner classes, methods, and fields as per\nthe [Django Style Guide].",
      "category": "flake8-django",
      "categoryCode": "DJ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-unordered-body-content-in-model/",
      "whyBad": "The [Django Style Guide] specifies that the order of Model inner classes,\nattributes and methods should be as follows:\n\n1. All database fields\n2. Custom manager attributes\n3. `class Meta`\n4. `def __str__()`\n5. `def save()`\n6. `def get_absolute_url()`\n7. Any custom methods",
      "example": "```python\nfrom django.db import models\n\n\nclass StrBeforeFieldModel(models.Model):\n    class Meta:\n        verbose_name = \"test\"\n        verbose_name_plural = \"tests\"\n\n    def __str__(self):\n        return \"foobar\"\n\n    first_name = models.CharField(max_length=32)\n    last_name = models.CharField(max_length=40)\n```\n\nUse instead:\n```python\nfrom django.db import models\n\n\nclass StrBeforeFieldModel(models.Model):\n    first_name = models.CharField(max_length=32)\n    last_name = models.CharField(max_length=40)\n\n    class Meta:\n        verbose_name = \"test\"\n        verbose_name_plural = \"tests\"\n\n    def __str__(self):\n        return \"foobar\"\n```\n\n[Django Style Guide]: https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#model-style"
    },
    {
      "code": "DJ013",
      "name": "django-non-leading-receiver-decorator",
      "summary": "Checks that Django's `@receiver` decorator is listed first, prior to\nany other decorators.",
      "category": "flake8-django",
      "categoryCode": "DJ",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/django-non-leading-receiver-decorator/",
      "whyBad": "Django's `@receiver` decorator is special in that it does not return\na wrapped function. Rather, `@receiver` connects the decorated function\nto a signal. If any other decorators are listed before `@receiver`,\nthe decorated function will not be connected to the signal.",
      "example": "```python\nfrom django.dispatch import receiver\nfrom django.db.models.signals import post_save\n\n\n@transaction.atomic\n@receiver(post_save, sender=MyModel)\ndef my_handler(sender, instance, created, **kwargs):\n    pass\n```\n\nUse instead:\n```python\nfrom django.dispatch import receiver\nfrom django.db.models.signals import post_save\n\n\n@receiver(post_save, sender=MyModel)\n@transaction.atomic\ndef my_handler(sender, instance, created, **kwargs):\n    pass\n```"
    },
    {
      "code": "EM101",
      "name": "raw-string-in-exception",
      "summary": "Checks for the use of string literals in exception constructors.",
      "category": "flake8-errmsg",
      "categoryCode": "EM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/raw-string-in-exception/",
      "whyBad": "Python includes the `raise` in the default traceback (and formatters\nlike Rich and IPython do too).\n\nBy using a string literal, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.",
      "example": "Given:\n```python\nraise RuntimeError(\"'Some value' is incorrect\")\n```\n\nPython will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(\"'Some value' is incorrect\")\nRuntimeError: 'Some value' is incorrect\n```\n\nInstead, assign the string to a variable:\n```python\nmsg = \"'Some value' is incorrect\"\nraise RuntimeError(msg)\n```\n\nWhich will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n```"
    },
    {
      "code": "EM102",
      "name": "f-string-in-exception",
      "summary": "Checks for the use of f-strings in exception constructors.",
      "category": "flake8-errmsg",
      "categoryCode": "EM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/f-string-in-exception/",
      "whyBad": "Python includes the `raise` in the default traceback (and formatters\nlike Rich and IPython do too).\n\nBy using an f-string, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.",
      "example": "Given:\n```python\nsub = \"Some value\"\nraise RuntimeError(f\"{sub!r} is incorrect\")\n```\n\nPython will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(f\"{sub!r} is incorrect\")\nRuntimeError: 'Some value' is incorrect\n```\n\nInstead, assign the string to a variable:\n```python\nsub = \"Some value\"\nmsg = f\"{sub!r} is incorrect\"\nraise RuntimeError(msg)\n```\n\nWhich will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n```"
    },
    {
      "code": "EM103",
      "name": "dot-format-in-exception",
      "summary": "Checks for the use of `.format` calls on string literals in exception\nconstructors.",
      "category": "flake8-errmsg",
      "categoryCode": "EM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/dot-format-in-exception/",
      "whyBad": "Python includes the `raise` in the default traceback (and formatters\nlike Rich and IPython do too).\n\nBy using a `.format` call, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.",
      "example": "Given:\n```python\nsub = \"Some value\"\nraise RuntimeError(\"'{}' is incorrect\".format(sub))\n```\n\nPython will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(\"'{}' is incorrect\".format(sub))\nRuntimeError: 'Some value' is incorrect\n```\n\nInstead, assign the string to a variable:\n```python\nsub = \"Some value\"\nmsg = \"'{}' is incorrect\".format(sub)\nraise RuntimeError(msg)\n```\n\nWhich will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n```"
    },
    {
      "code": "EXE001",
      "name": "shebang-not-executable",
      "summary": "Checks for a shebang directive in a file that is not executable.",
      "category": "flake8-executable",
      "categoryCode": "EXE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/shebang-not-executable/",
      "whyBad": "In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nThe presence of a shebang suggests that a file is intended to be\nexecutable. If a file contains a shebang but is not executable, then the\nshebang is misleading, or the file is missing the executable bit.\n\nIf the file is meant to be executable, add the executable bit to the file\n(e.g., `chmod +x __main__.py` or `git update-index --chmod=+x __main__.py`).\n\nOtherwise, remove the shebang.\n\nA file is considered executable if it has the executable bit set (i.e., its\npermissions mode intersects with `0o111`). As such, _this rule is only\navailable on Unix-like systems_, and is not enforced on Windows or WSL.",
      "example": "```python\n#!/usr/bin/env python\n```"
    },
    {
      "code": "EXE002",
      "name": "shebang-missing-executable-file",
      "summary": "Checks for executable `.py` files that do not have a shebang.",
      "category": "flake8-executable",
      "categoryCode": "EXE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/shebang-missing-executable-file/",
      "whyBad": "In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nIf a `.py` file is executable, but does not have a shebang, it may be run\nwith the wrong interpreter, or fail to run at all.\n\nIf the file is meant to be executable, add a shebang, as in:\n```python\n#!/usr/bin/env python\n```\n\nOtherwise, remove the executable bit from the file\n(e.g., `chmod -x __main__.py` or `git update-index --chmod=-x __main__.py`).\n\nA file is considered executable if it has the executable bit set (i.e., its\npermissions mode intersects with `0o111`). As such, _this rule is only\navailable on Unix-like systems_, and is not enforced on Windows or WSL."
    },
    {
      "code": "EXE003",
      "name": "shebang-missing-python",
      "summary": "Checks for a shebang directive in `.py` files that does not contain `python`,\n`pytest`, or `uv run`.",
      "category": "flake8-executable",
      "categoryCode": "EXE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/shebang-missing-python/",
      "whyBad": "In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the command that should be used to run the\nscript.\n\nFor Python scripts, if the shebang does not include a command that explicitly\nor implicitly specifies an interpreter, then the file will be executed with\nthe default interpreter, which is likely a mistake.",
      "example": "```python\n#!/usr/bin/env bash\n```\n\nUse instead:\n```python\n#!/usr/bin/env python3\n```"
    },
    {
      "code": "EXE004",
      "name": "shebang-leading-whitespace",
      "summary": "Checks for whitespace before a shebang directive.",
      "category": "flake8-executable",
      "categoryCode": "EXE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/shebang-leading-whitespace/",
      "whyBad": "In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nThe shebang's `#!` prefix must be the first two characters of a file. The\npresence of whitespace before the shebang will cause the shebang to be\nignored, which is likely a mistake.",
      "example": "```python\n #!/usr/bin/env python3\n```\n\nUse instead:\n```python\n#!/usr/bin/env python3\n```"
    },
    {
      "code": "EXE005",
      "name": "shebang-not-first-line",
      "summary": "Checks for a shebang directive that is not at the beginning of the file.",
      "category": "flake8-executable",
      "categoryCode": "EXE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/shebang-not-first-line/",
      "whyBad": "In Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nThe shebang's `#!` prefix must be the first two characters of a file. If\nthe shebang is not at the beginning of the file, it will be ignored, which\nis likely a mistake.",
      "example": "```python\nfoo = 1\n#!/usr/bin/env python3\n```\n\nUse instead:\n```python\n#!/usr/bin/env python3\nfoo = 1\n```"
    },
    {
      "code": "FIX001",
      "name": "line-contains-fixme",
      "summary": "Checks for \"FIXME\" comments.",
      "category": "flake8-fixme",
      "categoryCode": "FIX",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/line-contains-fixme/",
      "whyBad": "\"FIXME\" comments are used to describe an issue that should be resolved\n(usually, a bug or unexpected behavior).\n\nConsider resolving the issue before deploying the code.\n\nNote that if you use \"FIXME\" comments as a form of documentation, this\nrule may not be appropriate for your project.",
      "example": "```python\ndef speed(distance, time):\n    return distance / time  # FIXME: Raises ZeroDivisionError for time = 0.\n```"
    },
    {
      "code": "FIX002",
      "name": "line-contains-todo",
      "summary": "Checks for \"TODO\" comments.",
      "category": "flake8-fixme",
      "categoryCode": "FIX",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/line-contains-todo/",
      "whyBad": "\"TODO\" comments are used to describe an issue that should be resolved\n(usually, a missing feature, optimization, or refactoring opportunity).\n\nConsider resolving the issue before deploying the code.\n\nNote that if you use \"TODO\" comments as a form of documentation (e.g.,\nto [provide context for future work](https://gist.github.com/dmnd/ed5d8ef8de2e4cfea174bd5dafcda382)),\nthis rule may not be appropriate for your project.",
      "example": "```python\ndef greet(name):\n    return f\"Hello, {name}!\"  # TODO: Add support for custom greetings.\n```"
    },
    {
      "code": "FIX003",
      "name": "line-contains-xxx",
      "summary": "Checks for \"XXX\" comments.",
      "category": "flake8-fixme",
      "categoryCode": "FIX",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/line-contains-xxx/",
      "whyBad": "\"XXX\" comments are used to describe an issue that should be resolved.\n\nConsider resolving the issue before deploying the code, or, at minimum,\nusing a more descriptive comment tag (e.g, \"TODO\").",
      "example": "```python\ndef speed(distance, time):\n    return distance / time  # XXX: Raises ZeroDivisionError for time = 0.\n```"
    },
    {
      "code": "FIX004",
      "name": "line-contains-hack",
      "summary": "Checks for \"HACK\" comments.",
      "category": "flake8-fixme",
      "categoryCode": "FIX",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/line-contains-hack/",
      "whyBad": "\"HACK\" comments are used to describe an issue that should be resolved\n(usually, a suboptimal solution or temporary workaround).\n\nConsider resolving the issue before deploying the code.\n\nNote that if you use \"HACK\" comments as a form of documentation, this\nrule may not be appropriate for your project.",
      "example": "```python\nimport os\n\n\ndef running_windows():  # HACK: Use platform module instead.\n    try:\n        os.mkdir(\"C:\\\\Windows\\\\System32\\\\\")\n    except FileExistsError:\n        return True\n    else:\n        os.rmdir(\"C:\\\\Windows\\\\System32\\\\\")\n        return False\n```"
    },
    {
      "code": "FA100",
      "name": "future-rewritable-type-annotation",
      "summary": "Checks for missing `from __future__ import annotations` imports upon\ndetecting type annotations that can be written more succinctly under\nPEP 563.",
      "category": "flake8-future-annotations",
      "categoryCode": "FA",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/future-rewritable-type-annotation/",
      "whyBad": "PEP 585 enabled the use of a number of convenient type annotations, such as\n`list[str]` instead of `List[str]`. However, these annotations are only\navailable on Python 3.9 and higher, _unless_ the `from __future__ import annotations`\nimport is present.\n\nSimilarly, PEP 604 enabled the use of the `|` operator for unions, such as\n`str | None` instead of `Optional[str]`. However, these annotations are only\navailable on Python 3.10 and higher, _unless_ the `from __future__ import annotations`\nimport is present.\n\nBy adding the `__future__` import, the pyupgrade rules can automatically\nmigrate existing code to use the new syntax, even for older Python versions.\nThis rule thus pairs well with pyupgrade and with Ruff's pyupgrade rules.\n\nThis rule respects the [`target-version`] setting. For example, if your\nproject targets Python 3.10 and above, adding `from __future__ import annotations`\ndoes not impact your ability to leverage PEP 604-style unions (e.g., to\nconvert `Optional[str]` to `str | None`). As such, this rule will only\nflag such usages if your project targets Python 3.9 or below.",
      "example": "```python\nfrom typing import List, Dict, Optional\n\n\ndef func(obj: Dict[str, Optional[int]]) -> None: ...\n```\n\nUse instead:\n\n```python\nfrom __future__ import annotations\n\nfrom typing import List, Dict, Optional\n\n\ndef func(obj: Dict[str, Optional[int]]) -> None: ...\n```\n\nAfter running the additional pyupgrade rules:\n\n```python\nfrom __future__ import annotations\n\n\ndef func(obj: dict[str, int | None]) -> None: ...\n```"
    },
    {
      "code": "FA102",
      "name": "future-required-type-annotation",
      "summary": "Checks for uses of PEP 585- and PEP 604-style type annotations in Python\nmodules that lack the required `from __future__ import annotations` import\nfor compatibility with older Python versions.",
      "category": "flake8-future-annotations",
      "categoryCode": "FA",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/future-required-type-annotation/",
      "whyBad": "Using PEP 585 and PEP 604 style annotations without a `from __future__ import\nannotations` import will cause runtime errors on Python versions prior to\n3.9 and 3.10, respectively.\n\nBy adding the `__future__` import, the interpreter will no longer interpret\nannotations at evaluation time, making the code compatible with both past\nand future Python versions.\n\nThis rule respects the [`target-version`] setting. For example, if your\nproject targets Python 3.10 and above, adding `from __future__ import annotations`\ndoes not impact your ability to leverage PEP 604-style unions (e.g., to\nconvert `Optional[str]` to `str | None`). As such, this rule will only\nflag such usages if your project targets Python 3.9 or below.",
      "example": "```python\ndef func(obj: dict[str, int | None]) -> None: ...\n```\n\nUse instead:\n\n```python\nfrom __future__ import annotations\n\n\ndef func(obj: dict[str, int | None]) -> None: ...\n```"
    },
    {
      "code": "INT001",
      "name": "f-string-in-get-text-func-call",
      "summary": "Checks for f-strings in `gettext` function calls.",
      "category": "flake8-gettext",
      "categoryCode": "INT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/f-string-in-get-text-func-call/",
      "whyBad": "In the `gettext` API, the `gettext` function (often aliased to `_`) returns\na translation of its input argument by looking it up in a translation\ncatalog.\n\nCalling `gettext` with an f-string as its argument can cause unexpected\nbehavior. Since the f-string is resolved before the function call, the\ntranslation catalog will look up the formatted string, rather than the\nf-string template.\n\nInstead, format the value returned by the function call, rather than\nits argument.",
      "example": "```python\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(f\"Hello, {name}!\")  # Looks for \"Hello, Maria!\".\n```\n\nUse instead:\n```python\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, %s!\") % name  # Looks for \"Hello, %s!\".\n```"
    },
    {
      "code": "INT002",
      "name": "format-in-get-text-func-call",
      "summary": "Checks for `str.format` calls in `gettext` function calls.",
      "category": "flake8-gettext",
      "categoryCode": "INT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/format-in-get-text-func-call/",
      "whyBad": "In the `gettext` API, the `gettext` function (often aliased to `_`) returns\na translation of its input argument by looking it up in a translation\ncatalog.\n\nCalling `gettext` with a formatted string as its argument can cause\nunexpected behavior. Since the formatted string is resolved before the\nfunction call, the translation catalog will look up the formatted string,\nrather than the `str.format`-style template.\n\nInstead, format the value returned by the function call, rather than\nits argument.",
      "example": "```python\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, {}!\".format(name))  # Looks for \"Hello, Maria!\".\n```\n\nUse instead:\n```python\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, %s!\") % name  # Looks for \"Hello, %s!\".\n```"
    },
    {
      "code": "INT003",
      "name": "printf-in-get-text-func-call",
      "summary": "Checks for printf-style formatted strings in `gettext` function calls.",
      "category": "flake8-gettext",
      "categoryCode": "INT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/printf-in-get-text-func-call/",
      "whyBad": "In the `gettext` API, the `gettext` function (often aliased to `_`) returns\na translation of its input argument by looking it up in a translation\ncatalog.\n\nCalling `gettext` with a formatted string as its argument can cause\nunexpected behavior. Since the formatted string is resolved before the\nfunction call, the translation catalog will look up the formatted string,\nrather than the printf-style template.\n\nInstead, format the value returned by the function call, rather than\nits argument.",
      "example": "```python\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, %s!\" % name)  # Looks for \"Hello, Maria!\".\n```\n\nUse instead:\n```python\nfrom gettext import gettext as _\n\nname = \"Maria\"\n_(\"Hello, %s!\") % name  # Looks for \"Hello, %s!\".\n```"
    },
    {
      "code": "ISC001",
      "name": "single-line-implicit-string-concatenation",
      "summary": "Checks for implicitly concatenated strings on a single line.",
      "category": "flake8-implicit-str-concat",
      "categoryCode": "ISC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/single-line-implicit-string-concatenation/",
      "whyBad": "While it is valid Python syntax to concatenate multiple string or byte\nliterals implicitly (via whitespace delimiters), it is unnecessary and\nnegatively affects code readability.\n\nIn some cases, the implicit concatenation may also be unintentional, as\ncode formatters are capable of introducing single-line implicit\nconcatenations when collapsing long lines.",
      "example": "```python\nz = \"The quick \" \"brown fox.\"\n```\n\nUse instead:\n```python\nz = \"The quick brown fox.\"\n```"
    },
    {
      "code": "ISC002",
      "name": "multi-line-implicit-string-concatenation",
      "summary": "Checks for implicitly concatenated strings that span multiple lines.",
      "category": "flake8-implicit-str-concat",
      "categoryCode": "ISC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multi-line-implicit-string-concatenation/",
      "whyBad": "For string literals that wrap across multiple lines, [PEP 8] recommends\nthe use of implicit string concatenation within parentheses instead of\nusing a backslash for line continuation, as the former is more readable\nthan the latter.\n\nBy default, this rule will only trigger if the string literal is\nconcatenated via a backslash. To disallow implicit string concatenation\naltogether, set the [`lint.flake8-implicit-str-concat.allow-multiline`] option\nto `false`.",
      "example": "```python\nz = \"The quick brown fox jumps over the lazy \"\\\n    \"dog.\"\n```\n\nUse instead:\n```python\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    \"dog.\"\n)\n```"
    },
    {
      "code": "ISC003",
      "name": "explicit-string-concatenation",
      "summary": "Checks for string literals that are explicitly concatenated (using the\n`+` operator).",
      "category": "flake8-implicit-str-concat",
      "categoryCode": "ISC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/explicit-string-concatenation/",
      "whyBad": "For string literals that wrap across multiple lines, implicit string\nconcatenation within parentheses is preferred over explicit\nconcatenation using the `+` operator, as the former is more readable.",
      "example": "```python\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    + \"dog\"\n)\n```\n\nUse instead:\n```python\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    \"dog\"\n)\n```"
    },
    {
      "code": "ISC004",
      "name": "implicit-string-concatenation-in-collection-literal",
      "summary": "Checks for implicitly concatenated strings inside list, tuple, and set literals.",
      "category": "flake8-implicit-str-concat",
      "categoryCode": "ISC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/implicit-string-concatenation-in-collection-literal/",
      "whyBad": "In collection literals, implicit string concatenation is often the result of\na missing comma between elements, which can silently merge items together.",
      "example": "```python\nfacts = (\n    \"Lobsters have blue blood.\",\n    \"The liver is the only human organ that can fully regenerate itself.\",\n    \"Clarinets are made almost entirely out of wood from the mpingo tree.\"\n    \"In 1971, astronaut Alan Shepard played golf on the moon.\",\n)\n```\n\nInstead, you likely intended:\n```python\nfacts = (\n    \"Lobsters have blue blood.\",\n    \"The liver is the only human organ that can fully regenerate itself.\",\n    \"Clarinets are made almost entirely out of wood from the mpingo tree.\",\n    \"In 1971, astronaut Alan Shepard played golf on the moon.\",\n)\n```\n\nIf the concatenation is intentional, wrap it in parentheses to make it\nexplicit:\n```python\nfacts = (\n    \"Lobsters have blue blood.\",\n    \"The liver is the only human organ that can fully regenerate itself.\",\n    (\n        \"Clarinets are made almost entirely out of wood from the mpingo tree.\"\n        \"In 1971, astronaut Alan Shepard played golf on the moon.\"\n    ),\n)\n```"
    },
    {
      "code": "ICN001",
      "name": "unconventional-import-alias",
      "summary": "Checks for imports that are typically imported using a common convention,\nlike `import pandas as pd`, and enforces that convention.",
      "category": "flake8-import-conventions",
      "categoryCode": "ICN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unconventional-import-alias/",
      "whyBad": "Consistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\nFor example, `import pandas as pd` is a common\nconvention for importing the `pandas` library, and users typically expect\nPandas to be aliased as `pd`.",
      "example": "```python\nimport pandas\n```\n\nUse instead:\n```python\nimport pandas as pd\n```"
    },
    {
      "code": "ICN002",
      "name": "banned-import-alias",
      "summary": "Checks for imports that use non-standard naming conventions, like\n`import tensorflow.keras.backend as K`.",
      "category": "flake8-import-conventions",
      "categoryCode": "ICN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/banned-import-alias/",
      "whyBad": "Consistency is good. Avoid using a non-standard naming convention for\nimports, and, in particular, choosing import aliases that violate PEP 8.\n\nFor example, aliasing via `import tensorflow.keras.backend as K` violates\nthe guidance of PEP 8, and is thus avoided in some projects.",
      "example": "```python\nimport tensorflow.keras.backend as K\n```\n\nUse instead:\n```python\nimport tensorflow as tf\n\ntf.keras.backend\n```"
    },
    {
      "code": "ICN003",
      "name": "banned-import-from",
      "summary": "Checks for member imports that should instead be accessed by importing the\nmodule.",
      "category": "flake8-import-conventions",
      "categoryCode": "ICN",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/banned-import-from/",
      "whyBad": "Consistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\nFor example, it's common to import `pandas` as `pd`, and then access\nmembers like `Series` via `pd.Series`, rather than importing `Series`\ndirectly.",
      "example": "```python\nfrom pandas import Series\n```\n\nUse instead:\n```python\nimport pandas as pd\n\npd.Series\n```"
    },
    {
      "code": "LOG001",
      "name": "direct-logger-instantiation",
      "summary": "Checks for direct instantiation of `logging.Logger`, as opposed to using\n`logging.getLogger()`.",
      "category": "flake8-logging",
      "categoryCode": "LOG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/direct-logger-instantiation/",
      "whyBad": "The [Logger Objects] documentation states that:\n\n> Note that Loggers should NEVER be instantiated directly, but always\n> through the module-level function `logging.getLogger(name)`.\n\nIf a logger is directly instantiated, it won't be added to the logger\ntree, and will bypass all configuration. Messages logged to it will\nonly be sent to the \"handler of last resort\", skipping any filtering\nor formatting.",
      "example": "```python\nimport logging\n\nlogger = logging.Logger(__name__)\n```\n\nUse instead:\n```python\nimport logging\n\nlogger = logging.getLogger(__name__)\n```"
    },
    {
      "code": "LOG002",
      "name": "invalid-get-logger-argument",
      "summary": "Checks for any usage of `__cached__` and `__file__` as an argument to\n`logging.getLogger()`.",
      "category": "flake8-logging",
      "categoryCode": "LOG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-get-logger-argument/",
      "whyBad": "The [logging documentation] recommends this pattern:\n\n```python\nlogging.getLogger(__name__)\n```\n\nHere, `__name__` is the fully qualified module name, such as `foo.bar`,\nwhich is the intended format for logger names.\n\nThis rule detects probably-mistaken usage of similar module-level dunder constants:\n\n* `__cached__` - the pathname of the module's compiled version, such as `foo/__pycache__/bar.cpython-311.pyc`.\n* `__file__` - the pathname of the module, such as `foo/bar.py`.",
      "example": "```python\nimport logging\n\nlogger = logging.getLogger(__file__)\n```\n\nUse instead:\n```python\nimport logging\n\nlogger = logging.getLogger(__name__)\n```"
    },
    {
      "code": "LOG004",
      "name": "log-exception-outside-except-handler",
      "summary": "Checks for `.exception()` logging calls outside of exception handlers.",
      "category": "flake8-logging",
      "categoryCode": "LOG",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/log-exception-outside-except-handler/",
      "whyBad": "[The documentation] states:\n> This function should only be called from an exception handler.\n\nCalling `.exception()` outside of an exception handler\nattaches `None` as exception information, leading to confusing messages:\n\n```pycon\n>>> logging.exception(\"example\")\nERROR:root:example\nNoneType: None\n```",
      "example": "```python\nimport logging\n\nlogging.exception(\"Foobar\")\n```\n\nUse instead:\n\n```python\nimport logging\n\nlogging.error(\"Foobar\")\n```"
    },
    {
      "code": "LOG007",
      "name": "exception-without-exc-info",
      "summary": "Checks for uses of `logging.exception()` with `exc_info` set to `False`.",
      "category": "flake8-logging",
      "categoryCode": "LOG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/exception-without-exc-info/",
      "whyBad": "The `logging.exception()` method captures the exception automatically, but\naccepts an optional `exc_info` argument to override this behavior. Setting\n`exc_info` to `False` disables the automatic capture of the exception and\nstack trace.\n\nInstead of setting `exc_info` to `False`, prefer `logging.error()`, which\nhas equivalent behavior to `logging.exception()` with `exc_info` set to\n`False`, but is clearer in intent.",
      "example": "```python\nlogging.exception(\"...\", exc_info=False)\n```\n\nUse instead:\n```python\nlogging.error(\"...\")\n```"
    },
    {
      "code": "LOG009",
      "name": "undocumented-warn",
      "summary": "Checks for uses of `logging.WARN`.",
      "category": "flake8-logging",
      "categoryCode": "LOG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-warn/",
      "whyBad": "The `logging.WARN` constant is an undocumented alias for `logging.WARNING`.\n\nAlthough its not explicitly deprecated, `logging.WARN` is not mentioned\nin the `logging` documentation. Prefer `logging.WARNING` instead.",
      "example": "```python\nimport logging\n\n\nlogging.basicConfig(level=logging.WARN)\n```\n\nUse instead:\n```python\nimport logging\n\n\nlogging.basicConfig(level=logging.WARNING)\n```"
    },
    {
      "code": "LOG014",
      "name": "exc-info-outside-except-handler",
      "summary": "Checks for logging calls with `exc_info=` outside exception handlers.",
      "category": "flake8-logging",
      "categoryCode": "LOG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/exc-info-outside-except-handler/",
      "whyBad": "Using `exc_info=True` outside of an exception handler\nattaches `None` as the exception information, leading to confusing messages:\n\n```pycon\n>>> logging.warning(\"Uh oh\", exc_info=True)\nWARNING:root:Uh oh\nNoneType: None\n```",
      "example": "```python\nimport logging\n\n\nlogging.warning(\"Foobar\", exc_info=True)\n```\n\nUse instead:\n\n```python\nimport logging\n\n\nlogging.warning(\"Foobar\")\n```"
    },
    {
      "code": "LOG015",
      "name": "root-logger-call",
      "summary": "Checks for usages of the following `logging` top-level functions:\n`debug`, `info`, `warn`, `warning`, `error`, `critical`, `log`, `exception`.",
      "category": "flake8-logging",
      "categoryCode": "LOG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/root-logger-call/",
      "whyBad": "Using the root logger causes the messages to have no source information,\nmaking them less useful for debugging.",
      "example": "```python\nimport logging\n\nlogging.info(\"Foobar\")\n```\n\nUse instead:\n```python\nimport logging\n\nlogger = logging.getLogger(__name__)\nlogger.info(\"Foobar\")\n```"
    },
    {
      "code": "G001",
      "name": "logging-string-format",
      "summary": "Checks for uses of `str.format` to format logging messages.",
      "category": "flake8-logging-format",
      "categoryCode": "G",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-string-format/",
      "whyBad": "The `logging` module provides a mechanism for passing additional values to\nbe logged using the `extra` keyword argument. This is more consistent, more\nefficient, and less error-prone than formatting the string directly.\n\nUsing `str.format` to format a logging message requires that Python eagerly\nformat the string, even if the logging statement is never executed (e.g.,\nif the log level is above the level of the logging statement), whereas\nusing the `extra` keyword argument defers formatting until required.\n\nAdditionally, the use of `extra` will ensure that the values are made\navailable to all handlers, which can then be configured to log the values\nin a consistent manner.\n\nAs an alternative to `extra`, passing values as arguments to the logging\nmethod can also be used to defer string formatting until required.",
      "example": "```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"{} - Something happened\".format(user))\n```\n\nUse instead:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"Something happened\", extra={\"user_id\": user})\n```\n\nOr:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n```"
    },
    {
      "code": "G002",
      "name": "logging-percent-format",
      "summary": "Checks for uses of `printf`-style format strings to format logging\nmessages.",
      "category": "flake8-logging-format",
      "categoryCode": "G",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-percent-format/",
      "whyBad": "The `logging` module provides a mechanism for passing additional values to\nbe logged using the `extra` keyword argument. This is more consistent, more\nefficient, and less error-prone than formatting the string directly.\n\nUsing `printf`-style format strings to format a logging message requires\nthat Python eagerly format the string, even if the logging statement is\nnever executed (e.g., if the log level is above the level of the logging\nstatement), whereas using the `extra` keyword argument defers formatting\nuntil required.\n\nAdditionally, the use of `extra` will ensure that the values are made\navailable to all handlers, which can then be configured to log the values\nin a consistent manner.\n\nAs an alternative to `extra`, passing values as arguments to the logging\nmethod can also be used to defer string formatting until required.",
      "example": "```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\" % user)\n```\n\nUse instead:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(user_id=user))\n```\n\nOr:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n```"
    },
    {
      "code": "G003",
      "name": "logging-string-concat",
      "summary": "Checks for uses string concatenation via the `+` operator to format logging\nmessages.",
      "category": "flake8-logging-format",
      "categoryCode": "G",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-string-concat/",
      "whyBad": "The `logging` module provides a mechanism for passing additional values to\nbe logged using the `extra` keyword argument. This is more consistent, more\nefficient, and less error-prone than formatting the string directly.\n\nUsing concatenation to format a logging message requires that Python\neagerly format the string, even if the logging statement is never executed\n(e.g., if the log level is above the level of the logging statement),\nwhereas using the `extra` keyword argument defers formatting until required.\n\nAdditionally, the use of `extra` will ensure that the values are made\navailable to all handlers, which can then be configured to log the values\nin a consistent manner.\n\nAs an alternative to `extra`, passing values as arguments to the logging\nmethod can also be used to defer string formatting until required.",
      "example": "```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(user + \" - Something happened\")\n```\n\nUse instead:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(user_id=user))\n```\n\nOr:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n```"
    },
    {
      "code": "G004",
      "name": "logging-f-string",
      "summary": "Checks for uses of f-strings to format logging messages.",
      "category": "flake8-logging-format",
      "categoryCode": "G",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-f-string/",
      "whyBad": "The `logging` module provides a mechanism for passing additional values to\nbe logged using the `extra` keyword argument. This is more consistent, more\nefficient, and less error-prone than formatting the string directly.\n\nUsing f-strings to format a logging message requires that Python eagerly\nformat the string, even if the logging statement is never executed (e.g.,\nif the log level is above the level of the logging statement), whereas\nusing the `extra` keyword argument defers formatting until required.\n\nAdditionally, the use of `extra` will ensure that the values are made\navailable to all handlers, which can then be configured to log the values\nin a consistent manner.\n\nAs an alternative to `extra`, passing values as arguments to the logging\nmethod can also be used to defer string formatting until required.",
      "example": "```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(f\"{user} - Something happened\")\n```\n\nUse instead:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(user_id=user))\n```\n\nOr:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n```"
    },
    {
      "code": "G010",
      "name": "logging-warn",
      "summary": "Checks for uses of `logging.warn` and `logging.Logger.warn`.",
      "category": "flake8-logging-format",
      "categoryCode": "G",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-warn/",
      "whyBad": "`logging.warn` and `logging.Logger.warn` are deprecated in favor of\n`logging.warning` and `logging.Logger.warning`, which are functionally\nequivalent.",
      "example": "```python\nimport logging\n\nlogging.warn(\"Something happened\")\n```\n\nUse instead:\n```python\nimport logging\n\nlogging.warning(\"Something happened\")\n```"
    },
    {
      "code": "G101",
      "name": "logging-extra-attr-clash",
      "summary": "Checks for `extra` keywords in logging statements that clash with\n`LogRecord` attributes.",
      "category": "flake8-logging-format",
      "categoryCode": "G",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-extra-attr-clash/",
      "whyBad": "The `logging` module provides a mechanism for passing additional values to\nbe logged using the `extra` keyword argument. These values are then passed\nto the `LogRecord` constructor.\n\nProviding a value via `extra` that clashes with one of the attributes of\nthe `LogRecord` constructor will raise a `KeyError` when the `LogRecord` is\nconstructed.",
      "example": "```python\nimport logging\n\nlogging.basicConfig(format=\"%(name) - %(message)s\", level=logging.INFO)\n\nusername = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(name=username))\n```\n\nUse instead:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(user_id)s - %(message)s\", level=logging.INFO)\n\nusername = \"Maria\"\n\nlogging.info(\"Something happened\", extra=dict(user_id=username))\n```"
    },
    {
      "code": "G201",
      "name": "logging-exc-info",
      "summary": "Checks for uses of `logging.error` that pass `exc_info=True`.",
      "category": "flake8-logging-format",
      "categoryCode": "G",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-exc-info/",
      "whyBad": "Calling `logging.error` with `exc_info=True` is equivalent to calling\n`logging.exception`. Using `logging.exception` is more concise, more\nreadable, and conveys the intent of the logging statement more clearly.",
      "example": "```python\nimport logging\n\ntry:\n    ...\nexcept ValueError:\n    logging.error(\"Exception occurred\", exc_info=True)\n```\n\nUse instead:\n```python\nimport logging\n\ntry:\n    ...\nexcept ValueError:\n    logging.exception(\"Exception occurred\")\n```"
    },
    {
      "code": "G202",
      "name": "logging-redundant-exc-info",
      "summary": "Checks for redundant `exc_info` keyword arguments in logging statements.",
      "category": "flake8-logging-format",
      "categoryCode": "G",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-redundant-exc-info/",
      "whyBad": "`exc_info` is `True` by default for `logging.exception`, and `False` by\ndefault for `logging.error`.\n\nPassing `exc_info=True` to `logging.exception` calls is redundant, as is\npassing `exc_info=False` to `logging.error` calls.",
      "example": "```python\nimport logging\n\ntry:\n    ...\nexcept ValueError:\n    logging.exception(\"Exception occurred\", exc_info=True)\n```\n\nUse instead:\n```python\nimport logging\n\ntry:\n    ...\nexcept ValueError:\n    logging.exception(\"Exception occurred\")\n```"
    },
    {
      "code": "INP001",
      "name": "implicit-namespace-package",
      "summary": "Checks for packages that are missing an `__init__.py` file.",
      "category": "flake8-no-pep420",
      "categoryCode": "INP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/implicit-namespace-package/",
      "whyBad": "Python packages are directories that contain a file named `__init__.py`.\nThe existence of this file indicates that the directory is a Python\npackage, and so it can be imported the same way a module can be\nimported.\n\nDirectories that lack an `__init__.py` file can still be imported, but\nthey're indicative of a special kind of package, known as a \"namespace\npackage\" (see: [PEP 420](https://peps.python.org/pep-0420/)).\nNamespace packages are less widely used, so a package that lacks an\n`__init__.py` file is typically meant to be a regular package, and\nthe absence of the `__init__.py` file is probably an oversight."
    },
    {
      "code": "PIE790",
      "name": "unnecessary-placeholder",
      "summary": "Checks for unnecessary `pass` statements and ellipsis (`...`) literals in\nfunctions, classes, and other blocks.",
      "category": "flake8-pie",
      "categoryCode": "PIE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-placeholder/",
      "whyBad": "In Python, the `pass` statement and ellipsis (`...`) literal serve as\nplaceholders, allowing for syntactically correct empty code blocks. The\nprimary purpose of these nodes is to avoid syntax errors in situations\nwhere a statement or expression is syntactically required, but no code\nneeds to be executed.\n\nIf a `pass` or ellipsis is present in a code block that includes at least\none other statement (even, e.g., a docstring), it is unnecessary and should\nbe removed.",
      "example": "```python\ndef func():\n    \"\"\"Placeholder docstring.\"\"\"\n    pass\n```\n\nUse instead:\n```python\ndef func():\n    \"\"\"Placeholder docstring.\"\"\"\n```\n\nOr, given:\n```python\ndef func():\n    \"\"\"Placeholder docstring.\"\"\"\n    ...\n```\n\nUse instead:\n```python\ndef func():\n    \"\"\"Placeholder docstring.\"\"\"\n```"
    },
    {
      "code": "PIE794",
      "name": "duplicate-class-field-definition",
      "summary": "Checks for duplicate field definitions in classes.",
      "category": "flake8-pie",
      "categoryCode": "PIE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/duplicate-class-field-definition/",
      "whyBad": "Defining a field multiple times in a class body is redundant and likely a\nmistake.",
      "example": "```python\nclass Person:\n    name = Tom\n    ...\n    name = Ben\n```\n\nUse instead:\n```python\nclass Person:\n    name = Tom\n    ...\n```"
    },
    {
      "code": "PIE796",
      "name": "non-unique-enums",
      "summary": "Checks for enums that contain duplicate values.",
      "category": "flake8-pie",
      "categoryCode": "PIE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-unique-enums/",
      "whyBad": "Enum values should be unique. Non-unique values are redundant and likely a\nmistake.",
      "example": "```python\nfrom enum import Enum\n\n\nclass Foo(Enum):\n    A = 1\n    B = 2\n    C = 1\n```\n\nUse instead:\n```python\nfrom enum import Enum\n\n\nclass Foo(Enum):\n    A = 1\n    B = 2\n    C = 3\n```"
    },
    {
      "code": "PIE800",
      "name": "unnecessary-spread",
      "summary": "Checks for unnecessary dictionary unpacking operators (`**`).",
      "category": "flake8-pie",
      "categoryCode": "PIE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-spread/",
      "whyBad": "Unpacking a dictionary into another dictionary is redundant. The unpacking\noperator can be removed, making the code more readable.",
      "example": "```python\nfoo = {\"A\": 1, \"B\": 2}\nbar = {**foo, **{\"C\": 3}}\n```\n\nUse instead:\n```python\nfoo = {\"A\": 1, \"B\": 2}\nbar = {**foo, \"C\": 3}\n```"
    },
    {
      "code": "PIE804",
      "name": "unnecessary-dict-kwargs",
      "summary": "Checks for unnecessary `dict` kwargs.",
      "category": "flake8-pie",
      "categoryCode": "PIE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-dict-kwargs/",
      "whyBad": "If the `dict` keys are valid identifiers, they can be passed as keyword\narguments directly, without constructing unnecessary dictionary.\nThis also makes code more type-safe as type checkers often cannot\nprecisely verify dynamic keyword arguments.",
      "example": "```python\ndef foo(bar):\n    return bar + 1\n\n\nprint(foo(**{\"bar\": 2}))  # prints 3\n\n# No typing errors, but results in an exception at runtime.\nprint(foo(**{\"bar\": 2, \"baz\": 3}))\n```\n\nUse instead:\n\n```python\ndef foo(bar):\n    return bar + 1\n\n\nprint(foo(bar=2))  # prints 3\n\n# Typing error detected: No parameter named \"baz\".\nprint(foo(bar=2, baz=3))\n```"
    },
    {
      "code": "PIE807",
      "name": "reimplemented-container-builtin",
      "summary": "Checks for lambdas that can be replaced with the `list` or `dict` builtins.",
      "category": "flake8-pie",
      "categoryCode": "PIE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/reimplemented-container-builtin/",
      "whyBad": "Using container builtins are more succinct and idiomatic than wrapping\nthe literal in a lambda.",
      "example": "```python\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass Foo:\n    bar: list[int] = field(default_factory=lambda: [])\n```\n\nUse instead:\n```python\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass Foo:\n    bar: list[int] = field(default_factory=list)\n    baz: dict[str, int] = field(default_factory=dict)\n```"
    },
    {
      "code": "PIE808",
      "name": "unnecessary-range-start",
      "summary": "Checks for `range` calls with an unnecessary `start` argument.",
      "category": "flake8-pie",
      "categoryCode": "PIE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-range-start/",
      "whyBad": "`range(0, x)` is equivalent to `range(x)`, as `0` is the default value for\nthe `start` argument. Omitting the `start` argument makes the code more\nconcise and idiomatic.",
      "example": "```python\nrange(0, 3)\n```\n\nUse instead:\n```python\nrange(3)\n```"
    },
    {
      "code": "PIE810",
      "name": "multiple-starts-ends-with",
      "summary": "Checks for `startswith` or `endswith` calls on the same value with\ndifferent prefixes or suffixes.",
      "category": "flake8-pie",
      "categoryCode": "PIE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-starts-ends-with/",
      "whyBad": "The `startswith` and `endswith` methods accept tuples of prefixes or\nsuffixes respectively. Passing a tuple of prefixes or suffixes is more\nefficient and readable than calling the method multiple times.",
      "example": "```python\nmsg = \"Hello, world!\"\nif msg.startswith(\"Hello\") or msg.startswith(\"Hi\"):\n    print(\"Greetings!\")\n```\n\nUse instead:\n```python\nmsg = \"Hello, world!\"\nif msg.startswith((\"Hello\", \"Hi\")):\n    print(\"Greetings!\")\n```"
    },
    {
      "code": "T201",
      "name": "print",
      "summary": "Checks for `print` statements.",
      "category": "flake8-print",
      "categoryCode": "T",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/print/",
      "whyBad": "`print` statements used for debugging should be omitted from production\ncode. They can lead the accidental inclusion of sensitive information in\nlogs, and are not configurable by clients, unlike `logging` statements.\n\n`print` statements used to produce output as a part of a command-line\ninterface program are not typically a problem.",
      "example": "```python\ndef sum_less_than_four(a, b):\n    print(f\"Calling sum_less_than_four\")\n    return a + b < 4\n```\n\nThe automatic fix will remove the print statement entirely:\n\n```python\ndef sum_less_than_four(a, b):\n    return a + b < 4\n```\n\nTo keep the line for logging purposes, instead use something like:\n\n```python\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\n\ndef sum_less_than_four(a, b):\n    logging.debug(\"Calling sum_less_than_four\")\n    return a + b < 4\n```"
    },
    {
      "code": "T203",
      "name": "p-print",
      "summary": "Checks for `pprint` statements.",
      "category": "flake8-print",
      "categoryCode": "T",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/p-print/",
      "whyBad": "Like `print` statements, `pprint` statements used for debugging should\nbe omitted from production code. They can lead the accidental inclusion\nof sensitive information in logs, and are not configurable by clients,\nunlike `logging` statements.\n\n`pprint` statements used to produce output as a part of a command-line\ninterface program are not typically a problem.",
      "example": "```python\nimport pprint\n\n\ndef merge_dicts(dict_a, dict_b):\n    dict_c = {**dict_a, **dict_b}\n    pprint.pprint(dict_c)\n    return dict_c\n```\n\nUse instead:\n```python\ndef merge_dicts(dict_a, dict_b):\n    dict_c = {**dict_a, **dict_b}\n    return dict_c\n```"
    },
    {
      "code": "PYI001",
      "name": "unprefixed-type-param",
      "summary": "Checks that type `TypeVar`s, `ParamSpec`s, and `TypeVarTuple`s in stubs\nhave names prefixed with `_`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unprefixed-type-param/",
      "whyBad": "Prefixing type parameters with `_` avoids accidentally exposing names\ninternal to the stub.",
      "example": "```pyi\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n```\n\nUse instead:\n```pyi\nfrom typing import TypeVar\n\n_T = TypeVar(\"_T\")\n```"
    },
    {
      "code": "PYI002",
      "name": "complex-if-statement-in-stub",
      "summary": "Checks for `if` statements with complex conditionals in stubs.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/complex-if-statement-in-stub/",
      "whyBad": "Type checkers understand simple conditionals to express variations between\ndifferent Python versions and platforms. However, complex tests may not be\nunderstood by a type checker, leading to incorrect inferences when they\nanalyze your code.",
      "example": "```pyi\nimport sys\n\nif (3, 10) <= sys.version_info < (3, 12): ...\n```\n\nUse instead:\n```pyi\nimport sys\n\nif sys.version_info >= (3, 10) and sys.version_info < (3, 12): ...\n```"
    },
    {
      "code": "PYI003",
      "name": "unrecognized-version-info-check",
      "summary": "Checks for problematic `sys.version_info`-related conditions in stubs.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unrecognized-version-info-check/",
      "whyBad": "Stub files support simple conditionals to test for differences in Python\nversions using `sys.version_info`. However, there are a number of common\nmistakes involving `sys.version_info` comparisons that should be avoided.\nFor example, comparing against a string can lead to unexpected behavior.",
      "example": "```pyi\nimport sys\n\nif sys.version_info[0] == \"2\": ...\n```\n\nUse instead:\n```pyi\nimport sys\n\nif sys.version_info[0] == 2: ...\n```"
    },
    {
      "code": "PYI004",
      "name": "patch-version-comparison",
      "summary": "Checks for Python version comparisons in stubs that compare against patch\nversions (e.g., Python 3.8.3) instead of major and minor versions (e.g.,\nPython 3.8).",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/patch-version-comparison/",
      "whyBad": "Stub files support simple conditionals to test for differences in Python\nversions and platforms. However, type checkers only understand a limited\nsubset of these conditionals. In particular, type checkers don't support\npatch versions (e.g., Python 3.8.3), only major and minor versions (e.g.,\nPython 3.8). Therefore, version checks in stubs should only use the major\nand minor versions.",
      "example": "```pyi\nimport sys\n\nif sys.version_info >= (3, 4, 3): ...\n```\n\nUse instead:\n```pyi\nimport sys\n\nif sys.version_info >= (3, 4): ...\n```"
    },
    {
      "code": "PYI005",
      "name": "wrong-tuple-length-version-comparison",
      "summary": "Checks for Python version comparisons that compare against a tuple of the\nwrong length.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/wrong-tuple-length-version-comparison/",
      "whyBad": "Stub files support simple conditionals to test for differences in Python\nversions and platforms. When comparing against `sys.version_info`, avoid\ncomparing against tuples of the wrong length, which can lead to unexpected\nbehavior.",
      "example": "```pyi\nimport sys\n\nif sys.version_info[:2] == (3,): ...\n```\n\nUse instead:\n```pyi\nimport sys\n\nif sys.version_info[0] == 3: ...\n```"
    },
    {
      "code": "PYI006",
      "name": "bad-version-info-comparison",
      "summary": "Checks for uses of comparators other than `<` and `>=` for\n`sys.version_info` checks. All other comparators, such\nas `>`, `<=`, and `==`, are banned.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-version-info-comparison/",
      "whyBad": "Comparing `sys.version_info` with `==` or `<=` has unexpected behavior\nand can lead to bugs.\n\nFor example, `sys.version_info > (3, 8, 1)` will resolve to `True` if your\nPython version is 3.8.1; meanwhile, `sys.version_info <= (3, 8)` will _not_\nresolve to `True` if your Python version is 3.8.10:\n\n```python\n>>> import sys\n>>> print(sys.version_info)\nsys.version_info(major=3, minor=8, micro=10, releaselevel='final', serial=0)\n>>> print(sys.version_info > (3, 8))\nTrue\n>>> print(sys.version_info == (3, 8))\nFalse\n>>> print(sys.version_info <= (3, 8))\nFalse\n>>> print(sys.version_info in (3, 8))\nFalse\n```",
      "example": "```py\nimport sys\n\nif sys.version_info > (3, 8): ...\n```\n\nUse instead:\n```py\nimport sys\n\nif sys.version_info >= (3, 9): ...\n```\n\n[preview]: https://docs.astral.sh/ruff/preview/"
    },
    {
      "code": "PYI007",
      "name": "unrecognized-platform-check",
      "summary": "Check for unrecognized `sys.platform` checks. Platform checks should be\nsimple string comparisons.\n\n**Note**: this rule is only enabled in `.pyi` stub files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unrecognized-platform-check/",
      "whyBad": "Some `sys.platform` checks are too complex for type checkers to\nunderstand, and thus result in incorrect inferences by these tools.\n`sys.platform` checks should be simple string comparisons, like\n`if sys.platform == \"linux\"`.",
      "example": "```pyi\nimport sys\n\nif sys.platform == \"xunil\"[::-1]:\n    # Linux specific definitions\n    ...\nelse:\n    # Posix specific definitions\n    ...\n```\n\nInstead, use a simple string comparison, such as `==` or `!=`:\n```pyi\nimport sys\n\nif sys.platform == \"linux\":\n    # Linux specific definitions\n    ...\nelse:\n    # Posix specific definitions\n    ...\n```"
    },
    {
      "code": "PYI008",
      "name": "unrecognized-platform-name",
      "summary": "Check for unrecognized platform names in `sys.platform` checks.\n\n**Note**: this rule is only enabled in `.pyi` stub files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unrecognized-platform-name/",
      "whyBad": "If a `sys.platform` check compares to a platform name outside of a\nsmall set of known platforms (e.g. \"linux\", \"win32\", etc.), it's likely\na typo or a platform name that is not recognized by type checkers.\n\nThe list of known platforms is: \"linux\", \"win32\", \"cygwin\", \"darwin\".",
      "example": "```pyi\nimport sys\n\nif sys.platform == \"linus\": ...\n```\n\nUse instead:\n```pyi\nimport sys\n\nif sys.platform == \"linux\": ...\n```"
    },
    {
      "code": "PYI009",
      "name": "pass-statement-stub-body",
      "summary": "Checks for `pass` statements in empty stub bodies.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pass-statement-stub-body/",
      "whyBad": "For stylistic consistency, `...` should always be used rather than `pass`\nin stub files.",
      "example": "```pyi\ndef foo(bar: int) -> list[int]: pass\n```\n\nUse instead:\n```pyi\ndef foo(bar: int) -> list[int]: ...\n```"
    },
    {
      "code": "PYI010",
      "name": "non-empty-stub-body",
      "summary": "Checks for non-empty function stub bodies.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-empty-stub-body/",
      "whyBad": "Stub files are never executed at runtime; they should be thought of as\n\"data files\" for type checkers or IDEs. Function bodies are redundant\nfor this purpose.",
      "example": "```pyi\ndef double(x: int) -> int:\n    return x * 2\n```\n\nUse instead:\n```pyi\ndef double(x: int) -> int: ...\n```"
    },
    {
      "code": "PYI011",
      "name": "typed-argument-default-in-stub",
      "summary": "Checks for typed function arguments in stubs with complex default values.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/typed-argument-default-in-stub/",
      "whyBad": "Stub (`.pyi`) files exist as \"data files\" for static analysis tools, and\nare not evaluated at runtime. While simple default values may be useful for\nsome tools that consume stubs, such as IDEs, they are ignored by type\ncheckers.\n\nInstead of including and reproducing a complex value, use `...` to indicate\nthat the assignment has a default value, but that the value is \"complex\" or\nvaries according to the current platform or Python version. For the\npurposes of this rule, any default value counts as \"complex\" unless it is\na literal `int`, `float`, `complex`, `bytes`, `str`, `bool`, `None`, `...`,\nor a simple container literal.",
      "example": "```pyi\ndef foo(arg: list[int] = list(range(10_000))) -> None: ...\n```\n\nUse instead:\n\n```pyi\ndef foo(arg: list[int] = ...) -> None: ...\n```"
    },
    {
      "code": "PYI012",
      "name": "pass-in-class-body",
      "summary": "Checks for the presence of the `pass` statement in non-empty class bodies\nin `.pyi` files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pass-in-class-body/",
      "whyBad": "The `pass` statement is always unnecessary in non-empty class bodies in\nstubs.",
      "example": "```pyi\nclass MyClass:\n    x: int\n    pass\n```\n\nUse instead:\n```pyi\nclass MyClass:\n    x: int\n```"
    },
    {
      "code": "PYI013",
      "name": "ellipsis-in-non-empty-class-body",
      "summary": "Removes ellipses (`...`) in otherwise non-empty class bodies.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ellipsis-in-non-empty-class-body/",
      "whyBad": "An ellipsis in a class body is only necessary if the class body is\notherwise empty. If the class body is non-empty, then the ellipsis\nis redundant.",
      "example": "```pyi\nclass Foo:\n    ...\n    value: int\n```\n\nUse instead:\n```pyi\nclass Foo:\n    value: int\n```"
    },
    {
      "code": "PYI014",
      "name": "argument-default-in-stub",
      "summary": "Checks for untyped function arguments in stubs with default values that\nare not \"simple\" /// (i.e., `int`, `float`, `complex`, `bytes`, `str`,\n`bool`, `None`, `...`, or simple container literals).",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/argument-default-in-stub/",
      "whyBad": "Stub (`.pyi`) files exist to define type hints, and are not evaluated at\nruntime. As such, function arguments in stub files should not have default\nvalues, as they are ignored by type checkers.\n\nHowever, the use of default values may be useful for IDEs and other\nconsumers of stub files, and so \"simple\" values may be worth including and\nare permitted by this rule.\n\nInstead of including and reproducing a complex value, use `...` to indicate\nthat the assignment has a default value, but that the value is non-simple\nor varies according to the current platform or Python version.",
      "example": "```pyi\ndef foo(arg=bar()) -> None: ...\n```\n\nUse instead:\n\n```pyi\ndef foo(arg=...) -> None: ...\n```"
    },
    {
      "code": "PYI015",
      "name": "assignment-default-in-stub",
      "summary": "Checks for assignments in stubs with default values that are not \"simple\"\n(i.e., `int`, `float`, `complex`, `bytes`, `str`, `bool`, `None`, `...`, or\nsimple container literals).",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assignment-default-in-stub/",
      "whyBad": "Stub (`.pyi`) files exist to define type hints, and are not evaluated at\nruntime. As such, assignments in stub files should not include values,\nas they are ignored by type checkers.\n\nHowever, the use of such values may be useful for IDEs and other consumers\nof stub files, and so \"simple\" values may be worth including and are\npermitted by this rule.\n\nInstead of including and reproducing a complex value, use `...` to indicate\nthat the assignment has a default value, but that the value is non-simple\nor varies according to the current platform or Python version.",
      "example": "```pyi\nfoo: str = bar()\n```\n\nUse instead:\n```pyi\nfoo: str = ...\n```"
    },
    {
      "code": "PYI016",
      "name": "duplicate-union-member",
      "summary": "Checks for duplicate union members.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/duplicate-union-member/",
      "whyBad": "Duplicate union members are redundant and should be removed.",
      "example": "```python\nfoo: str | str\n```\n\nUse instead:\n```python\nfoo: str\n```"
    },
    {
      "code": "PYI017",
      "name": "complex-assignment-in-stub",
      "summary": "Checks for assignments with multiple or non-name targets in stub files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/complex-assignment-in-stub/",
      "whyBad": "In general, stub files should be thought of as \"data files\" for a type\nchecker, and are not intended to be executed. As such, it's useful to\nenforce that only a subset of Python syntax is allowed in a stub file, to\nensure that everything in the stub is unambiguous for the type checker.\n\nThe need to perform multi-assignment, or assignment to a non-name target,\nlikely indicates a misunderstanding of how stub files are intended to be\nused.",
      "example": "```pyi\nfrom typing import TypeAlias\n\na = b = int\n\nclass Klass: ...\n\nKlass.X: TypeAlias = int\n```\n\nUse instead:\n\n```pyi\nfrom typing import TypeAlias\n\na: TypeAlias = int\nb: TypeAlias = int\n\nclass Klass:\n    X: TypeAlias = int\n```"
    },
    {
      "code": "PYI018",
      "name": "unused-private-type-var",
      "summary": "Checks for the presence of unused private `TypeVar`, `ParamSpec` or\n`TypeVarTuple` declarations.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-private-type-var/",
      "whyBad": "A private `TypeVar` that is defined but not used is likely a mistake. It\nshould either be used, made public, or removed to avoid confusion. A type\nvariable is considered \"private\" if its name starts with an underscore.",
      "example": "```pyi\nimport typing\nimport typing_extensions\n\n_T = typing.TypeVar(\"_T\")\n_Ts = typing_extensions.TypeVarTuple(\"_Ts\")\n```"
    },
    {
      "code": "PYI019",
      "name": "custom-type-var-for-self",
      "summary": "Checks for methods that use custom [`TypeVar`s][typing_TypeVar] in their\nannotations when they could use [`Self`][Self] instead.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/custom-type-var-for-self/",
      "whyBad": "While the semantics are often identical, using `Self` is more intuitive\nand succinct (per [PEP 673]) than a custom `TypeVar`. For example, the\nuse of `Self` will typically allow for the omission of type parameters\non the `self` and `cls` arguments.\n\nThis check currently applies to instance methods that return `self`,\nclass methods that return an instance of `cls`, class methods that return\n`cls`, and `__new__` methods.",
      "example": "```pyi\nfrom typing import TypeVar\n\n_S = TypeVar(\"_S\", bound=\"Foo\")\n\nclass Foo:\n    def __new__(cls: type[_S], *args: str, **kwargs: int) -> _S: ...\n    def foo(self: _S, arg: bytes) -> _S: ...\n    @classmethod\n    def bar(cls: type[_S], arg: int) -> _S: ...\n```\n\nUse instead:\n\n```pyi\nfrom typing import Self\n\nclass Foo:\n    def __new__(cls, *args: str, **kwargs: int) -> Self: ...\n    def foo(self, arg: bytes) -> Self: ...\n    @classmethod\n    def bar(cls, arg: int) -> Self: ...\n```"
    },
    {
      "code": "PYI020",
      "name": "quoted-annotation-in-stub",
      "summary": "Checks for quoted type annotations in stub (`.pyi`) files, which should be avoided.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/quoted-annotation-in-stub/",
      "whyBad": "Stub files natively support forward references in all contexts, as stubs\nare never executed at runtime. (They should be thought of as \"data files\"\nfor type checkers and IDEs.) As such, quotes are never required for type\nannotations in stub files, and should be omitted.",
      "example": "```pyi\ndef function() -> \"int\": ...\n```\n\nUse instead:\n\n```pyi\ndef function() -> int: ...\n```"
    },
    {
      "code": "PYI021",
      "name": "docstring-in-stub",
      "summary": "Checks for the presence of docstrings in stub files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-in-stub/",
      "whyBad": "Stub files should omit docstrings, as they're intended to provide type\nhints, rather than documentation.",
      "example": "```pyi\ndef func(param: int) -> str:\n    \"\"\"This is a docstring.\"\"\"\n    ...\n```\n\nUse instead:\n\n```pyi\ndef func(param: int) -> str: ...\n```"
    },
    {
      "code": "PYI024",
      "name": "collections-named-tuple",
      "summary": "Checks for uses of `collections.namedtuple` in stub files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/collections-named-tuple/",
      "whyBad": "`typing.NamedTuple` is the \"typed version\" of `collections.namedtuple`.\n\nInheriting from `typing.NamedTuple` creates a custom `tuple` subclass in\nthe same way as using the `collections.namedtuple` factory function.\nHowever, using `typing.NamedTuple` allows you to provide a type annotation\nfor each field in the class. This means that type checkers will have more\ninformation to work with, and will be able to analyze your code more\nprecisely.",
      "example": "```pyi\nfrom collections import namedtuple\n\nPerson = namedtuple(\"Person\", [\"name\", \"age\"])\n```\n\nUse instead:\n```pyi\nfrom typing import NamedTuple\n\nclass Person(NamedTuple):\n    name: str\n    age: int\n```"
    },
    {
      "code": "PYI025",
      "name": "unaliased-collections-abc-set-import",
      "summary": "Checks for `from collections.abc import Set` imports that do not alias\n`Set` to `AbstractSet`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unaliased-collections-abc-set-import/",
      "whyBad": "The `Set` type in `collections.abc` is an abstract base class for set-like types.\nIt is easily confused with, and not equivalent to, the `set` builtin.\n\nTo avoid confusion, `Set` should be aliased to `AbstractSet` when imported. This\nmakes it clear that the imported type is an abstract base class, and not the\n`set` builtin.",
      "example": "```pyi\nfrom collections.abc import Set\n```\n\nUse instead:\n```pyi\nfrom collections.abc import Set as AbstractSet\n```"
    },
    {
      "code": "PYI026",
      "name": "type-alias-without-annotation",
      "summary": "Checks for type alias definitions that are not annotated with\n`typing.TypeAlias`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-alias-without-annotation/",
      "whyBad": "In Python, a type alias is defined by assigning a type to a variable (e.g.,\n`Vector = list[float]`).\n\nIt's best to annotate type aliases with the `typing.TypeAlias` type to\nmake it clear that the statement is a type alias declaration, as opposed\nto a normal variable assignment.",
      "example": "```pyi\nVector = list[float]\n```\n\nUse instead:\n```pyi\nfrom typing import TypeAlias\n\nVector: TypeAlias = list[float]\n```"
    },
    {
      "code": "PYI029",
      "name": "str-or-repr-defined-in-stub",
      "summary": "Checks for redundant definitions of `__str__` or `__repr__` in stubs.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/str-or-repr-defined-in-stub/",
      "whyBad": "Defining `__str__` or `__repr__` in a stub is almost always redundant,\nas the signatures are almost always identical to those of the default\nequivalent, `object.__str__` and `object.__repr__`, respectively.",
      "example": "```pyi\nclass Foo:\n    def __repr__(self) -> str: ...\n```"
    },
    {
      "code": "PYI030",
      "name": "unnecessary-literal-union",
      "summary": "Checks for the presence of multiple literal types in a union.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-literal-union/",
      "whyBad": "`Literal[\"foo\", 42]` has identical semantics to\n`Literal[\"foo\"] | Literal[42]`, but is clearer and more concise.",
      "example": "```pyi\nfrom typing import Literal\n\nfield: Literal[1] | Literal[2] | str\n```\n\nUse instead:\n```pyi\nfrom typing import Literal\n\nfield: Literal[1, 2] | str\n```"
    },
    {
      "code": "PYI032",
      "name": "any-eq-ne-annotation",
      "summary": "Checks for `__eq__` and `__ne__` implementations that use `typing.Any` as\nthe type annotation for their second parameter.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/any-eq-ne-annotation/",
      "whyBad": "The Python documentation recommends the use of `object` to \"indicate that a\nvalue could be any type in a typesafe manner\". `Any`, on the other hand,\nshould be seen as an \"escape hatch when you need to mix dynamically and\nstatically typed code\". Since using `Any` allows you to write highly unsafe\ncode, you should generally only use `Any` when the semantics of your code\nwould otherwise be inexpressible to the type checker.\n\nThe expectation in Python is that a comparison of two arbitrary objects\nusing `==` or `!=` should never raise an exception. This contract can be\nfully expressed in the type system and does not involve requesting unsound\nbehaviour from a type checker. As such, `object` is a more appropriate\nannotation than `Any` for the second parameter of the methods implementing\nthese comparison operators -- `__eq__` and `__ne__`.",
      "example": "```pyi\nfrom typing import Any\n\nclass Foo:\n    def __eq__(self, obj: Any) -> bool: ...\n```\n\nUse instead:\n\n```pyi\nclass Foo:\n    def __eq__(self, obj: object) -> bool: ...\n```"
    },
    {
      "code": "PYI033",
      "name": "type-comment-in-stub",
      "summary": "Checks for the use of type comments (e.g., `x = 1  # type: int`) in stub\nfiles.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-comment-in-stub/",
      "whyBad": "Stub (`.pyi`) files should use type annotations directly, rather\nthan type comments, even if they're intended to support Python 2, since\nstub files are not executed at runtime. The one exception is `# type: ignore`.",
      "example": "```pyi\nx = 1  # type: int\n```\n\nUse instead:\n```pyi\nx: int = 1\n```"
    },
    {
      "code": "PYI034",
      "name": "non-self-return-type",
      "summary": "Checks for methods that are annotated with a fixed return type which\nshould instead be returning `Self`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-self-return-type/",
      "whyBad": "If methods that generally return `self` at runtime are annotated with a\nfixed return type, and the class is subclassed, type checkers will not be\nable to infer the correct return type.\n\nFor example:\n```python\nclass Shape:\n    def set_scale(self, scale: float) -> Shape:\n        self.scale = scale\n        return self\n\nclass Circle(Shape):\n    def set_radius(self, radius: float) -> Circle:\n        self.radius = radius\n        return self\n\n# Type checker infers return type as `Shape`, not `Circle`.\nCircle().set_scale(0.5)\n\n# Thus, this expression is invalid, as `Shape` has no attribute `set_radius`.\nCircle().set_scale(0.5).set_radius(2.7)\n```\n\nSpecifically, this check enforces that the return type of the following\nmethods is `Self`:\n\n1. In-place binary-operation dunder methods, like `__iadd__`, `__imul__`, etc.\n1. `__new__`, `__enter__`, and `__aenter__`, if those methods return the\n   class name.\n1. `__iter__` methods that return `Iterator`, despite the class inheriting\n   directly from `Iterator`.\n1. `__aiter__` methods that return `AsyncIterator`, despite the class\n   inheriting directly from `AsyncIterator`.\n\nThe rule attempts to avoid flagging methods on metaclasses, since\n[PEP 673] specifies that `Self` is disallowed in metaclasses. Ruff can\ndetect a class as being a metaclass if it inherits from a stdlib\nmetaclass such as `builtins.type` or `abc.ABCMeta`, and additionally\ninfers that a class may be a metaclass if it has a `__new__` method\nwith a similar signature to `type.__new__`. The heuristic used to\nidentify a metaclass-like `__new__` method signature is that it:\n\n1. Has exactly 5 parameters (including `cls`)\n1. Has a second parameter annotated with `str`\n1. Has a third parameter annotated with a `tuple` type\n1. Has a fourth parameter annotated with a `dict` type\n1. Has a fifth parameter is keyword-variadic (`**kwargs`)\n\nFor example, the following class would be detected as a metaclass, disabling\nthe rule:\n\n```python\nclass MyMetaclass(django.db.models.base.ModelBase):\n    def __new__(cls, name: str, bases: tuple[Any, ...], attrs: dict[str, Any], **kwargs: Any) -> MyMetaclass:\n        ...\n```",
      "example": "```pyi\nclass Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Foo: ...\n    def __enter__(self) -> Foo: ...\n    async def __aenter__(self) -> Foo: ...\n    def __iadd__(self, other: Foo) -> Foo: ...\n```\n\nUse instead:\n\n```pyi\nfrom typing_extensions import Self\n\nclass Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Self: ...\n    def __enter__(self) -> Self: ...\n    async def __aenter__(self) -> Self: ...\n    def __iadd__(self, other: Foo) -> Self: ...\n```"
    },
    {
      "code": "PYI035",
      "name": "unassigned-special-variable-in-stub",
      "summary": "Checks that `__all__`, `__match_args__`, and `__slots__` variables are\nassigned to values when defined in stub files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unassigned-special-variable-in-stub/",
      "whyBad": "Special variables like `__all__` have the same semantics in stub files\nas they do in Python modules, and so should be consistent with their\nruntime counterparts.",
      "example": "```pyi\n__all__: list[str]\n```\n\nUse instead:\n```pyi\n__all__: list[str] = [\"foo\", \"bar\"]\n```"
    },
    {
      "code": "PYI036",
      "name": "bad-exit-annotation",
      "summary": "Checks for incorrect function signatures on `__exit__` and `__aexit__`\nmethods.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-exit-annotation/",
      "whyBad": "Improperly annotated `__exit__` and `__aexit__` methods can cause\nunexpected behavior when interacting with type checkers.",
      "example": "```pyi\nfrom types import TracebackType\n\nclass Foo:\n    def __exit__(\n        self, typ: BaseException, exc: BaseException, tb: TracebackType\n    ) -> None: ...\n```\n\nUse instead:\n\n```pyi\nfrom types import TracebackType\n\nclass Foo:\n    def __exit__(\n        self,\n        typ: type[BaseException] | None,\n        exc: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None: ...\n```"
    },
    {
      "code": "PYI041",
      "name": "redundant-numeric-union",
      "summary": "Checks for parameter annotations that contain redundant unions between\nbuiltin numeric types (e.g., `int | float`).",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-numeric-union/",
      "whyBad": "The [typing specification] states:\n\n> Pythons numeric types `complex`, `float` and `int` are not subtypes of\n> each other, but to support common use cases, the type system contains a\n> straightforward shortcut: when an argument is annotated as having type\n> `float`, an argument of type `int` is acceptable; similar, for an\n> argument annotated as having type `complex`, arguments of type `float` or\n> `int` are acceptable.\n\nAs such, a union that includes both `int` and `float` is redundant in the\nspecific context of a parameter annotation, as it is equivalent to a union\nthat only includes `float`. For readability and clarity, unions should omit\nredundant elements.",
      "example": "```pyi\ndef foo(x: float | int | str) -> None: ...\n```\n\nUse instead:\n\n```pyi\ndef foo(x: float | str) -> None: ...\n```"
    },
    {
      "code": "PYI042",
      "name": "snake-case-type-alias",
      "summary": "Checks for type aliases that do not use the CamelCase naming convention.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/snake-case-type-alias/",
      "whyBad": "It's conventional to use the CamelCase naming convention for type aliases,\nto distinguish them from other variables.",
      "example": "```pyi\nfrom typing import TypeAlias\n\ntype_alias_name: TypeAlias = int\n```\n\nUse instead:\n```pyi\nfrom typing import TypeAlias\n\nTypeAliasName: TypeAlias = int\n```"
    },
    {
      "code": "PYI043",
      "name": "t-suffixed-type-alias",
      "summary": "Checks for private type alias definitions suffixed with 'T'.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/t-suffixed-type-alias/",
      "whyBad": "It's conventional to use the 'T' suffix for type variables; the use of\nsuch a suffix implies that the object is a `TypeVar`.\n\nAdding the 'T' suffix to a non-`TypeVar`, it can be misleading and should\nbe avoided.",
      "example": "```pyi\nfrom typing import TypeAlias\n\n_MyTypeT: TypeAlias = int\n```\n\nUse instead:\n```pyi\nfrom typing import TypeAlias\n\n_MyType: TypeAlias = int\n```"
    },
    {
      "code": "PYI044",
      "name": "future-annotations-in-stub",
      "summary": "Checks for the presence of the `from __future__ import annotations` import\nstatement in stub files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/future-annotations-in-stub/",
      "whyBad": "Stub files natively support forward references in all contexts, as stubs are\nnever executed at runtime. (They should be thought of as \"data files\" for\ntype checkers.) As such, the `from __future__ import annotations` import\nstatement has no effect and should be omitted."
    },
    {
      "code": "PYI045",
      "name": "iter-method-return-iterable",
      "summary": "Checks for `__iter__` methods in stubs that return `Iterable[T]` instead\nof an `Iterator[T]`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/iter-method-return-iterable/",
      "whyBad": "`__iter__` methods should always should return an `Iterator` of some kind,\nnot an `Iterable`.\n\nIn Python, an `Iterable` is an object that has an `__iter__` method; an\n`Iterator` is an object that has `__iter__` and `__next__` methods. All\n`__iter__` methods are expected to return `Iterator`s. Type checkers may\nnot always recognize an object as being iterable if its `__iter__` method\ndoes not return an `Iterator`.\n\nEvery `Iterator` is an `Iterable`, but not every `Iterable` is an `Iterator`.\nFor example, `list` is an `Iterable`, but not an `Iterator`; you can obtain\nan iterator over a list's elements by passing the list to `iter()`:\n\n```pycon\n>>> import collections.abc\n>>> x = [42]\n>>> isinstance(x, collections.abc.Iterable)\nTrue\n>>> isinstance(x, collections.abc.Iterator)\nFalse\n>>> next(x)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nTypeError: 'list' object is not an iterator\n>>> y = iter(x)\n>>> isinstance(y, collections.abc.Iterable)\nTrue\n>>> isinstance(y, collections.abc.Iterator)\nTrue\n>>> next(y)\n42\n```\n\nUsing `Iterable` rather than `Iterator` as a return type for an `__iter__`\nmethods would imply that you would not necessarily be able to call `next()`\non the returned object, violating the expectations of the interface.",
      "example": "```python\nimport collections.abc\n\n\nclass Klass:\n    def __iter__(self) -> collections.abc.Iterable[str]: ...\n```\n\nUse instead:\n\n```python\nimport collections.abc\n\n\nclass Klass:\n    def __iter__(self) -> collections.abc.Iterator[str]: ...\n```"
    },
    {
      "code": "PYI046",
      "name": "unused-private-protocol",
      "summary": "Checks for the presence of unused private `typing.Protocol` definitions.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-private-protocol/",
      "whyBad": "A private `typing.Protocol` that is defined but not used is likely a\nmistake. It should either be used, made public, or removed to avoid\nconfusion.",
      "example": "```pyi\nimport typing\n\nclass _PrivateProtocol(typing.Protocol):\n    foo: int\n```\n\nUse instead:\n\n```pyi\nimport typing\n\nclass _PrivateProtocol(typing.Protocol):\n    foo: int\n\ndef func(arg: _PrivateProtocol) -> None: ...\n```"
    },
    {
      "code": "PYI047",
      "name": "unused-private-type-alias",
      "summary": "Checks for the presence of unused private type aliases.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-private-type-alias/",
      "whyBad": "A private type alias that is defined but not used is likely a\nmistake. It should either be used, made public, or removed to avoid\nconfusion.",
      "example": "```pyi\nimport typing\n\n_UnusedTypeAlias: typing.TypeAlias = int\n```\n\nUse instead:\n\n```pyi\nimport typing\n\n_UsedTypeAlias: typing.TypeAlias = int\n\ndef func(arg: _UsedTypeAlias) -> _UsedTypeAlias: ...\n```"
    },
    {
      "code": "PYI048",
      "name": "stub-body-multiple-statements",
      "summary": "Checks for functions in stub (`.pyi`) files that contain multiple\nstatements.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/stub-body-multiple-statements/",
      "whyBad": "Stub files are never executed, and are only intended to define type hints.\nAs such, functions in stub files should not contain functional code, and\nshould instead contain only a single statement (e.g., `...`).",
      "example": "```pyi\ndef function():\n    x = 1\n    y = 2\n    return x + y\n```\n\nUse instead:\n\n```pyi\ndef function(): ...\n```"
    },
    {
      "code": "PYI049",
      "name": "unused-private-typed-dict",
      "summary": "Checks for the presence of unused private `typing.TypedDict` definitions.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-private-typed-dict/",
      "whyBad": "A private `typing.TypedDict` that is defined but not used is likely a\nmistake. It should either be used, made public, or removed to avoid\nconfusion.",
      "example": "```pyi\nimport typing\n\nclass _UnusedPrivateTypedDict(typing.TypedDict):\n    foo: list[int]\n```\n\nUse instead:\n\n```pyi\nimport typing\n\nclass _UsedPrivateTypedDict(typing.TypedDict):\n    foo: set[str]\n\ndef func(arg: _UsedPrivateTypedDict) -> _UsedPrivateTypedDict: ...\n```"
    },
    {
      "code": "PYI050",
      "name": "no-return-argument-annotation-in-stub",
      "summary": "Checks for uses of `typing.NoReturn` (and `typing_extensions.NoReturn`) for\nparameter annotations.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-return-argument-annotation-in-stub/",
      "whyBad": "Prefer `Never` over `NoReturn` for parameter annotations. `Never` has a\nclearer name in these contexts, since it makes little sense to talk about a\nparameter annotation \"not returning\".\n\nThis is a purely stylistic lint: the two types have identical semantics for\ntype checkers. Both represent Python's \"[bottom type]\" (a type that has no\nmembers).",
      "example": "```pyi\nfrom typing import NoReturn\n\ndef foo(x: NoReturn): ...\n```\n\nUse instead:\n```pyi\nfrom typing import Never\n\ndef foo(x: Never): ...\n```"
    },
    {
      "code": "PYI051",
      "name": "redundant-literal-union",
      "summary": "Checks for redundant unions between a `Literal` and a builtin supertype of\nthat `Literal`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-literal-union/",
      "whyBad": "Using a `Literal` type in a union with its builtin supertype is redundant,\nas the supertype will be strictly more general than the `Literal` type.\nFor example, `Literal[\"A\"] | str` is equivalent to `str`, and\n`Literal[1] | int` is equivalent to `int`, as `str` and `int` are the\nsupertypes of `\"A\"` and `1` respectively.",
      "example": "```pyi\nfrom typing import Literal\n\nx: Literal[\"A\", b\"B\"] | str\n```\n\nUse instead:\n```pyi\nfrom typing import Literal\n\nx: Literal[b\"B\"] | str\n```"
    },
    {
      "code": "PYI052",
      "name": "unannotated-assignment-in-stub",
      "summary": "Checks for unannotated assignments in stub (`.pyi`) files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unannotated-assignment-in-stub/",
      "whyBad": "Stub files exist to provide type hints, and are never executed. As such,\nall assignments in stub files should be annotated with a type."
    },
    {
      "code": "PYI053",
      "name": "string-or-bytes-too-long",
      "summary": "Checks for the use of string and bytes literals longer than 50 characters\nin stub (`.pyi`) files.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/string-or-bytes-too-long/",
      "whyBad": "If a function or variable has a default value where the string or bytes\nrepresentation is greater than 50 characters long, it is likely to be an\nimplementation detail or a constant that varies depending on the system\nyou're running on.\n\nAlthough IDEs may find them useful, default values are ignored by type\ncheckers, the primary consumers of stub files. Replace very long constants\nwith ellipses (`...`) to simplify the stub.",
      "example": "```pyi\ndef foo(arg: str = \"51 character stringgggggggggggggggggggggggggggggggg\") -> None: ...\n```\n\nUse instead:\n\n```pyi\ndef foo(arg: str = ...) -> None: ...\n```"
    },
    {
      "code": "PYI054",
      "name": "numeric-literal-too-long",
      "summary": "Checks for numeric literals with a string representation longer than ten\ncharacters.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/numeric-literal-too-long/",
      "whyBad": "If a function has a default value where the literal representation is\ngreater than 10 characters, the value is likely to be an implementation\ndetail or a constant that varies depending on the system you're running on.\n\nDefault values like these should generally be omitted from stubs. Use\nellipses (`...`) instead.",
      "example": "```pyi\ndef foo(arg: int = 693568516352839939918568862861217771399698285293568) -> None: ...\n```\n\nUse instead:\n\n```pyi\ndef foo(arg: int = ...) -> None: ...\n```"
    },
    {
      "code": "PYI055",
      "name": "unnecessary-type-union",
      "summary": "Checks for the presence of multiple `type`s in a union.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-type-union/",
      "whyBad": "`type[T | S]` has identical semantics to `type[T] | type[S]` in a type\nannotation, but is cleaner and more concise.",
      "example": "```pyi\nfield: type[int] | type[float] | str\n```\n\nUse instead:\n```pyi\nfield: type[int | float] | str\n```"
    },
    {
      "code": "PYI056",
      "name": "unsupported-method-call-on-all",
      "summary": "Checks that `append`, `extend` and `remove` methods are not called on\n`__all__`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unsupported-method-call-on-all/",
      "whyBad": "Different type checkers have varying levels of support for calling these\nmethods on `__all__`. Instead, use the `+=` operator to add items to\n`__all__`, which is known to be supported by all major type checkers.",
      "example": "```pyi\nimport sys\n\n__all__ = [\"A\", \"B\"]\n\nif sys.version_info >= (3, 10):\n    __all__.append(\"C\")\n\nif sys.version_info >= (3, 11):\n    __all__.remove(\"B\")\n```\n\nUse instead:\n```pyi\nimport sys\n\n__all__ = [\"A\"]\n\nif sys.version_info < (3, 11):\n    __all__ += [\"B\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"C\"]\n```"
    },
    {
      "code": "PYI057",
      "name": "byte-string-usage",
      "summary": "Checks for uses of `typing.ByteString` or `collections.abc.ByteString`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/byte-string-usage/",
      "whyBad": "`ByteString` has been deprecated since Python 3.9 and will be removed in\nPython 3.14. The Python documentation recommends using either\n`collections.abc.Buffer` (or the `typing_extensions` backport\non Python <3.12) or a union like `bytes | bytearray | memoryview` instead.",
      "example": "```python\nfrom typing import ByteString\n```\n\nUse instead:\n```python\nfrom collections.abc import Buffer\n```"
    },
    {
      "code": "PYI058",
      "name": "generator-return-from-iter-method",
      "summary": "Checks for simple `__iter__` methods that return `Generator`, and for\nsimple `__aiter__` methods that return `AsyncGenerator`.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/generator-return-from-iter-method/",
      "whyBad": "Using `(Async)Iterator` for these methods is simpler and more elegant. More\nimportantly, it also reflects the fact that the precise kind of iterator\nreturned from an `__iter__` method is usually an implementation detail that\ncould change at any time. Type annotations help define a contract for a\nfunction; implementation details should not leak into that contract.\n\nFor example:\n```python\nfrom collections.abc import AsyncGenerator, Generator\nfrom typing import Any\n\n\nclass CustomIterator:\n    def __iter__(self) -> Generator:\n        yield from range(42)\n\n\nclass CustomIterator2:\n    def __iter__(self) -> Generator[str, Any, None]:\n        yield from \"abcdefg\"\n```\n\nUse instead:\n```python\nfrom collections.abc import Iterator\n\n\nclass CustomIterator:\n    def __iter__(self) -> Iterator:\n        yield from range(42)\n\n\nclass CustomIterator2:\n    def __iter__(self) -> Iterator[str]:\n        yield from \"abdefg\"\n```"
    },
    {
      "code": "PYI059",
      "name": "generic-not-last-base-class",
      "summary": "Checks for classes inheriting from `typing.Generic[]` where `Generic[]` is\nnot the last base class in the bases tuple.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/generic-not-last-base-class/",
      "whyBad": "If `Generic[]` is not the final class in the bases tuple, unexpected\nbehaviour can occur at runtime (See [this CPython issue][1] for an example).\n\nThe rule is also applied to stub files, where it won't cause issues at\nruntime. This is because type checkers may not be able to infer an\naccurate [MRO] for the class, which could lead to unexpected or\ninaccurate results when they analyze your code.\n\nFor example:\n```python\nfrom collections.abc import Container, Iterable, Sized\nfrom typing import Generic, TypeVar\n\n\nT = TypeVar(\"T\")\nK = TypeVar(\"K\")\nV = TypeVar(\"V\")\n\n\nclass LinkedList(Generic[T], Sized):\n    def push(self, item: T) -> None:\n        self._items.append(item)\n\n\nclass MyMapping(\n    Generic[K, V],\n    Iterable[tuple[K, V]],\n    Container[tuple[K, V]],\n):\n    ...\n```\n\nUse instead:\n```python\nfrom collections.abc import Container, Iterable, Sized\nfrom typing import Generic, TypeVar\n\n\nT = TypeVar(\"T\")\nK = TypeVar(\"K\")\nV = TypeVar(\"V\")\n\n\nclass LinkedList(Sized, Generic[T]):\n    def push(self, item: T) -> None:\n        self._items.append(item)\n\n\nclass MyMapping(\n    Iterable[tuple[K, V]],\n    Container[tuple[K, V]],\n    Generic[K, V],\n):\n    ...\n```"
    },
    {
      "code": "PYI061",
      "name": "redundant-none-literal",
      "summary": "Checks for redundant `Literal[None]` annotations.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-none-literal/",
      "whyBad": "While `Literal[None]` is a valid type annotation, it is semantically equivalent to `None`.\nPrefer `None` over `Literal[None]` for both consistency and readability.",
      "example": "```python\nfrom typing import Literal\n\nLiteral[None]\nLiteral[1, 2, 3, \"foo\", 5, None]\n```\n\nUse instead:\n```python\nfrom typing import Literal\n\nNone\nLiteral[1, 2, 3, \"foo\", 5] | None\n```"
    },
    {
      "code": "PYI062",
      "name": "duplicate-literal-member",
      "summary": "Checks for duplicate members in a `typing.Literal[]` slice.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/duplicate-literal-member/",
      "whyBad": "Duplicate literal members are redundant and should be removed.",
      "example": "```python\nfrom typing import Literal\n\nfoo: Literal[\"a\", \"b\", \"a\"]\n```\n\nUse instead:\n```python\nfrom typing import Literal\n\nfoo: Literal[\"a\", \"b\"]\n```"
    },
    {
      "code": "PYI063",
      "name": "pep484-style-positional-only-parameter",
      "summary": "Checks for the presence of [PEP 484]-style positional-only parameters.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pep484-style-positional-only-parameter/",
      "whyBad": "Historically, [PEP 484] recommended prefixing parameter names with double\nunderscores (`__`) to indicate to a type checker that they were\npositional-only. However, [PEP 570] (introduced in Python 3.8) introduced\ndedicated syntax for positional-only arguments. If a forward slash (`/`) is\npresent in a function signature on Python 3.8+, all parameters prior to the\nslash are interpreted as positional-only.\n\nThe new syntax should be preferred as it is more widely used, more concise\nand more readable. It is also respected by Python at runtime, whereas the\nold-style syntax was only understood by type checkers.",
      "example": "```pyi\ndef foo(__x: int) -> None: ...\n```\n\nUse instead:\n\n```pyi\ndef foo(x: int, /) -> None: ...\n```"
    },
    {
      "code": "PYI064",
      "name": "redundant-final-literal",
      "summary": "Checks for redundant `Final[Literal[...]]` annotations.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-final-literal/",
      "whyBad": "All constant variables annotated as `Final` are understood as implicitly\nhaving `Literal` types by a type checker. As such, a `Final[Literal[...]]`\nannotation can often be replaced with a bare `Final`, annotation, which\nwill have the same meaning to the type checker while being more concise and\nmore readable.",
      "example": "```pyi\nfrom typing import Final, Literal\n\nx: Final[Literal[42]]\ny: Final[Literal[42]] = 42\n```\n\nUse instead:\n```pyi\nfrom typing import Final, Literal\n\nx: Final = 42\ny: Final = 42\n```"
    },
    {
      "code": "PYI066",
      "name": "bad-version-info-order",
      "summary": "Checks for code that branches on `sys.version_info` comparisons where\nbranches corresponding to older Python versions come before branches\ncorresponding to newer Python versions.",
      "category": "flake8-pyi",
      "categoryCode": "PYI",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-version-info-order/",
      "whyBad": "As a convention, branches that correspond to newer Python versions should\ncome first. This makes it easier to understand the desired behavior, which\ntypically corresponds to the latest Python versions.\n\nThis rule enforces the convention by checking for `if` tests that compare\n`sys.version_info` with `<` rather than `>=`.\n\nBy default, this rule only applies to stub files.\nIn [preview], it will also flag this anti-pattern in non-stub files.",
      "example": "```pyi\nimport sys\n\nif sys.version_info < (3, 10):\n    def read_data(x, *, preserve_order=True): ...\n\nelse:\n    def read_data(x): ...\n```\n\nUse instead:\n\n```pyi\nif sys.version_info >= (3, 10):\n    def read_data(x): ...\n\nelse:\n    def read_data(x, *, preserve_order=True): ...\n```\n\n[preview]: https://docs.astral.sh/ruff/preview/"
    },
    {
      "code": "PT001",
      "name": "pytest-fixture-incorrect-parentheses-style",
      "summary": "Checks for argument-free `@pytest.fixture()` decorators with or without\nparentheses, depending on the [`lint.flake8-pytest-style.fixture-parentheses`]\nsetting.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-fixture-incorrect-parentheses-style/",
      "whyBad": "If a `@pytest.fixture()` doesn't take any arguments, the parentheses are\noptional.\n\nEither removing those unnecessary parentheses _or_ requiring them for all\nfixtures is fine, but it's best to be consistent. The rule defaults to\nremoving unnecessary parentheses, to match the documentation of the\nofficial pytest projects.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture(): ...\n```\n\nUse instead:\n\n```python\nimport pytest\n\n\n@pytest.fixture\ndef my_fixture(): ...\n```"
    },
    {
      "code": "PT002",
      "name": "pytest-fixture-positional-args",
      "summary": "Checks for `pytest.fixture` calls with positional arguments.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-fixture-positional-args/",
      "whyBad": "For clarity and consistency, prefer using keyword arguments to specify\nfixture configuration.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture(\"module\")\ndef my_fixture(): ...\n```\n\nUse instead:\n\n```python\nimport pytest\n\n\n@pytest.fixture(scope=\"module\")\ndef my_fixture(): ...\n```"
    },
    {
      "code": "PT003",
      "name": "pytest-extraneous-scope-function",
      "summary": "Checks for `pytest.fixture` calls with `scope=\"function\"`.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-extraneous-scope-function/",
      "whyBad": "`scope=\"function\"` can be omitted, as it is the default.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture(scope=\"function\")\ndef my_fixture(): ...\n```\n\nUse instead:\n\n```python\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture(): ...\n```"
    },
    {
      "code": "PT004",
      "name": "pytest-missing-fixture-name-underscore",
      "summary": "Checks for `pytest` fixtures that do not return a value, but are not named\nwith a leading underscore.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-missing-fixture-name-underscore/",
      "whyBad": "By convention, fixtures that don't return a value should be named with a\nleading underscore, while fixtures that do return a value should not.\n\nThis rule ignores abstract fixtures and generators.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture()\ndef patch_something(mocker):\n    mocker.patch(\"module.object\")\n\n\n@pytest.fixture()\ndef use_context():\n    with create_context():\n        yield\n```\n\nUse instead:\n```python\nimport pytest\n\n\n@pytest.fixture()\ndef _patch_something(mocker):\n    mocker.patch(\"module.object\")\n\n\n@pytest.fixture()\ndef _use_context():\n    with create_context():\n        yield\n```"
    },
    {
      "code": "PT005",
      "name": "pytest-incorrect-fixture-name-underscore",
      "summary": "Checks for `pytest` fixtures that return a value, but are named with a\nleading underscore.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-incorrect-fixture-name-underscore/",
      "whyBad": "By convention, fixtures that don't return a value should be named with a\nleading underscore, while fixtures that do return a value should not.\n\nThis rule ignores abstract fixtures.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture()\ndef _some_object():\n    return SomeClass()\n\n\n@pytest.fixture()\ndef _some_object_with_cleanup():\n    obj = SomeClass()\n    yield obj\n    obj.cleanup()\n```\n\nUse instead:\n```python\nimport pytest\n\n\n@pytest.fixture()\ndef some_object():\n    return SomeClass()\n\n\n@pytest.fixture()\ndef some_object_with_cleanup():\n    obj = SomeClass()\n    yield obj\n    obj.cleanup()\n```"
    },
    {
      "code": "PT006",
      "name": "pytest-parametrize-names-wrong-type",
      "summary": "Checks for the type of parameter names passed to `pytest.mark.parametrize`.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-parametrize-names-wrong-type/",
      "whyBad": "The `argnames` argument of `pytest.mark.parametrize` takes a string or\na sequence of strings. For a single parameter, it's preferable to use a\nstring. For multiple parameters, it's preferable to use the style\nconfigured via the [`lint.flake8-pytest-style.parametrize-names-type`] setting.",
      "example": "```python\nimport pytest"
    },
    {
      "code": "PT007",
      "name": "pytest-parametrize-values-wrong-type",
      "summary": "Checks for the type of parameter values passed to `pytest.mark.parametrize`.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-parametrize-values-wrong-type/",
      "whyBad": "The `argvalues` argument of `pytest.mark.parametrize` takes an iterator of\nparameter values, which can be provided as lists or tuples.\n\nTo aid in readability, it's recommended to use a consistent style for the\nlist of values rows, and, in the case of multiple parameters, for each row\nof values.\n\nThe style for the list of values rows can be configured via the\n[`lint.flake8-pytest-style.parametrize-values-type`] setting, while the\nstyle for each row of values can be configured via the\n[`lint.flake8-pytest-style.parametrize-values-row-type`] setting.\n\nFor example, [`lint.flake8-pytest-style.parametrize-values-type`] will lead to\nthe following expectations:\n\n- `tuple`: `@pytest.mark.parametrize(\"value\", (\"a\", \"b\", \"c\"))`\n- `list`: `@pytest.mark.parametrize(\"value\", [\"a\", \"b\", \"c\"])`\n\nSimilarly, [`lint.flake8-pytest-style.parametrize-values-row-type`] will lead to\nthe following expectations:\n\n- `tuple`: `@pytest.mark.parametrize((\"key\", \"value\"), [(\"a\", \"b\"), (\"c\", \"d\")])`\n- `list`: `@pytest.mark.parametrize((\"key\", \"value\"), [[\"a\", \"b\"], [\"c\", \"d\"]])`",
      "example": "```python\nimport pytest"
    },
    {
      "code": "PT008",
      "name": "pytest-patch-with-lambda",
      "summary": "Checks for mocked calls that use a dummy `lambda` function instead of\n`return_value`.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-patch-with-lambda/",
      "whyBad": "When patching calls, an explicit `return_value` better conveys the intent\nthan a `lambda` function, assuming the `lambda` does not use the arguments\npassed to it.\n\n`return_value` is also robust to changes in the patched function's\nsignature, and enables additional assertions to verify behavior. For\nexample, `return_value` allows for verification of the number of calls or\nthe arguments passed to the patched function via `assert_called_once_with`\nand related methods.",
      "example": "```python\ndef test_foo(mocker):\n    mocker.patch(\"module.target\", lambda x, y: 7)\n```\n\nUse instead:\n```python\ndef test_foo(mocker):\n    mocker.patch(\"module.target\", return_value=7)\n\n    # If the lambda makes use of the arguments, no diagnostic is emitted.\n    mocker.patch(\"module.other_target\", lambda x, y: x)\n```"
    },
    {
      "code": "PT009",
      "name": "pytest-unittest-assertion",
      "summary": "Checks for uses of assertion methods from the `unittest` module.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-unittest-assertion/",
      "whyBad": "To make use of `pytest`'s assertion rewriting, a regular `assert` statement\nis preferred over `unittest`'s assertion methods.",
      "example": "```python\nimport unittest\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        self.assertEqual(a, b)\n```\n\nUse instead:\n```python\nimport unittest\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        assert a == b\n```"
    },
    {
      "code": "PT010",
      "name": "pytest-raises-without-exception",
      "summary": "Checks for `pytest.raises` calls without an expected exception.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-raises-without-exception/",
      "whyBad": "`pytest.raises` expects to receive an expected exception as its first\nargument. If omitted, the `pytest.raises` call will fail at runtime.\nThe rule will also accept calls without an expected exception but with\n`match` and/or `check` keyword arguments, which are also valid after\npytest version 8.4.0.",
      "example": "```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises():\n        do_something()\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(SomeException):\n        do_something()\n```"
    },
    {
      "code": "PT011",
      "name": "pytest-raises-too-broad",
      "summary": "Checks for `pytest.raises` calls without a `match` parameter.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-raises-too-broad/",
      "whyBad": "`pytest.raises(Error)` will catch any `Error` and may catch errors that are\nunrelated to the code under test. To avoid this, `pytest.raises` should be\ncalled with a `match` parameter. The exception names that require a `match`\nparameter can be configured via the\n[`lint.flake8-pytest-style.raises-require-match-for`] and\n[`lint.flake8-pytest-style.raises-extend-require-match-for`] settings.",
      "example": "```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(ValueError):\n        ...\n\n    # empty string is also an error\n    with pytest.raises(ValueError, match=\"\"):\n        ...\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(ValueError, match=\"expected message\"):\n        ...\n```"
    },
    {
      "code": "PT012",
      "name": "pytest-raises-with-multiple-statements",
      "summary": "Checks for `pytest.raises` context managers with multiple statements.\n\nThis rule allows `pytest.raises` bodies to contain `for`\nloops with empty bodies (e.g., `pass` or `...` statements), to test\niterator behavior.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-raises-with-multiple-statements/",
      "whyBad": "When a `pytest.raises` is used as a context manager and contains multiple\nstatements, it can lead to the test passing when it actually should fail.\n\nA `pytest.raises` context manager should only contain a single simple\nstatement that raises the expected exception.",
      "example": "```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(MyError):\n        setup()\n        func_to_test()  # not executed if `setup()` raises `MyError`\n        assert foo()  # not executed\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo():\n    setup()\n    with pytest.raises(MyError):\n        func_to_test()\n    assert foo()\n```"
    },
    {
      "code": "PT013",
      "name": "pytest-incorrect-pytest-import",
      "summary": "Checks for incorrect import of pytest.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-incorrect-pytest-import/",
      "whyBad": "For consistency, `pytest` should be imported as `import pytest` and its members should be\naccessed in the form of `pytest.xxx.yyy` for consistency",
      "example": "```python\nimport pytest as pt\nfrom pytest import fixture\n```\n\nUse instead:\n```python\nimport pytest\n```"
    },
    {
      "code": "PT014",
      "name": "pytest-duplicate-parametrize-test-cases",
      "summary": "Checks for duplicate test cases in `pytest.mark.parametrize`.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-duplicate-parametrize-test-cases/",
      "whyBad": "Duplicate test cases are redundant and should be removed.",
      "example": "```python\nimport pytest\n\n\n@pytest.mark.parametrize(\n    (\"param1\", \"param2\"),\n    [\n        (1, 2),\n        (1, 2),\n    ],\n)\ndef test_foo(param1, param2): ...\n```\n\nUse instead:\n\n```python\nimport pytest\n\n\n@pytest.mark.parametrize(\n    (\"param1\", \"param2\"),\n    [\n        (1, 2),\n    ],\n)\ndef test_foo(param1, param2): ...\n```"
    },
    {
      "code": "PT015",
      "name": "pytest-assert-always-false",
      "summary": "Checks for `assert` statements whose test expression is a falsy value.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-assert-always-false/",
      "whyBad": "`pytest.fail` conveys the intent more clearly than `assert falsy_value`.",
      "example": "```python\ndef test_foo():\n    if some_condition:\n        assert False, \"some_condition was True\"\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo():\n    if some_condition:\n        pytest.fail(\"some_condition was True\")\n    ...\n```"
    },
    {
      "code": "PT016",
      "name": "pytest-fail-without-message",
      "summary": "Checks for `pytest.fail` calls without a message.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-fail-without-message/",
      "whyBad": "`pytest.fail` calls without a message make it harder to understand and debug test failures.",
      "example": "```python\nimport pytest\n\n\ndef test_foo():\n    pytest.fail()\n\n\ndef test_bar():\n    pytest.fail(\"\")\n\n\ndef test_baz():\n    pytest.fail(reason=\"\")\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo():\n    pytest.fail(\"...\")\n\n\ndef test_bar():\n    pytest.fail(reason=\"...\")\n```"
    },
    {
      "code": "PT017",
      "name": "pytest-assert-in-except",
      "summary": "Checks for `assert` statements in `except` clauses.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-assert-in-except/",
      "whyBad": "When testing for exceptions, `pytest.raises()` should be used instead of\n`assert` statements in `except` clauses, as it's more explicit and\nidiomatic. Further, `pytest.raises()` will fail if the exception is _not_\nraised, unlike the `assert` statement.",
      "example": "```python\ndef test_foo():\n    try:\n        1 / 0\n    except ZeroDivisionError as e:\n        assert e.args\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.raises(ZeroDivisionError) as exc_info:\n        1 / 0\n    assert exc_info.value.args\n```"
    },
    {
      "code": "PT018",
      "name": "pytest-composite-assertion",
      "summary": "Checks for assertions that combine multiple independent conditions.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-composite-assertion/",
      "whyBad": "Composite assertion statements are harder to debug upon failure, as the\nfailure message will not indicate which condition failed.",
      "example": "```python\ndef test_foo():\n    assert something and something_else\n\n\ndef test_bar():\n    assert not (something or something_else)\n```\n\nUse instead:\n```python\ndef test_foo():\n    assert something\n    assert something_else\n\n\ndef test_bar():\n    assert not something\n    assert not something_else\n```"
    },
    {
      "code": "PT019",
      "name": "pytest-fixture-param-without-value",
      "summary": "Checks for `pytest` test functions that should be decorated with\n`@pytest.mark.usefixtures`.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-fixture-param-without-value/",
      "whyBad": "In `pytest`, fixture injection is used to activate fixtures in a test\nfunction.\n\nFixtures can be injected either by passing them as parameters to the test\nfunction, or by using the `@pytest.mark.usefixtures` decorator.\n\nIf the test function depends on the fixture being activated, but does not\nuse it in the test body or otherwise rely on its return value, prefer\nthe `@pytest.mark.usefixtures` decorator, to make the dependency explicit\nand avoid the confusion caused by unused arguments.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture\ndef _patch_something(): ...\n\n\ndef test_foo(_patch_something): ...\n```\n\nUse instead:\n\n```python\nimport pytest\n\n\n@pytest.fixture\ndef _patch_something(): ...\n\n\n@pytest.mark.usefixtures(\"_patch_something\")\ndef test_foo(): ...\n```"
    },
    {
      "code": "PT020",
      "name": "pytest-deprecated-yield-fixture",
      "summary": "Checks for `pytest.yield_fixture` usage.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-deprecated-yield-fixture/",
      "whyBad": "`pytest.yield_fixture` is deprecated. `pytest.fixture` should be used instead.",
      "example": "```python\nimport pytest\n\n\n@pytest.yield_fixture()\ndef my_fixture():\n    obj = SomeClass()\n    yield obj\n    obj.cleanup()\n```\n\nUse instead:\n```python\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture():\n    obj = SomeClass()\n    yield obj\n    obj.cleanup()\n```"
    },
    {
      "code": "PT021",
      "name": "pytest-fixture-finalizer-callback",
      "summary": "Checks for unnecessary `request.addfinalizer` usages in `pytest` fixtures.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-fixture-finalizer-callback/",
      "whyBad": "`pytest` offers two ways to perform cleanup in fixture code. The first is\nsequential (via the `yield` statement), the second callback-based (via\n`request.addfinalizer`).\n\nThe sequential approach is more readable and should be preferred, unless\nthe fixture uses the \"factory as fixture\" pattern.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture(request):\n    resource = acquire_resource()\n    request.addfinalizer(resource.release)\n    return resource\n```\n\nUse instead:\n```python\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture():\n    resource = acquire_resource()\n    yield resource\n    resource.release()\n\n\n# \"factory-as-fixture\" pattern\n@pytest.fixture()\ndef my_factory(request):\n    def create_resource(arg):\n        resource = acquire_resource(arg)\n        request.addfinalizer(resource.release)\n        return resource\n\n    return create_resource\n```"
    },
    {
      "code": "PT022",
      "name": "pytest-useless-yield-fixture",
      "summary": "Checks for unnecessary `yield` expressions in `pytest` fixtures.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-useless-yield-fixture/",
      "whyBad": "In `pytest` fixtures, the `yield` expression should only be used for fixtures\nthat include teardown code, to clean up the fixture after the test function\nhas finished executing.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture():\n    resource = acquire_resource()\n    yield resource\n```\n\nUse instead:\n```python\nimport pytest\n\n\n@pytest.fixture()\ndef my_fixture_with_teardown():\n    resource = acquire_resource()\n    yield resource\n    resource.release()\n\n\n@pytest.fixture()\ndef my_fixture_without_teardown():\n    resource = acquire_resource()\n    return resource\n```"
    },
    {
      "code": "PT023",
      "name": "pytest-incorrect-mark-parentheses-style",
      "summary": "Checks for argument-free `@pytest.mark.<marker>()` decorators with or\nwithout parentheses, depending on the [`lint.flake8-pytest-style.mark-parentheses`]\nsetting.\n\nThe rule defaults to removing unnecessary parentheses,\nto match the documentation of the official pytest projects.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-incorrect-mark-parentheses-style/",
      "whyBad": "If a `@pytest.mark.<marker>()` doesn't take any arguments, the parentheses are\noptional.\n\nEither removing those unnecessary parentheses _or_ requiring them for all\nfixtures is fine, but it's best to be consistent.",
      "example": "```python\nimport pytest\n\n\n@pytest.mark.foo()\ndef test_something(): ...\n```\n\nUse instead:\n\n```python\nimport pytest\n\n\n@pytest.mark.foo\ndef test_something(): ...\n```"
    },
    {
      "code": "PT024",
      "name": "pytest-unnecessary-asyncio-mark-on-fixture",
      "summary": "Checks for unnecessary `@pytest.mark.asyncio` decorators applied to fixtures.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-unnecessary-asyncio-mark-on-fixture/",
      "whyBad": "`pytest.mark.asyncio` is unnecessary for fixtures.",
      "example": "```python\nimport pytest\n\n\n@pytest.mark.asyncio()\n@pytest.fixture()\nasync def my_fixture():\n    return 0\n```\n\nUse instead:\n```python\nimport pytest\n\n\n@pytest.fixture()\nasync def my_fixture():\n    return 0\n```"
    },
    {
      "code": "PT025",
      "name": "pytest-erroneous-use-fixtures-on-fixture",
      "summary": "Checks for `pytest.mark.usefixtures` decorators applied to `pytest`\nfixtures.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-erroneous-use-fixtures-on-fixture/",
      "whyBad": "The `pytest.mark.usefixtures` decorator has no effect on `pytest` fixtures.",
      "example": "```python\nimport pytest\n\n\n@pytest.fixture()\ndef a():\n    pass\n\n\n@pytest.mark.usefixtures(\"a\")\n@pytest.fixture()\ndef b(a):\n    pass\n```\n\nUse instead:\n```python\nimport pytest\n\n\n@pytest.fixture()\ndef a():\n    pass\n\n\n@pytest.fixture()\ndef b(a):\n    pass\n```"
    },
    {
      "code": "PT026",
      "name": "pytest-use-fixtures-without-parameters",
      "summary": "Checks for `@pytest.mark.usefixtures()` decorators that aren't passed any\narguments.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-use-fixtures-without-parameters/",
      "whyBad": "A `@pytest.mark.usefixtures()` decorator that isn't passed any arguments is\nuseless and should be removed.",
      "example": "```python\nimport pytest\n\n\n@pytest.mark.usefixtures()\ndef test_something(): ...\n```\n\nUse instead:\n\n```python\ndef test_something(): ...\n```"
    },
    {
      "code": "PT027",
      "name": "pytest-unittest-raises-assertion",
      "summary": "Checks for uses of exception-related assertion methods from the `unittest`\nmodule.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-unittest-raises-assertion/",
      "whyBad": "To enforce the assertion style recommended by `pytest`, `pytest.raises` is\npreferred over the exception-related assertion methods in `unittest`, like\n`assertRaises`.",
      "example": "```python\nimport unittest\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        with self.assertRaises(ValueError):\n            raise ValueError(\"foo\")\n```\n\nUse instead:\n```python\nimport unittest\nimport pytest\n\n\nclass TestFoo(unittest.TestCase):\n    def test_foo(self):\n        with pytest.raises(ValueError):\n            raise ValueError(\"foo\")\n```"
    },
    {
      "code": "PT028",
      "name": "pytest-parameter-with-default-argument",
      "summary": "Checks for parameters of test functions with default arguments.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-parameter-with-default-argument/",
      "whyBad": "Such a parameter will always have the default value during the test\nregardless of whether a fixture with the same name is defined.",
      "example": "```python\ndef test_foo(a=1): ...\n```\n\nUse instead:\n\n```python\ndef test_foo(a): ...\n```"
    },
    {
      "code": "PT029",
      "name": "pytest-warns-without-warning",
      "summary": "Checks for `pytest.warns` calls without an expected warning.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-warns-without-warning/",
      "whyBad": "`pytest.warns` expects to receive an expected warning as its first\nargument. If omitted, the `pytest.warns` call will fail at runtime.",
      "example": "```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.warns():\n        do_something()\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.warns(SomeWarning):\n        do_something()\n```"
    },
    {
      "code": "PT030",
      "name": "pytest-warns-too-broad",
      "summary": "Checks for `pytest.warns` calls without a `match` parameter.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-warns-too-broad/",
      "whyBad": "`pytest.warns(Warning)` will catch any `Warning` and may catch warnings that\nare unrelated to the code under test. To avoid this, `pytest.warns` should\nbe called with a `match` parameter. The warning names that require a `match`\nparameter can be configured via the\n[`lint.flake8-pytest-style.warns-require-match-for`] and\n[`lint.flake8-pytest-style.warns-extend-require-match-for`] settings.",
      "example": "```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.warns(Warning):\n        ...\n\n    # empty string is also an error\n    with pytest.warns(Warning, match=\"\"):\n        ...\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo():\n    with pytest.warns(Warning, match=\"expected message\"):\n        ...\n```"
    },
    {
      "code": "PT031",
      "name": "pytest-warns-with-multiple-statements",
      "summary": "Checks for `pytest.warns` context managers with multiple statements.\n\nThis rule allows `pytest.warns` bodies to contain `for`\nloops with empty bodies (e.g., `pass` or `...` statements), to test\niterator behavior.",
      "category": "flake8-pytest-style",
      "categoryCode": "PT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-warns-with-multiple-statements/",
      "whyBad": "When `pytest.warns` is used as a context manager and contains multiple\nstatements, it can lead to the test passing when it should instead fail.\n\nA `pytest.warns` context manager should only contain a single\nsimple statement that triggers the expected warning.",
      "example": "```python\nimport pytest\n\n\ndef test_foo_warns():\n    with pytest.warns(Warning):\n        setup()  # False negative if setup triggers a warning but foo does not.\n        foo()\n```\n\nUse instead:\n```python\nimport pytest\n\n\ndef test_foo_warns():\n    setup()\n    with pytest.warns(Warning):\n        foo()\n```"
    },
    {
      "code": "Q000",
      "name": "bad-quotes-inline-string",
      "summary": "Checks for inline strings that use single quotes or double quotes,\ndepending on the value of the [`lint.flake8-quotes.inline-quotes`] option.",
      "category": "flake8-quotes",
      "categoryCode": "Q",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-quotes-inline-string/",
      "whyBad": "Consistency is good. Use either single or double quotes for inline\nstrings, but be consistent.",
      "example": "```python\nfoo = 'bar'\n```\n\nAssuming `inline-quotes` is set to `double`, use instead:\n```python\nfoo = \"bar\"\n```"
    },
    {
      "code": "Q001",
      "name": "bad-quotes-multiline-string",
      "summary": "Checks for multiline strings that use single quotes or double quotes,\ndepending on the value of the [`lint.flake8-quotes.multiline-quotes`]\nsetting.",
      "category": "flake8-quotes",
      "categoryCode": "Q",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-quotes-multiline-string/",
      "whyBad": "Consistency is good. Use either single or double quotes for multiline\nstrings, but be consistent.",
      "example": "```python\nfoo = '''\nbar\n'''\n```\n\nAssuming `multiline-quotes` is set to `double`, use instead:\n```python\nfoo = \"\"\"\nbar\n\"\"\"\n```"
    },
    {
      "code": "Q002",
      "name": "bad-quotes-docstring",
      "summary": "Checks for docstrings that use single quotes or double quotes, depending\non the value of the [`lint.flake8-quotes.docstring-quotes`] setting.",
      "category": "flake8-quotes",
      "categoryCode": "Q",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-quotes-docstring/",
      "whyBad": "Consistency is good. Use either single or double quotes for docstring\nstrings, but be consistent.",
      "example": "```python\n'''\nbar\n'''\n```\n\nAssuming `docstring-quotes` is set to `double`, use instead:\n```python\n\"\"\"\nbar\n\"\"\"\n```"
    },
    {
      "code": "Q003",
      "name": "avoidable-escaped-quote",
      "summary": "Checks for strings that include escaped quotes, and suggests changing\nthe quote style to avoid the need to escape them.",
      "category": "flake8-quotes",
      "categoryCode": "Q",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/avoidable-escaped-quote/",
      "whyBad": "It's preferable to avoid escaped quotes in strings. By changing the\nouter quote style, you can avoid escaping inner quotes.",
      "example": "```python\nfoo = \"bar\\\"s\"\n```\n\nUse instead:\n```python\nfoo = 'bar\"s'\n```"
    },
    {
      "code": "Q004",
      "name": "unnecessary-escaped-quote",
      "summary": "Checks for strings that include unnecessarily escaped quotes.",
      "category": "flake8-quotes",
      "categoryCode": "Q",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-escaped-quote/",
      "whyBad": "If a string contains an escaped quote that doesn't match the quote\ncharacter used for the string, it's unnecessary and can be removed.",
      "example": "```python\nfoo = \"bar\\'s\"\n```\n\nUse instead:\n```python\nfoo = \"bar's\"\n```"
    },
    {
      "code": "RSE102",
      "name": "unnecessary-paren-on-raise-exception",
      "summary": "Checks for unnecessary parentheses on raised exceptions.",
      "category": "flake8-raise",
      "categoryCode": "RSE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-paren-on-raise-exception/",
      "whyBad": "If an exception is raised without any arguments, parentheses are not\nrequired, as the `raise` statement accepts either an exception instance\nor an exception class (which is then implicitly instantiated).\n\nRemoving the parentheses makes the code more concise.",
      "example": "```python\nraise TypeError()\n```\n\nUse instead:\n```python\nraise TypeError\n```"
    },
    {
      "code": "RET501",
      "name": "unnecessary-return-none",
      "summary": "Checks for the presence of a `return None` statement when `None` is the only\npossible return value.",
      "category": "flake8-return",
      "categoryCode": "RET",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-return-none/",
      "whyBad": "Python implicitly assumes `return None` if an explicit `return` value is\nomitted. Therefore, explicitly returning `None` is redundant and should be\navoided when it is the only possible `return` value across all code paths\nin a given function.",
      "example": "```python\ndef foo(bar):\n    if not bar:\n        return\n    return None\n```\n\nUse instead:\n```python\ndef foo(bar):\n    if not bar:\n        return\n    return\n```"
    },
    {
      "code": "RET502",
      "name": "implicit-return-value",
      "summary": "Checks for the presence of a `return` statement with no explicit value,\nfor functions that return non-`None` values elsewhere.",
      "category": "flake8-return",
      "categoryCode": "RET",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/implicit-return-value/",
      "whyBad": "Including a `return` statement with no explicit value can cause confusion\nwhen other `return` statements in the function return non-`None` values.\nPython implicitly assumes return `None` if no other return value is present.\nAdding an explicit `return None` can make the code more readable by clarifying\nintent.",
      "example": "```python\ndef foo(bar):\n    if not bar:\n        return\n    return 1\n```\n\nUse instead:\n```python\ndef foo(bar):\n    if not bar:\n        return None\n    return 1\n```"
    },
    {
      "code": "RET503",
      "name": "implicit-return",
      "summary": "Checks for missing explicit `return` statements at the end of functions\nthat can return non-`None` values.",
      "category": "flake8-return",
      "categoryCode": "RET",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/implicit-return/",
      "whyBad": "The lack of an explicit `return` statement at the end of a function that\ncan return non-`None` values can cause confusion. Python implicitly returns\n`None` if no other return value is present. Adding an explicit\n`return None` can make the code more readable by clarifying intent.",
      "example": "```python\ndef foo(bar):\n    if not bar:\n        return 1\n```\n\nUse instead:\n```python\ndef foo(bar):\n    if not bar:\n        return 1\n    return None\n```"
    },
    {
      "code": "RET504",
      "name": "unnecessary-assign",
      "summary": "Checks for variable assignments that immediately precede a `return` of the\nassigned variable.",
      "category": "flake8-return",
      "categoryCode": "RET",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-assign/",
      "whyBad": "The variable assignment is not necessary, as the value can be returned\ndirectly.",
      "example": "```python\ndef foo():\n    bar = 1\n    return bar\n```\n\nUse instead:\n```python\ndef foo():\n    return 1\n```"
    },
    {
      "code": "RET505",
      "name": "superfluous-else-return",
      "summary": "Checks for `else` statements with a `return` statement in the preceding\n`if` block.",
      "category": "flake8-return",
      "categoryCode": "RET",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/superfluous-else-return/",
      "whyBad": "The `else` statement is not needed as the `return` statement will always\nbreak out of the enclosing function. Removing the `else` will reduce\nnesting and make the code more readable.",
      "example": "```python\ndef foo(bar, baz):\n    if bar:\n        return 1\n    else:\n        return baz\n```\n\nUse instead:\n```python\ndef foo(bar, baz):\n    if bar:\n        return 1\n    return baz\n```"
    },
    {
      "code": "RET506",
      "name": "superfluous-else-raise",
      "summary": "Checks for `else` statements with a `raise` statement in the preceding `if`\nblock.",
      "category": "flake8-return",
      "categoryCode": "RET",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/superfluous-else-raise/",
      "whyBad": "The `else` statement is not needed as the `raise` statement will always\nbreak out of the current scope. Removing the `else` will reduce nesting\nand make the code more readable.",
      "example": "```python\ndef foo(bar, baz):\n    if bar == \"Specific Error\":\n        raise Exception(bar)\n    else:\n        raise Exception(baz)\n```\n\nUse instead:\n```python\ndef foo(bar, baz):\n    if bar == \"Specific Error\":\n        raise Exception(bar)\n    raise Exception(baz)\n```"
    },
    {
      "code": "RET507",
      "name": "superfluous-else-continue",
      "summary": "Checks for `else` statements with a `continue` statement in the preceding\n`if` block.",
      "category": "flake8-return",
      "categoryCode": "RET",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/superfluous-else-continue/",
      "whyBad": "The `else` statement is not needed, as the `continue` statement will always\ncontinue onto the next iteration of a loop. Removing the `else` will reduce\nnesting and make the code more readable.",
      "example": "```python\ndef foo(bar, baz):\n    for i in bar:\n        if i < baz:\n            continue\n        else:\n            x = 0\n```\n\nUse instead:\n```python\ndef foo(bar, baz):\n    for i in bar:\n        if i < baz:\n            continue\n        x = 0\n```"
    },
    {
      "code": "RET508",
      "name": "superfluous-else-break",
      "summary": "Checks for `else` statements with a `break` statement in the preceding `if`\nblock.",
      "category": "flake8-return",
      "categoryCode": "RET",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/superfluous-else-break/",
      "whyBad": "The `else` statement is not needed, as the `break` statement will always\nbreak out of the loop. Removing the `else` will reduce nesting and make the\ncode more readable.",
      "example": "```python\ndef foo(bar, baz):\n    for i in bar:\n        if i > baz:\n            break\n        else:\n            x = 0\n```\n\nUse instead:\n```python\ndef foo(bar, baz):\n    for i in bar:\n        if i > baz:\n            break\n        x = 0\n```"
    },
    {
      "code": "SLF001",
      "name": "private-member-access",
      "summary": "Checks for accesses on \"private\" class members.",
      "category": "flake8-self",
      "categoryCode": "SLF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/private-member-access/",
      "whyBad": "In Python, the convention is such that class members that are prefixed\nwith a single underscore, or prefixed but not suffixed with a double\nunderscore, are considered private and intended for internal use.\n\nUsing such \"private\" members is considered a misuse of the class, as\nthere are no guarantees that the member will be present in future\nversions, that it will have the same type, or that it will have the same\nbehavior. Instead, use the class's public interface.\n\nThis rule ignores accesses on dunder methods (e.g., `__init__`) and sunder\nmethods (e.g., `_missing_`).",
      "example": "```python\nclass Class:\n    def __init__(self):\n        self._private_member = \"...\"\n\n\nvar = Class()\nprint(var._private_member)\n```\n\nUse instead:\n```python\nclass Class:\n    def __init__(self):\n        self.public_member = \"...\"\n\n\nvar = Class()\nprint(var.public_member)\n```"
    },
    {
      "code": "SIM101",
      "name": "duplicate-isinstance-call",
      "summary": "Checks for multiple `isinstance` calls on the same target.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/duplicate-isinstance-call/",
      "whyBad": "To check if an object is an instance of any one of multiple types\nor classes, it is unnecessary to use multiple `isinstance` calls, as\nthe second argument of the `isinstance` built-in function accepts a\ntuple of types and classes.\n\nUsing a single `isinstance` call implements the same behavior with more\nconcise code and clearer intent.",
      "example": "```python\nif isinstance(obj, int) or isinstance(obj, float):\n    pass\n```\n\nUse instead:\n```python\nif isinstance(obj, (int, float)):\n    pass\n```"
    },
    {
      "code": "SIM102",
      "name": "collapsible-if",
      "summary": "Checks for nested `if` statements that can be collapsed into a single `if`\nstatement.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/collapsible-if/",
      "whyBad": "Nesting `if` statements leads to deeper indentation and makes code harder to\nread. Instead, combine the conditions into a single `if` statement with an\n`and` operator.",
      "example": "```python\nif foo:\n    if bar:\n        ...\n```\n\nUse instead:\n```python\nif foo and bar:\n    ...\n```"
    },
    {
      "code": "SIM103",
      "name": "needless-bool",
      "summary": "Checks for `if` statements that can be replaced with `bool`.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/needless-bool/",
      "whyBad": "`if` statements that return `True` for a truthy condition and `False` for\na falsy condition can be replaced with boolean casts.",
      "example": "Given:\n```python\ndef foo(x: int) -> bool:\n    if x > 0:\n        return True\n    else:\n        return False\n```\n\nUse instead:\n```python\ndef foo(x: int) -> bool:\n    return x > 0\n```\n\nOr, given:\n```python\ndef foo(x: int) -> bool:\n    if x > 0:\n        return True\n    return False\n```\n\nUse instead:\n```python\ndef foo(x: int) -> bool:\n    return x > 0\n```"
    },
    {
      "code": "SIM105",
      "name": "suppressible-exception",
      "summary": "Checks for `try`-`except`-`pass` blocks that can be replaced with the\n`contextlib.suppress` context manager.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/suppressible-exception/",
      "whyBad": "Using `contextlib.suppress` is more concise and directly communicates the\nintent of the code: to suppress a given exception.\n\nNote that `contextlib.suppress` is slower than using `try`-`except`-`pass`\ndirectly. For performance-critical code, consider retaining the\n`try`-`except`-`pass` pattern.",
      "example": "```python\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    pass\n```\n\nUse instead:\n```python\nimport contextlib\n\nwith contextlib.suppress(ZeroDivisionError):\n    1 / 0\n```"
    },
    {
      "code": "SIM107",
      "name": "return-in-try-except-finally",
      "summary": "Checks for `return` statements in `try`-`except` and `finally` blocks.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/return-in-try-except-finally/",
      "whyBad": "The `return` statement in a `finally` block will always be executed, even if\nan exception is raised in the `try` or `except` block. This can lead to\nunexpected behavior.",
      "example": "```python\ndef squared(n):\n    try:\n        sqr = n**2\n        return sqr\n    except Exception:\n        return \"An exception occurred\"\n    finally:\n        return -1  # Always returns -1.\n```\n\nUse instead:\n```python\ndef squared(n):\n    try:\n        return_value = n**2\n    except Exception:\n        return_value = \"An exception occurred\"\n    finally:\n        return_value = -1\n    return return_value\n```"
    },
    {
      "code": "SIM108",
      "name": "if-else-block-instead-of-if-exp",
      "summary": "Check for `if`-`else`-blocks that can be replaced with a ternary\nor binary operator.\n\nThe lint is suppressed if the suggested replacement would exceed\nthe maximum line length configured in [pycodestyle.max-line-length].",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-else-block-instead-of-if-exp/",
      "whyBad": "`if`-`else`-blocks that assign a value to a variable in both branches can\nbe expressed more concisely by using a ternary or binary operator.",
      "example": "```python\nif foo:\n    bar = x\nelse:\n    bar = y\n```\n\nUse instead:\n```python\nbar = x if foo else y\n```\n\nOr:\n\n```python\nif cond:\n    z = cond\nelse:\n    z = other_cond\n```\n\nUse instead:\n\n```python\nz = cond or other_cond\n```"
    },
    {
      "code": "SIM109",
      "name": "compare-with-tuple",
      "summary": "Checks for boolean expressions that contain multiple equality comparisons\nto the same value.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/compare-with-tuple/",
      "whyBad": "To check if an object is equal to any one of multiple values, it's more\nconcise to use the `in` operator with a tuple of values.",
      "example": "```python\nif foo == x or foo == y:\n    ...\n```\n\nUse instead:\n```python\nif foo in (x, y):\n    ...\n```"
    },
    {
      "code": "SIM110",
      "name": "reimplemented-builtin",
      "summary": "Checks for `for` loops that can be replaced with a builtin function, like\n`any` or `all`.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/reimplemented-builtin/",
      "whyBad": "Using a builtin function is more concise and readable.",
      "example": "```python\ndef foo():\n    for item in iterable:\n        if predicate(item):\n            return True\n    return False\n```\n\nUse instead:\n```python\ndef foo():\n    return any(predicate(item) for item in iterable)\n```"
    },
    {
      "code": "SIM112",
      "name": "uncapitalized-environment-variables",
      "summary": "Check for environment variables that are not capitalized.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/uncapitalized-environment-variables/",
      "whyBad": "By convention, environment variables should be capitalized.\n\nOn Windows, environment variables are case-insensitive and are converted to\nuppercase, so using lowercase environment variables can lead to subtle bugs.",
      "example": "```python\nimport os\n\nos.environ[\"foo\"]\n```\n\nUse instead:\n```python\nimport os\n\nos.environ[\"FOO\"]\n```"
    },
    {
      "code": "SIM113",
      "name": "enumerate-for-loop",
      "summary": "Checks for `for` loops with explicit loop-index variables that can be replaced\nwith `enumerate()`.\n\nIn [preview], this rule checks for index variables initialized with any integer rather than only\na literal zero.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/enumerate-for-loop/",
      "whyBad": "When iterating over a sequence, it's often desirable to keep track of the\nindex of each element alongside the element itself. Prefer the `enumerate`\nbuiltin over manually incrementing a counter variable within the loop, as\n`enumerate` is more concise and idiomatic.",
      "example": "```python\nfruits = [\"apple\", \"banana\", \"cherry\"]\ni = 0\nfor fruit in fruits:\n    print(f\"{i + 1}. {fruit}\")\n    i += 1\n```\n\nUse instead:\n```python\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor i, fruit in enumerate(fruits):\n    print(f\"{i + 1}. {fruit}\")\n```"
    },
    {
      "code": "SIM114",
      "name": "if-with-same-arms",
      "summary": "Checks for `if` branches with identical arm bodies.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-with-same-arms/",
      "whyBad": "If multiple arms of an `if` statement have the same body, using `or`\nbetter signals the intent of the statement.",
      "example": "```python\nif x == 1:\n    print(\"Hello\")\nelif x == 2:\n    print(\"Hello\")\n```\n\nUse instead:\n```python\nif x == 1 or x == 2:\n    print(\"Hello\")\n```"
    },
    {
      "code": "SIM115",
      "name": "open-file-with-context-handler",
      "summary": "Checks for cases where files are opened (e.g., using the builtin `open()` function)\nwithout using a context manager.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/open-file-with-context-handler/",
      "whyBad": "If a file is opened without a context manager, it is not guaranteed that\nthe file will be closed (e.g., if an exception is raised), which can cause\nresource leaks. The rule detects a wide array of IO calls where context managers\ncould be used, such as `open`, `pathlib.Path(...).open()`, `tempfile.TemporaryFile()`\nor`tarfile.TarFile(...).gzopen()`.",
      "example": "```python\nfile = open(\"foo.txt\")\n...\nfile.close()\n```\n\nUse instead:\n```python\nwith open(\"foo.txt\") as file:\n    ...\n```"
    },
    {
      "code": "SIM116",
      "name": "if-else-block-instead-of-dict-lookup",
      "summary": "Checks for three or more consecutive if-statements with direct returns",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-else-block-instead-of-dict-lookup/",
      "whyBad": "These can be simplified by using a dictionary",
      "example": "```python\ndef find_phrase(x):\n    if x == 1:\n        return \"Hello\"\n    elif x == 2:\n        return \"Goodbye\"\n    elif x == 3:\n        return \"Good morning\"\n    else:\n        return \"Goodnight\"\n```\n\nUse instead:\n```python\ndef find_phrase(x):\n    phrases = {1: \"Hello\", 2: \"Goodye\", 3: \"Good morning\"}\n    return phrases.get(x, \"Goodnight\")\n```"
    },
    {
      "code": "SIM117",
      "name": "multiple-with-statements",
      "summary": "Checks for the unnecessary nesting of multiple consecutive context\nmanagers.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-with-statements/",
      "whyBad": "In Python 3, a single `with` block can include multiple context\nmanagers.\n\nCombining multiple context managers into a single `with` statement\nwill minimize the indentation depth of the code, making it more\nreadable.\n\nThe following context managers are exempt when used as standalone\nstatements:\n\n - `anyio`.{`CancelScope`, `fail_after`, `move_on_after`}\n - `asyncio`.{`timeout`, `timeout_at`}\n - `trio`.{`fail_after`, `fail_at`, `move_on_after`, `move_on_at`}",
      "example": "```python\nwith A() as a:\n    with B() as b:\n        pass\n```\n\nUse instead:\n```python\nwith A() as a, B() as b:\n    pass\n```"
    },
    {
      "code": "SIM118",
      "name": "in-dict-keys",
      "summary": "Checks for key-existence checks against `dict.keys()` calls.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/in-dict-keys/",
      "whyBad": "When checking for the existence of a key in a given dictionary, using\n`key in dict` is more readable and efficient than `key in dict.keys()`,\nwhile having the same semantics.",
      "example": "```python\nkey in foo.keys()\n```\n\nUse instead:\n```python\nkey in foo\n```"
    },
    {
      "code": "SIM201",
      "name": "negate-equal-op",
      "summary": "Checks for negated `==` operators.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/negate-equal-op/",
      "whyBad": "Negated `==` operators are less readable than `!=` operators. When testing\nfor non-equality, it is more common to use `!=` than `==`.",
      "example": "```python\nnot a == b\n```\n\nUse instead:\n```python\na != b\n```"
    },
    {
      "code": "SIM202",
      "name": "negate-not-equal-op",
      "summary": "Checks for negated `!=` operators.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/negate-not-equal-op/",
      "whyBad": "Negated `!=` operators are less readable than `==` operators, as they avoid a\ndouble negation.",
      "example": "```python\nnot a != b\n```\n\nUse instead:\n```python\na == b\n```"
    },
    {
      "code": "SIM208",
      "name": "double-negation",
      "summary": "Checks for double negations (i.e., multiple `not` operators).",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/double-negation/",
      "whyBad": "A double negation is redundant and less readable than omitting the `not`\noperators entirely.",
      "example": "```python\nnot (not a)\n```\n\nUse instead:\n```python\na\n```"
    },
    {
      "code": "SIM210",
      "name": "if-expr-with-true-false",
      "summary": "Checks for `if` expressions that can be replaced with `bool()` calls.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-expr-with-true-false/",
      "whyBad": "`if` expressions that evaluate to `True` for a truthy condition an `False`\nfor a falsey condition can be replaced with `bool()` calls, which are more\nconcise and readable.",
      "example": "```python\nTrue if a else False\n```\n\nUse instead:\n```python\nbool(a)\n```"
    },
    {
      "code": "SIM211",
      "name": "if-expr-with-false-true",
      "summary": "Checks for `if` expressions that can be replaced by negating a given\ncondition.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-expr-with-false-true/",
      "whyBad": "`if` expressions that evaluate to `False` for a truthy condition and `True`\nfor a falsey condition can be replaced with `not` operators, which are more\nconcise and readable.",
      "example": "```python\nFalse if a else True\n```\n\nUse instead:\n```python\nnot a\n```"
    },
    {
      "code": "SIM212",
      "name": "if-expr-with-twisted-arms",
      "summary": "Checks for `if` expressions that check against a negated condition.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-expr-with-twisted-arms/",
      "whyBad": "`if` expressions that check against a negated condition are more difficult\nto read than `if` expressions that check against the condition directly.",
      "example": "```python\nb if not a else a\n```\n\nUse instead:\n```python\na if a else b\n```"
    },
    {
      "code": "SIM220",
      "name": "expr-and-not-expr",
      "summary": "Checks for `and` expressions that include both an expression and its\nnegation.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/expr-and-not-expr/",
      "whyBad": "An `and` expression that includes both an expression and its negation will\nalways evaluate to `False`.",
      "example": "```python\nx and not x\n```"
    },
    {
      "code": "SIM221",
      "name": "expr-or-not-expr",
      "summary": "Checks for `or` expressions that include both an expression and its\nnegation.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/expr-or-not-expr/",
      "whyBad": "An `or` expression that includes both an expression and its negation will\nalways evaluate to `True`.",
      "example": "```python\nx or not x\n```"
    },
    {
      "code": "SIM222",
      "name": "expr-or-true",
      "summary": "Checks for `or` expressions that contain truthy values.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/expr-or-true/",
      "whyBad": "If the expression is used as a condition, it can be replaced in-full with\n`True`.\n\nIn other cases, the expression can be short-circuited to the first truthy\nvalue.\n\nBy using `True` (or the first truthy value), the code is more concise\nand easier to understand, since it no longer contains redundant conditions.",
      "example": "```python\nif x or [1] or y:\n    pass\n\na = x or [1] or y\n```\n\nUse instead:\n```python\nif True:\n    pass\n\na = x or [1]\n```"
    },
    {
      "code": "SIM223",
      "name": "expr-and-false",
      "summary": "Checks for `and` expressions that contain falsey values.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/expr-and-false/",
      "whyBad": "If the expression is used as a condition, it can be replaced in-full with\n`False`.\n\nIn other cases, the expression can be short-circuited to the first falsey\nvalue.\n\nBy using `False` (or the first falsey value), the code is more concise\nand easier to understand, since it no longer contains redundant conditions.",
      "example": "```python\nif x and [] and y:\n    pass\n\na = x and [] and y\n```\n\nUse instead:\n```python\nif False:\n    pass\n\na = x and []\n```"
    },
    {
      "code": "SIM300",
      "name": "yoda-conditions",
      "summary": "Checks for conditions that position a constant on the left-hand side of the\ncomparison operator, rather than the right-hand side.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/yoda-conditions/",
      "whyBad": "These conditions (sometimes referred to as \"Yoda conditions\") are less\nreadable than conditions that place the variable on the left-hand side of\nthe comparison operator.\n\nIn some languages, Yoda conditions are used to prevent accidental\nassignment in conditions (i.e., accidental uses of the `=` operator,\ninstead of the `==` operator). However, Python does not allow assignments\nin conditions unless using the `:=` operator, so Yoda conditions provide\nno benefit in this regard.",
      "example": "```python\nif \"Foo\" == foo:\n    ...\n```\n\nUse instead:\n```python\nif foo == \"Foo\":\n    ...\n```"
    },
    {
      "code": "SIM401",
      "name": "if-else-block-instead-of-dict-get",
      "summary": "Checks for `if` statements that can be replaced with `dict.get` calls.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-else-block-instead-of-dict-get/",
      "whyBad": "`dict.get()` calls can be used to replace `if` statements that assign a\nvalue to a variable in both branches, falling back to a default value if\nthe key is not found. When possible, using `dict.get` is more concise and\nmore idiomatic.\n\nUnder [preview mode](https://docs.astral.sh/ruff/preview), this rule will\nalso suggest replacing `if`-`else` _expressions_ with `dict.get` calls.",
      "example": "```python\nfoo = {}\nif \"bar\" in foo:\n    value = foo[\"bar\"]\nelse:\n    value = 0\n```\n\nUse instead:\n```python\nfoo = {}\nvalue = foo.get(\"bar\", 0)\n```\n\nIf preview mode is enabled:\n```python\nvalue = foo[\"bar\"] if \"bar\" in foo else 0\n```\n\nUse instead:\n```python\nvalue = foo.get(\"bar\", 0)\n```"
    },
    {
      "code": "SIM905",
      "name": "split-static-string",
      "summary": "Checks for static `str.split` calls that can be replaced with list literals.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/split-static-string/",
      "whyBad": "List literals are more readable and do not require the overhead of calling `str.split`.",
      "example": "```python\n\"a,b,c,d\".split(\",\")\n```\n\nUse instead:\n```python\n[\"a\", \"b\", \"c\", \"d\"]\n```"
    },
    {
      "code": "SIM910",
      "name": "dict-get-with-none-default",
      "summary": "Checks for `dict.get()` calls that pass `None` as the default value.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/dict-get-with-none-default/",
      "whyBad": "`None` is the default value for `dict.get()`, so it is redundant to pass it\nexplicitly.",
      "example": "```python\nages = {\"Tom\": 23, \"Maria\": 23, \"Dog\": 11}\nage = ages.get(\"Cat\", None)\n```\n\nUse instead:\n```python\nages = {\"Tom\": 23, \"Maria\": 23, \"Dog\": 11}\nage = ages.get(\"Cat\")\n```"
    },
    {
      "code": "SIM911",
      "name": "zip-dict-keys-and-values",
      "summary": "Checks for use of `zip()` to iterate over keys and values of a dictionary at once.",
      "category": "flake8-simplify",
      "categoryCode": "SIM",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/zip-dict-keys-and-values/",
      "whyBad": "The `dict` type provides an `.items()` method which is faster and more readable.",
      "example": "```python\nflag_stars = {\"USA\": 50, \"Slovenia\": 3, \"Panama\": 2, \"Australia\": 6}\n\nfor country, stars in zip(flag_stars.keys(), flag_stars.values()):\n    print(f\"{country}'s flag has {stars} stars.\")\n```\n\nUse instead:\n```python\nflag_stars = {\"USA\": 50, \"Slovenia\": 3, \"Panama\": 2, \"Australia\": 6}\n\nfor country, stars in flag_stars.items():\n    print(f\"{country}'s flag has {stars} stars.\")\n```"
    },
    {
      "code": "SLOT000",
      "name": "no-slots-in-str-subclass",
      "summary": "Checks for subclasses of `str` that lack a `__slots__` definition.",
      "category": "flake8-slots",
      "categoryCode": "SLOT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-slots-in-str-subclass/",
      "whyBad": "In Python, the `__slots__` attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when `__slots__` is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\nSubclasses of `str` inherit all the attributes and methods of the built-in\n`str` class. Since strings are typically immutable, they don't require\nadditional attributes beyond what the `str` class provides. Defining\n`__slots__` for subclasses of `str` prevents the creation of a dictionary\nfor each instance, reducing memory consumption.",
      "example": "```python\nclass Foo(str):\n    pass\n```\n\nUse instead:\n```python\nclass Foo(str):\n    __slots__ = ()\n```"
    },
    {
      "code": "SLOT001",
      "name": "no-slots-in-tuple-subclass",
      "summary": "Checks for subclasses of `tuple` that lack a `__slots__` definition.",
      "category": "flake8-slots",
      "categoryCode": "SLOT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-slots-in-tuple-subclass/",
      "whyBad": "In Python, the `__slots__` attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when `__slots__` is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\nSubclasses of `tuple` inherit all the attributes and methods of the\nbuilt-in `tuple` class. Since tuples are typically immutable, they don't\nrequire additional attributes beyond what the `tuple` class provides.\nDefining `__slots__` for subclasses of `tuple` prevents the creation of a\ndictionary for each instance, reducing memory consumption.",
      "example": "```python\nclass Foo(tuple):\n    pass\n```\n\nUse instead:\n```python\nclass Foo(tuple):\n    __slots__ = ()\n```"
    },
    {
      "code": "SLOT002",
      "name": "no-slots-in-namedtuple-subclass",
      "summary": "Checks for subclasses of `collections.namedtuple` or `typing.NamedTuple`\nthat lack a `__slots__` definition.",
      "category": "flake8-slots",
      "categoryCode": "SLOT",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-slots-in-namedtuple-subclass/",
      "whyBad": "In Python, the `__slots__` attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when `__slots__` is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\nSubclasses of `namedtuple` inherit all the attributes and methods of the\nbuilt-in `namedtuple` class. Since tuples are typically immutable, they\ndon't require additional attributes beyond what the `namedtuple` class\nprovides. Defining `__slots__` for subclasses of `namedtuple` prevents the\ncreation of a dictionary for each instance, reducing memory consumption.",
      "example": "```python\nfrom collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    pass\n```\n\nUse instead:\n```python\nfrom collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    __slots__ = ()\n```"
    },
    {
      "code": "TID251",
      "name": "banned-api",
      "summary": "Checks for banned imports.",
      "category": "flake8-tidy-imports",
      "categoryCode": "TID",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/banned-api/",
      "whyBad": "Projects may want to ensure that specific modules or module members are\nnot imported or accessed.\n\nSecurity or other company policies may be a reason to impose\nrestrictions on importing external Python libraries. In some cases,\nprojects may adopt conventions around the use of certain modules or\nmodule members that are not enforceable by the language itself.\n\nThis rule enforces certain import conventions project-wide automatically."
    },
    {
      "code": "TID252",
      "name": "relative-imports",
      "summary": "Checks for relative imports.",
      "category": "flake8-tidy-imports",
      "categoryCode": "TID",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/relative-imports/",
      "whyBad": "Absolute imports, or relative imports from siblings, are recommended by [PEP 8]:\n\n> Absolute imports are recommended, as they are usually more readable and tend to be better behaved...\n> ```python\n> import mypkg.sibling\n> from mypkg import sibling\n> from mypkg.sibling import example\n> ```\n> However, explicit relative imports are an acceptable alternative to absolute imports,\n> especially when dealing with complex package layouts where using absolute imports would be\n> unnecessarily verbose:\n> ```python\n> from . import sibling\n> from .sibling import example\n> ```",
      "example": "```python\nfrom .. import foo\n```\n\nUse instead:\n```python\nfrom mypkg import foo\n```"
    },
    {
      "code": "TID253",
      "name": "banned-module-level-imports",
      "summary": "Checks for module-level imports that should instead be imported lazily\n(e.g., within a function definition, or an `if TYPE_CHECKING:` block, or\nsome other nested context).",
      "category": "flake8-tidy-imports",
      "categoryCode": "TID",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/banned-module-level-imports/",
      "whyBad": "Some modules are expensive to import. For example, importing `torch` or\n`tensorflow` can introduce a noticeable delay in the startup time of a\nPython program.\n\nIn such cases, you may want to enforce that the module is imported lazily\nas needed, rather than at the top of the file. This could involve inlining\nthe import into the function that uses it, rather than importing it\nunconditionally, to ensure that the module is only imported when necessary.",
      "example": "```python\nimport tensorflow as tf\n\n\ndef show_version():\n    print(tf.__version__)\n```\n\nUse instead:\n```python\ndef show_version():\n    import tensorflow as tf\n\n    print(tf.__version__)\n```"
    },
    {
      "code": "TD001",
      "name": "invalid-todo-tag",
      "summary": "Checks that a TODO comment is labelled with \"TODO\".",
      "category": "flake8-todos",
      "categoryCode": "TD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-todo-tag/",
      "whyBad": "Ambiguous tags reduce code visibility and can lead to dangling TODOs.\nFor example, if a comment is tagged with \"FIXME\" rather than \"TODO\", it may\nbe overlooked by future readers.\n\nNote that this rule will only flag \"FIXME\" and \"XXX\" tags as incorrect.",
      "example": "```python\n# FIXME(ruff): this should get fixed!\n```\n\nUse instead:\n```python\n# TODO(ruff): this is now fixed!\n```"
    },
    {
      "code": "TD002",
      "name": "missing-todo-author",
      "summary": "Checks that a TODO comment includes an author.",
      "category": "flake8-todos",
      "categoryCode": "TD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-todo-author/",
      "whyBad": "Including an author on a TODO provides future readers with context around\nthe issue. While the TODO author is not always considered responsible for\nfixing the issue, they are typically the individual with the most context.",
      "example": "```python\n# TODO: should assign an author here\n```\n\nUse instead\n```python\n# TODO(charlie): now an author is assigned\n```"
    },
    {
      "code": "TD003",
      "name": "missing-todo-link",
      "summary": "Checks that a TODO comment is associated with a link to a relevant issue\nor ticket.",
      "category": "flake8-todos",
      "categoryCode": "TD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-todo-link/",
      "whyBad": "Including an issue link near a TODO makes it easier for resolvers\nto get context around the issue.",
      "example": "```python\n# TODO: this link has no issue\n```\n\nUse one of these instead:\n```python\n# TODO(charlie): this comment has an issue link"
    },
    {
      "code": "TD004",
      "name": "missing-todo-colon",
      "summary": "Checks that a \"TODO\" tag is followed by a colon.",
      "category": "flake8-todos",
      "categoryCode": "TD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-todo-colon/",
      "whyBad": "\"TODO\" tags are typically followed by a parenthesized author name, a colon,\na space, and a description of the issue, in that order.\n\nDeviating from this pattern can lead to inconsistent and non-idiomatic\ncomments.",
      "example": "```python\n# TODO(charlie) fix this colon\n```\n\nUsed instead:\n```python\n# TODO(charlie): colon fixed\n```"
    },
    {
      "code": "TD005",
      "name": "missing-todo-description",
      "summary": "Checks that a \"TODO\" tag contains a description of the issue following the\ntag itself.",
      "category": "flake8-todos",
      "categoryCode": "TD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-todo-description/",
      "whyBad": "TODO comments should include a description of the issue to provide context\nfor future readers.",
      "example": "```python\n# TODO(charlie)\n```\n\nUse instead:\n```python\n# TODO(charlie): fix some issue\n```"
    },
    {
      "code": "TD006",
      "name": "invalid-todo-capitalization",
      "summary": "Checks that a \"TODO\" tag is properly capitalized (i.e., that the tag is\nuppercase).",
      "category": "flake8-todos",
      "categoryCode": "TD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-todo-capitalization/",
      "whyBad": "Capitalizing the \"TODO\" in a TODO comment is a convention that makes it\neasier for future readers to identify TODOs.",
      "example": "```python"
    },
    {
      "code": "TD007",
      "name": "missing-space-after-todo-colon",
      "summary": "Checks that the colon after a \"TODO\" tag is followed by a space.",
      "category": "flake8-todos",
      "categoryCode": "TD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-space-after-todo-colon/",
      "whyBad": "\"TODO\" tags are typically followed by a parenthesized author name, a colon,\na space, and a description of the issue, in that order.\n\nDeviating from this pattern can lead to inconsistent and non-idiomatic\ncomments.",
      "example": "```python\n# TODO(charlie):fix this\n```\n\nUse instead:\n```python\n# TODO(charlie): fix this\n```"
    },
    {
      "code": "TC001",
      "name": "typing-only-first-party-import",
      "summary": "Checks for first-party imports that are only used for type annotations, but\naren't defined in a type-checking block.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/typing-only-first-party-import/",
      "whyBad": "Unused imports add a performance overhead at runtime, and risk creating\nimport cycles. If an import is _only_ used in typing-only contexts, it can\ninstead be imported conditionally under an `if TYPE_CHECKING:` block to\nminimize runtime overhead.\n\nIf [`lint.flake8-type-checking.quote-annotations`] is set to `true`,\nannotations will be wrapped in quotes if doing so would enable the\ncorresponding import to be moved into an `if TYPE_CHECKING:` block.\n\nIf a class _requires_ that type annotations be available at runtime (as is\nthe case for Pydantic, SQLAlchemy, and other libraries), consider using\nthe [`lint.flake8-type-checking.runtime-evaluated-base-classes`] and\n[`lint.flake8-type-checking.runtime-evaluated-decorators`] settings to mark them\nas such.\n\nIf [`lint.future-annotations`] is set to `true`, `from __future__ import\nannotations` will be added if doing so would enable an import to be\nmoved into an `if TYPE_CHECKING:` block. This takes precedence over the\n[`lint.flake8-type-checking.quote-annotations`] setting described above if\nboth settings are enabled.",
      "example": "```python\nfrom __future__ import annotations\n\nfrom . import local_module\n\n\ndef func(sized: local_module.Container) -> int:\n    return len(sized)\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from . import local_module\n\n\ndef func(sized: local_module.Container) -> int:\n    return len(sized)\n```"
    },
    {
      "code": "TC002",
      "name": "typing-only-third-party-import",
      "summary": "Checks for third-party imports that are only used for type annotations, but\naren't defined in a type-checking block.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/typing-only-third-party-import/",
      "whyBad": "Unused imports add a performance overhead at runtime, and risk creating\nimport cycles. If an import is _only_ used in typing-only contexts, it can\ninstead be imported conditionally under an `if TYPE_CHECKING:` block to\nminimize runtime overhead.\n\nIf [`lint.flake8-type-checking.quote-annotations`] is set to `true`,\nannotations will be wrapped in quotes if doing so would enable the\ncorresponding import to be moved into an `if TYPE_CHECKING:` block.\n\nIf a class _requires_ that type annotations be available at runtime (as is\nthe case for Pydantic, SQLAlchemy, and other libraries), consider using\nthe [`lint.flake8-type-checking.runtime-evaluated-base-classes`] and\n[`lint.flake8-type-checking.runtime-evaluated-decorators`] settings to mark them\nas such.\n\nIf [`lint.future-annotations`] is set to `true`, `from __future__ import\nannotations` will be added if doing so would enable an import to be\nmoved into an `if TYPE_CHECKING:` block. This takes precedence over the\n[`lint.flake8-type-checking.quote-annotations`] setting described above if\nboth settings are enabled.",
      "example": "```python\nfrom __future__ import annotations\n\nimport pandas as pd\n\n\ndef func(df: pd.DataFrame) -> int:\n    return len(df)\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import pandas as pd\n\n\ndef func(df: pd.DataFrame) -> int:\n    return len(df)\n```"
    },
    {
      "code": "TC003",
      "name": "typing-only-standard-library-import",
      "summary": "Checks for standard library imports that are only used for type\nannotations, but aren't defined in a type-checking block.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/typing-only-standard-library-import/",
      "whyBad": "Unused imports add a performance overhead at runtime, and risk creating\nimport cycles. If an import is _only_ used in typing-only contexts, it can\ninstead be imported conditionally under an `if TYPE_CHECKING:` block to\nminimize runtime overhead.\n\nIf [`lint.flake8-type-checking.quote-annotations`] is set to `true`,\nannotations will be wrapped in quotes if doing so would enable the\ncorresponding import to be moved into an `if TYPE_CHECKING:` block.\n\nIf a class _requires_ that type annotations be available at runtime (as is\nthe case for Pydantic, SQLAlchemy, and other libraries), consider using\nthe [`lint.flake8-type-checking.runtime-evaluated-base-classes`] and\n[`lint.flake8-type-checking.runtime-evaluated-decorators`] settings to mark them\nas such.\n\nIf [`lint.future-annotations`] is set to `true`, `from __future__ import\nannotations` will be added if doing so would enable an import to be\nmoved into an `if TYPE_CHECKING:` block. This takes precedence over the\n[`lint.flake8-type-checking.quote-annotations`] setting described above if\nboth settings are enabled.",
      "example": "```python\nfrom __future__ import annotations\n\nfrom pathlib import Path\n\n\ndef func(path: Path) -> str:\n    return str(path)\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from pathlib import Path\n\n\ndef func(path: Path) -> str:\n    return str(path)\n```"
    },
    {
      "code": "TC004",
      "name": "runtime-import-in-type-checking-block",
      "summary": "Checks for imports that are required at runtime but are only defined in\ntype-checking blocks.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/runtime-import-in-type-checking-block/",
      "whyBad": "The type-checking block is not executed at runtime, so if the only definition\nof a symbol is in a type-checking block, it will not be available at runtime.\n\nIf [`lint.flake8-type-checking.quote-annotations`] is set to `true`,\nannotations will be wrapped in quotes if doing so would enable the\ncorresponding import to remain in the type-checking block.",
      "example": "```python\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import foo\n\n\ndef bar() -> None:\n    foo.bar()  # raises NameError: name 'foo' is not defined\n```\n\nUse instead:\n```python\nimport foo\n\n\ndef bar() -> None:\n    foo.bar()\n```"
    },
    {
      "code": "TC005",
      "name": "empty-type-checking-block",
      "summary": "Checks for an empty type-checking block.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/empty-type-checking-block/",
      "whyBad": "The type-checking block does not do anything and should be removed to avoid\nconfusion.",
      "example": "```python\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    pass\n\nprint(\"Hello, world!\")\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\")\n```"
    },
    {
      "code": "TC006",
      "name": "runtime-cast-value",
      "summary": "Checks for unquoted type expressions in `typing.cast()` calls.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/runtime-cast-value/",
      "whyBad": "This rule helps enforce a consistent style across your codebase.\n\nIt's often necessary to quote the first argument passed to `cast()`,\nas type expressions can involve forward references, or references\nto symbols which are only imported in `typing.TYPE_CHECKING` blocks.\nThis can lead to a visual inconsistency across different `cast()` calls,\nwhere some type expressions are quoted but others are not. By enabling\nthis rule, you ensure that all type expressions passed to `cast()` are\nquoted, enforcing stylistic consistency across all of your `cast()` calls.\n\nIn some cases where `cast()` is used in a hot loop, this rule may also\nhelp avoid overhead from repeatedly evaluating complex type expressions at\nruntime.",
      "example": "```python\nfrom typing import cast\n\nx = cast(dict[str, int], foo)\n```\n\nUse instead:\n```python\nfrom typing import cast\n\nx = cast(\"dict[str, int]\", foo)\n```"
    },
    {
      "code": "TC007",
      "name": "unquoted-type-alias",
      "summary": "Checks if [PEP 613] explicit type aliases contain references to\nsymbols that are not available at runtime.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unquoted-type-alias/",
      "whyBad": "Referencing type-checking only symbols results in a `NameError` at runtime.",
      "example": "```python\nfrom typing import TYPE_CHECKING, TypeAlias\n\nif TYPE_CHECKING:\n    from foo import Foo\nOptFoo: TypeAlias = Foo | None\n```\n\nUse instead:\n```python\nfrom typing import TYPE_CHECKING, TypeAlias\n\nif TYPE_CHECKING:\n    from foo import Foo\nOptFoo: TypeAlias = \"Foo | None\"\n```"
    },
    {
      "code": "TC008",
      "name": "quoted-type-alias",
      "summary": "Checks for unnecessary quotes in [PEP 613] explicit type aliases\nand [PEP 695] type statements.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/quoted-type-alias/",
      "whyBad": "Unnecessary string forward references can lead to additional overhead\nin runtime libraries making use of type hints. They can also have bad\ninteractions with other runtime uses like [PEP 604] type unions.\n\nPEP-613 type aliases are only flagged by the rule if Ruff can have high\nconfidence that the quotes are unnecessary. Specifically, any PEP-613\ntype alias where the type expression on the right-hand side contains\nsubscripts or attribute accesses will not be flagged. This is because\ntype aliases can reference types that are, for example, generic in stub\nfiles but not at runtime. That can mean that a type checker expects the\nreferenced type to be subscripted with type arguments despite the fact\nthat doing so would fail at runtime if the type alias value was not\nquoted. Similarly, a type alias might need to reference a module-level\nattribute that exists in a stub file but not at runtime, meaning that\nthe type alias value would need to be quoted to avoid a runtime error.",
      "example": "Given:\n```python\nfrom typing import TypeAlias\n\nOptInt: TypeAlias = \"int | None\"\n```\n\nUse instead:\n```python\nfrom typing import TypeAlias\n\nOptInt: TypeAlias = int | None\n```\n\nGiven:\n```python\ntype OptInt = \"int | None\"\n```\n\nUse instead:\n```python\ntype OptInt = int | None\n```"
    },
    {
      "code": "TC010",
      "name": "runtime-string-union",
      "summary": "Checks for the presence of string literals in `X | Y`-style union types.",
      "category": "flake8-type-checking",
      "categoryCode": "TC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/runtime-string-union/",
      "whyBad": "[PEP 604] introduced a new syntax for union type annotations based on the\n`|` operator.\n\nWhile Python's type annotations can typically be wrapped in strings to\navoid runtime evaluation, the use of a string member within an `X | Y`-style\nunion type will cause a runtime error.\n\nInstead, remove the quotes, wrap the _entire_ union in quotes, or use\n`from __future__ import annotations` to disable runtime evaluation of\nannotations entirely.",
      "example": "```python\nvar: \"Foo\" | None\n\n\nclass Foo: ...\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nvar: Foo | None\n\n\nclass Foo: ...\n```\n\nOr, extend the quotes to include the entire union:\n```python\nvar: \"Foo | None\"\n\n\nclass Foo: ...\n```"
    },
    {
      "code": "ARG001",
      "name": "unused-function-argument",
      "summary": "Checks for the presence of unused arguments in function definitions.",
      "category": "flake8-unused-arguments",
      "categoryCode": "ARG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-function-argument/",
      "whyBad": "An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\n[`lint.dummy-variable-rgx`] pattern.",
      "example": "```python\ndef foo(bar, baz):\n    return bar * 2\n```\n\nUse instead:\n```python\ndef foo(bar):\n    return bar * 2\n```"
    },
    {
      "code": "ARG002",
      "name": "unused-method-argument",
      "summary": "Checks for the presence of unused arguments in instance method definitions.",
      "category": "flake8-unused-arguments",
      "categoryCode": "ARG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-method-argument/",
      "whyBad": "An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\n[`lint.dummy-variable-rgx`] pattern.\n\nThis rule exempts methods decorated with [`@typing.override`][override].\nRemoving a parameter from a subclass method (or changing a parameter's\nname) may cause type checkers to complain about a violation of the Liskov\nSubstitution Principle if it means that the method now incompatibly\noverrides a method defined on a superclass. Explicitly decorating an\noverriding method with `@override` signals to Ruff that the method is\nintended to override a superclass method and that a type checker will\nenforce that it does so; Ruff therefore knows that it should not enforce\nrules about unused arguments on such methods.",
      "example": "```python\nclass Class:\n    def foo(self, arg1, arg2):\n        print(arg1)\n```\n\nUse instead:\n```python\nclass Class:\n    def foo(self, arg1):\n        print(arg1)\n```"
    },
    {
      "code": "ARG003",
      "name": "unused-class-method-argument",
      "summary": "Checks for the presence of unused arguments in class method definitions.",
      "category": "flake8-unused-arguments",
      "categoryCode": "ARG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-class-method-argument/",
      "whyBad": "An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\n[`lint.dummy-variable-rgx`] pattern.\n\nThis rule exempts methods decorated with [`@typing.override`][override].\nRemoving a parameter from a subclass method (or changing a parameter's\nname) may cause type checkers to complain about a violation of the Liskov\nSubstitution Principle if it means that the method now incompatibly\noverrides a method defined on a superclass. Explicitly decorating an\noverriding method with `@override` signals to Ruff that the method is\nintended to override a superclass method and that a type checker will\nenforce that it does so; Ruff therefore knows that it should not enforce\nrules about unused arguments on such methods.",
      "example": "```python\nclass Class:\n    @classmethod\n    def foo(cls, arg1, arg2):\n        print(arg1)\n```\n\nUse instead:\n```python\nclass Class:\n    @classmethod\n    def foo(cls, arg1):\n        print(arg1)\n```"
    },
    {
      "code": "ARG004",
      "name": "unused-static-method-argument",
      "summary": "Checks for the presence of unused arguments in static method definitions.",
      "category": "flake8-unused-arguments",
      "categoryCode": "ARG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-static-method-argument/",
      "whyBad": "An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\n[`lint.dummy-variable-rgx`] pattern.\n\nThis rule exempts methods decorated with [`@typing.override`][override].\nRemoving a parameter from a subclass method (or changing a parameter's\nname) may cause type checkers to complain about a violation of the Liskov\nSubstitution Principle if it means that the method now incompatibly\noverrides a method defined on a superclass. Explicitly decorating an\noverriding method with `@override` signals to Ruff that the method is\nintended to override a superclass method, and that a type checker will\nenforce that it does so; Ruff therefore knows that it should not enforce\nrules about unused arguments on such methods.",
      "example": "```python\nclass Class:\n    @staticmethod\n    def foo(arg1, arg2):\n        print(arg1)\n```\n\nUse instead:\n```python\nclass Class:\n    @staticmethod\n    def foo(arg1):\n        print(arg1)\n```"
    },
    {
      "code": "ARG005",
      "name": "unused-lambda-argument",
      "summary": "Checks for the presence of unused arguments in lambda expression\ndefinitions.",
      "category": "flake8-unused-arguments",
      "categoryCode": "ARG",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-lambda-argument/",
      "whyBad": "An argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\n[`lint.dummy-variable-rgx`] pattern.",
      "example": "```python\nmy_list = [1, 2, 3, 4, 5]\nsquares = map(lambda x, y: x**2, my_list)\n```\n\nUse instead:\n```python\nmy_list = [1, 2, 3, 4, 5]\nsquares = map(lambda x: x**2, my_list)\n```"
    },
    {
      "code": "PTH100",
      "name": "os-path-abspath",
      "summary": "Checks for uses of `os.path.abspath`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-abspath/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.resolve()` can improve readability over the `os.path`\nmodule's counterparts (e.g., `os.path.abspath()`)."
    },
    {
      "code": "PTH101",
      "name": "os-chmod",
      "summary": "Checks for uses of `os.chmod`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-chmod/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.chmod()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.chmod()`)."
    },
    {
      "code": "PTH102",
      "name": "os-mkdir",
      "summary": "Checks for uses of `os.mkdir`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-mkdir/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.mkdir()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.mkdir()`)."
    },
    {
      "code": "PTH103",
      "name": "os-makedirs",
      "summary": "Checks for uses of `os.makedirs`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-makedirs/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.mkdir(parents=True)` can improve readability over the\n`os` module's counterparts (e.g., `os.makedirs()`."
    },
    {
      "code": "PTH104",
      "name": "os-rename",
      "summary": "Checks for uses of `os.rename`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-rename/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.rename()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.rename()`)."
    },
    {
      "code": "PTH105",
      "name": "os-replace",
      "summary": "Checks for uses of `os.replace`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-replace/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.replace()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.replace()`).\n\nNote that `os` functions may be preferable if performance is a concern,\ne.g., in hot loops."
    },
    {
      "code": "PTH106",
      "name": "os-rmdir",
      "summary": "Checks for uses of `os.rmdir`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-rmdir/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.rmdir()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.rmdir()`)."
    },
    {
      "code": "PTH107",
      "name": "os-remove",
      "summary": "Checks for uses of `os.remove`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-remove/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.unlink()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.remove()`)."
    },
    {
      "code": "PTH108",
      "name": "os-unlink",
      "summary": "Checks for uses of `os.unlink`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-unlink/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.unlink()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.unlink()`)."
    },
    {
      "code": "PTH109",
      "name": "os-getcwd",
      "summary": "Checks for uses of `os.getcwd` and `os.getcwdb`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-getcwd/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.cwd()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.getcwd()`)."
    },
    {
      "code": "PTH110",
      "name": "os-path-exists",
      "summary": "Checks for uses of `os.path.exists`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-exists/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.exists()` can improve readability over the `os.path`\nmodule's counterparts (e.g., `os.path.exists()`)."
    },
    {
      "code": "PTH111",
      "name": "os-path-expanduser",
      "summary": "Checks for uses of `os.path.expanduser`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-expanduser/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.expanduser()` can improve readability over the `os.path`\nmodule's counterparts (e.g., as `os.path.expanduser()`)."
    },
    {
      "code": "PTH112",
      "name": "os-path-isdir",
      "summary": "Checks for uses of `os.path.isdir`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-isdir/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.is_dir()` can improve readability over the `os.path`\nmodule's counterparts (e.g., `os.path.isdir()`)."
    },
    {
      "code": "PTH113",
      "name": "os-path-isfile",
      "summary": "Checks for uses of `os.path.isfile`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-isfile/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.is_file()` can improve readability over the `os.path`\nmodule's counterparts (e.g., `os.path.isfile()`)."
    },
    {
      "code": "PTH114",
      "name": "os-path-islink",
      "summary": "Checks for uses of `os.path.islink`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-islink/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.is_symlink()` can improve readability over the `os.path`\nmodule's counterparts (e.g., `os.path.islink()`)."
    },
    {
      "code": "PTH115",
      "name": "os-readlink",
      "summary": "Checks for uses of `os.readlink`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-readlink/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.readlink()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.readlink()`)."
    },
    {
      "code": "PTH116",
      "name": "os-stat",
      "summary": "Checks for uses of `os.stat`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-stat/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `Path` object\nmethods such as `Path.stat()` can improve readability over the `os`\nmodule's counterparts (e.g., `os.path.stat()`)."
    },
    {
      "code": "PTH117",
      "name": "os-path-isabs",
      "summary": "Checks for uses of `os.path.isabs`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-isabs/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.is_absolute()` can improve readability over the `os.path`\nmodule's counterparts (e.g.,  as `os.path.isabs()`)."
    },
    {
      "code": "PTH118",
      "name": "os-path-join",
      "summary": "Checks for uses of `os.path.join`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-join/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.joinpath()` or the `/` operator can improve\nreadability over the `os.path` module's counterparts (e.g., `os.path.join()`)."
    },
    {
      "code": "PTH119",
      "name": "os-path-basename",
      "summary": "Checks for uses of `os.path.basename`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-basename/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.name` can improve readability over the `os.path`\nmodule's counterparts (e.g., `os.path.basename()`)."
    },
    {
      "code": "PTH120",
      "name": "os-path-dirname",
      "summary": "Checks for uses of `os.path.dirname`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-dirname/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.parent` can improve readability over the `os.path`\nmodule's counterparts (e.g., `os.path.dirname()`)."
    },
    {
      "code": "PTH121",
      "name": "os-path-samefile",
      "summary": "Checks for uses of `os.path.samefile`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-samefile/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.samefile()` can improve readability over the `os.path`\nmodule's counterparts (e.g., `os.path.samefile()`)."
    },
    {
      "code": "PTH122",
      "name": "os-path-splitext",
      "summary": "Checks for uses of `os.path.splitext`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-splitext/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`. When possible, using `Path` object\nmethods such as `Path.suffix` and `Path.stem` can improve readability over\nthe `os.path` module's counterparts (e.g., `os.path.splitext()`).\n\n`os.path.splitext()` specifically returns a tuple of the file root and\nextension (e.g., given `splitext('/foo/bar.py')`, `os.path.splitext()`\nreturns `(\"foo/bar\", \".py\")`. These outputs can be reconstructed through a\ncombination of `Path.suffix` (`\".py\"`), `Path.stem` (`\"bar\"`), and\n`Path.parent` (`\"foo\"`)."
    },
    {
      "code": "PTH123",
      "name": "builtin-open",
      "summary": "Checks for uses of the `open()` builtin.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/builtin-open/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation. When possible,\nusing `Path` object methods such as `Path.open()` can improve readability\nover the `open` builtin."
    },
    {
      "code": "PTH124",
      "name": "py-path",
      "summary": "Checks for uses of the `py.path` library.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/py-path/",
      "whyBad": "The `py.path` library is in maintenance mode. Instead, prefer the standard\nlibrary's `pathlib` module, or third-party modules like `path` (formerly\n`py.path`)."
    },
    {
      "code": "PTH201",
      "name": "path-constructor-current-directory",
      "summary": "Checks for `pathlib.Path` objects that are initialized with the current\ndirectory.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/path-constructor-current-directory/",
      "whyBad": "The `Path()` constructor defaults to the current directory, so passing it\nin explicitly (as `\".\"`) is unnecessary.",
      "example": "```python\nfrom pathlib import Path\n\n_ = Path(\".\")\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\n_ = Path()\n```"
    },
    {
      "code": "PTH202",
      "name": "os-path-getsize",
      "summary": "Checks for uses of `os.path.getsize`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-getsize/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`.\n\nWhen possible, using `Path` object methods such as `Path.stat()` can\nimprove readability over the `os.path` module's counterparts (e.g.,\n`os.path.getsize()`).",
      "example": "```python\nimport os\n\nos.path.getsize(__file__)\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nPath(__file__).stat().st_size\n```"
    },
    {
      "code": "PTH203",
      "name": "os-path-getatime",
      "summary": "Checks for uses of `os.path.getatime`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-getatime/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`.\n\nWhen possible, using `Path` object methods such as `Path.stat()` can\nimprove readability over the `os.path` module's counterparts (e.g.,\n`os.path.getatime()`).",
      "example": "```python\nimport os\n\nos.path.getatime(__file__)\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nPath(__file__).stat().st_atime\n```"
    },
    {
      "code": "PTH204",
      "name": "os-path-getmtime",
      "summary": "Checks for uses of `os.path.getmtime`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-getmtime/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`.\n\nWhen possible, using `Path` object methods such as `Path.stat()` can\nimprove readability over the `os.path` module's counterparts (e.g.,\n`os.path.getmtime()`).",
      "example": "```python\nimport os\n\nos.path.getmtime(__file__)\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nPath(__file__).stat().st_mtime\n```"
    },
    {
      "code": "PTH205",
      "name": "os-path-getctime",
      "summary": "Checks for uses of `os.path.getctime`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-path-getctime/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.path`.\n\nWhen possible, using `Path` object methods such as `Path.stat()` can\nimprove readability over the `os.path` module's counterparts (e.g.,\n`os.path.getctime()`).",
      "example": "```python\nimport os\n\nos.path.getctime(__file__)\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nPath(__file__).stat().st_ctime\n```"
    },
    {
      "code": "PTH206",
      "name": "os-sep-split",
      "summary": "Checks for uses of `.split(os.sep)`",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-sep-split/",
      "whyBad": "The `pathlib` module in the standard library should be used for path\nmanipulation. It provides a high-level API with the functionality\nneeded for common operations on `Path` objects.",
      "example": "If not all parts of the path are needed, then the `name` and `parent`\nattributes of the `Path` object should be used. Otherwise, the `parts`\nattribute can be used as shown in the last example.\n```python\nimport os\n\n\"path/to/file_name.txt\".split(os.sep)[-1]\n\n\"path/to/file_name.txt\".split(os.sep)[-2]\n\n# Iterating over the path parts\nif any(part in blocklist for part in \"my/file/path\".split(os.sep)):\n    ...\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nPath(\"path/to/file_name.txt\").name\n\nPath(\"path/to/file_name.txt\").parent.name\n\n# Iterating over the path parts\nif any(part in blocklist for part in Path(\"my/file/path\").parts):\n    ...\n```"
    },
    {
      "code": "PTH207",
      "name": "glob",
      "summary": "Checks for the use of `glob.glob()` and `glob.iglob()`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/glob/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os` and `glob`.\n\nWhen possible, using `Path` object methods such as `Path.glob()` can\nimprove readability over their low-level counterparts (e.g.,\n`glob.glob()`).\n\nNote that `glob.glob()` and `Path.glob()` are not exact equivalents:\n\n|                   | `glob`-module functions                                                                                                                              | `Path.glob()`                                                                                                                                |\n|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| Hidden files      | Hidden files are excluded by default. On Python 3.11+, the `include_hidden` keyword can be used to include hidden directories.                       | Includes hidden files by default.                                                                                                            |\n| Eagerness         | `glob.iglob()` returns a lazy iterator. Under the hood, `glob.glob()` simply converts the iterator to a list.                                        | `Path.glob()` returns a lazy iterator.                                                                                                       |\n| Working directory | `glob.glob()` and `glob.iglob()` take a `root_dir` keyword to set the current working directory.                                                     | `Path.rglob()` can be used to return the relative path.                                                                                      |\n| Globstar (`**`)   | The `recursive` flag must be set to `True` for the `**` pattern to match any files and zero or more directories, subdirectories, and symbolic links. | The `**` pattern in `Path.glob()` means \"this directory and all subdirectories, recursively\". In other words, it enables recursive globbing. |",
      "example": "```python\nimport glob\nimport os\n\nglob.glob(os.path.join(\"my_path\", \"requirements*.txt\"))\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nPath(\"my_path\").glob(\"requirements*.txt\")\n```"
    },
    {
      "code": "PTH208",
      "name": "os-listdir",
      "summary": "Checks for uses of `os.listdir`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-listdir/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os`. When possible, using `pathlib`'s\n`Path.iterdir()` can improve readability over `os.listdir()`.",
      "example": "```python\np = \".\"\nfor d in os.listdir(p):\n    ...\n\nif os.listdir(p):\n    ...\n\nif \"file\" in os.listdir(p):\n    ...\n```\n\nUse instead:\n\n```python\np = Path(\".\")\nfor d in p.iterdir():\n    ...\n\nif any(p.iterdir()):\n    ...\n\nif (p / \"file\").exists():\n    ...\n```"
    },
    {
      "code": "PTH210",
      "name": "invalid-pathlib-with-suffix",
      "summary": "Checks for `pathlib.Path.with_suffix()` calls where\nthe given suffix does not have a leading dot\nor the given suffix is a single dot `\".\"` and the\nPython version is less than 3.14.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-pathlib-with-suffix/",
      "whyBad": "`Path.with_suffix()` will raise an error at runtime\nif the given suffix is not prefixed with a dot\nor, in versions prior to Python 3.14, if it is a single dot `\".\"`.",
      "example": "```python\nfrom pathlib import Path\n\npath = Path()\n\npath.with_suffix(\"py\")\n```\n\nUse instead:\n\n```python\nfrom pathlib import Path\n\npath = Path()\n\npath.with_suffix(\".py\")\n```"
    },
    {
      "code": "PTH211",
      "name": "os-symlink",
      "summary": "Checks for uses of `os.symlink`.",
      "category": "flake8-use-pathlib",
      "categoryCode": "PTH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-symlink/",
      "whyBad": "`pathlib` offers a high-level API for path manipulation, as compared to\nthe lower-level API offered by `os.symlink`.",
      "example": "```python\nimport os\n\nos.symlink(\"usr/bin/python\", \"tmp/python\", target_is_directory=False)\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nPath(\"tmp/python\").symlink_to(\"usr/bin/python\")\n```"
    },
    {
      "code": "FLY002",
      "name": "static-join-to-f-string",
      "summary": "Checks for `str.join` calls that can be replaced with f-strings.",
      "category": "flynt",
      "categoryCode": "FLY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/static-join-to-f-string/",
      "whyBad": "f-strings are more readable and generally preferred over `str.join` calls.",
      "example": "```python\n\" \".join((foo, bar))\n```\n\nUse instead:\n```python\nf\"{foo} {bar}\"\n```"
    },
    {
      "code": "I001",
      "name": "unsorted-imports",
      "summary": "De-duplicates, groups, and sorts imports based on the provided `isort` settings.",
      "category": "isort",
      "categoryCode": "I",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unsorted-imports/",
      "whyBad": "Consistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.",
      "example": "```python\nimport pandas\nimport numpy as np\n```\n\nUse instead:\n```python\nimport numpy as np\nimport pandas\n```"
    },
    {
      "code": "I002",
      "name": "missing-required-import",
      "summary": "Adds any required imports, as specified by the user, to the top of the\nfile.",
      "category": "isort",
      "categoryCode": "I",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-required-import/",
      "whyBad": "In some projects, certain imports are required to be present in all\nfiles. For example, some projects assume that\n`from __future__ import annotations` is enabled,\nand thus require that import to be\npresent in all files. Omitting a \"required\" import (as specified by\nthe user) can cause errors or unexpected behavior.",
      "example": "```python\nimport typing\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nimport typing\n```"
    },
    {
      "code": "C901",
      "name": "complex-structure",
      "summary": "Checks for functions with a high `McCabe` complexity.",
      "category": "mccabe",
      "categoryCode": "C",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/complex-structure/",
      "whyBad": "The `McCabe` complexity of a function is a measure of the complexity of\nthe control flow graph of the function. It is calculated by adding\none to the number of decision points in the function. A decision\npoint is a place in the code where the program has a choice of two\nor more paths to follow.\n\nFunctions with a high complexity are hard to understand and maintain.",
      "example": "```python\ndef foo(a, b, c):\n    if a:\n        if b:\n            if c:\n                return 1\n            else:\n                return 2\n        else:\n            return 3\n    else:\n        return 4\n```\n\nUse instead:\n```python\ndef foo(a, b, c):\n    if not a:\n        return 4\n    if not b:\n        return 3\n    if not c:\n        return 2\n    return 1\n```"
    },
    {
      "code": "NPY001",
      "name": "numpy-deprecated-type-alias",
      "summary": "Checks for deprecated NumPy type aliases.",
      "category": "NumPy-specific rules",
      "categoryCode": "NPY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/numpy-deprecated-type-alias/",
      "whyBad": "NumPy's `np.int` has long been an alias of the builtin `int`; the same\nis true of `np.float` and others. These aliases exist primarily\nfor historic reasons, and have been a cause of frequent confusion\nfor newcomers.\n\nThese aliases were deprecated in 1.20, and removed in 1.24.\nNote, however, that `np.bool` and `np.long` were reintroduced in 2.0 with\ndifferent semantics, and are thus omitted from this rule.",
      "example": "```python\nimport numpy as np\n\nnp.int\n```\n\nUse instead:\n```python\nint\n```"
    },
    {
      "code": "NPY002",
      "name": "numpy-legacy-random",
      "summary": "Checks for the use of legacy `np.random` function calls.",
      "category": "NumPy-specific rules",
      "categoryCode": "NPY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/numpy-legacy-random/",
      "whyBad": "According to the NumPy documentation's [Legacy Random Generation]:\n\n> The `RandomState` provides access to legacy generators... This class\n> should only be used if it is essential to have randoms that are\n> identical to what would have been produced by previous versions of\n> NumPy.\n\nThe members exposed directly on the `random` module are convenience\nfunctions that alias to methods on a global singleton `RandomState`\ninstance. NumPy recommends using a dedicated `Generator` instance\nrather than the random variate generation methods exposed directly on\nthe `random` module, as the new `Generator` is both faster and has\nbetter statistical properties.\n\nSee the documentation on [Random Sampling] and [NEP 19] for further\ndetails.",
      "example": "```python\nimport numpy as np\n\nnp.random.seed(1337)\nnp.random.normal()\n```\n\nUse instead:\n```python\nrng = np.random.default_rng(1337)\nrng.normal()\n```\n\n[Legacy Random Generation]: https://numpy.org/doc/stable/reference/random/legacy.html#legacy\n[Random Sampling]: https://numpy.org/doc/stable/reference/random/index.html#random-quick-start\n[NEP 19]: https://numpy.org/neps/nep-0019-rng-policy.html"
    },
    {
      "code": "NPY003",
      "name": "numpy-deprecated-function",
      "summary": "Checks for uses of deprecated NumPy functions.",
      "category": "NumPy-specific rules",
      "categoryCode": "NPY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/numpy-deprecated-function/",
      "whyBad": "When NumPy functions are deprecated, they are usually replaced with\nnewer, more efficient versions, or with functions that are more\nconsistent with the rest of the NumPy API.\n\nPrefer newer APIs over deprecated ones.",
      "example": "```python\nimport numpy as np\n\nnp.alltrue([True, False])\n```\n\nUse instead:\n```python\nimport numpy as np\n\nnp.all([True, False])\n```"
    },
    {
      "code": "NPY201",
      "name": "numpy2-deprecation",
      "summary": "Checks for uses of NumPy functions and constants that were removed from\nthe main namespace in NumPy 2.0.",
      "category": "NumPy-specific rules",
      "categoryCode": "NPY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/numpy2-deprecation/",
      "whyBad": "NumPy 2.0 includes an overhaul of NumPy's Python API, intended to remove\nredundant aliases and routines, and establish unambiguous mechanisms for\naccessing constants, dtypes, and functions.\n\nAs part of this overhaul, a variety of deprecated NumPy functions and\nconstants were removed from the main namespace.\n\nThe majority of these functions and constants can be automatically replaced\nby other members of the NumPy API or by equivalents from the Python\nstandard library. With the exception of renaming `numpy.byte_bounds` to\n`numpy.lib.array_utils.byte_bounds`, all such replacements are backwards\ncompatible with earlier versions of NumPy.\n\nThis rule flags all uses of removed members, along with automatic fixes for\nany backwards-compatible replacements.",
      "example": "```python\nimport numpy as np\n\narr1 = [np.Infinity, np.NaN, np.nan, np.PINF, np.inf]\narr2 = [np.float_(1.5), np.float64(5.1)]\nnp.round_(arr2)\n```\n\nUse instead:\n```python\nimport numpy as np\n\narr1 = [np.inf, np.nan, np.nan, np.inf, np.inf]\narr2 = [np.float64(1.5), np.float64(5.1)]\nnp.round(arr2)\n```"
    },
    {
      "code": "N801",
      "name": "invalid-class-name",
      "summary": "Checks for class names that do not follow the `CamelCase` convention.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-class-name/",
      "whyBad": "[PEP 8] recommends the use of the `CapWords` (or `CamelCase`) convention\nfor class names:\n\n> Class names should normally use the `CapWords` convention.\n>\n> The naming convention for functions may be used instead in cases where the interface is\n> documented and used primarily as a callable.\n>\n> Note that there is a separate convention for builtin names: most builtin names are single\n> words (or two words run together), with the `CapWords` convention used only for exception\n> names and builtin constants.",
      "example": "```python\nclass my_class:\n    pass\n```\n\nUse instead:\n```python\nclass MyClass:\n    pass\n```"
    },
    {
      "code": "N802",
      "name": "invalid-function-name",
      "summary": "Checks for functions names that do not follow the `snake_case` naming\nconvention.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-function-name/",
      "whyBad": "[PEP 8] recommends that function names follow `snake_case`:\n\n> Function names should be lowercase, with words separated by underscores as necessary to\n> improve readability. mixedCase is allowed only in contexts where thats already the\n> prevailing style (e.g. threading.py), to retain backwards compatibility.\n\nNames can be excluded from this rule using the [`lint.pep8-naming.ignore-names`]\nor [`lint.pep8-naming.extend-ignore-names`] configuration options. For example,\nto ignore all functions starting with `test_` from this rule, set the\n[`lint.pep8-naming.extend-ignore-names`] option to `[\"test_*\"]`.\n\nThis rule exempts methods decorated with [`@typing.override`][override].\nExplicitly decorating a method with `@override` signals to Ruff that the method is intended\nto override a superclass method, and that a type checker will enforce that it does so. Ruff\ntherefore knows that it should not enforce naming conventions on such methods.",
      "example": "```python\ndef myFunction():\n    pass\n```\n\nUse instead:\n```python\ndef my_function():\n    pass\n```"
    },
    {
      "code": "N803",
      "name": "invalid-argument-name",
      "summary": "Checks for argument names that do not follow the `snake_case` convention.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-argument-name/",
      "whyBad": "[PEP 8] recommends that function names should be lower case and separated\nby underscores (also known as `snake_case`).\n\n> Function names should be lowercase, with words separated by underscores\n> as necessary to improve readability.\n>\n> Variable names follow the same convention as function names.\n>\n> mixedCase is allowed only in contexts where thats already the\n> prevailing style (e.g. threading.py), to retain backwards compatibility.\n\nMethods decorated with [`@typing.override`][override] are ignored.",
      "example": "```python\ndef my_function(A, myArg):\n    pass\n```\n\nUse instead:\n```python\ndef my_function(a, my_arg):\n    pass\n```"
    },
    {
      "code": "N804",
      "name": "invalid-first-argument-name-for-class-method",
      "summary": "Checks for class methods that use a name other than `cls` for their\nfirst argument.\n\nThe method `__new__` is exempted from this\ncheck and the corresponding violation is caught by\n[`bad-staticmethod-argument`][PLW0211].",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-first-argument-name-for-class-method/",
      "whyBad": "[PEP 8] recommends the use of `cls` as the first argument for all class\nmethods:\n\n> Always use `cls` for the first argument to class methods.\n>\n> If a function arguments name clashes with a reserved keyword, it is generally better to\n> append a single trailing underscore rather than use an abbreviation or spelling corruption.\n> Thus `class_` is better than `clss`. (Perhaps better is to avoid such clashes by using a synonym.)\n\nNames can be excluded from this rule using the [`lint.pep8-naming.ignore-names`]\nor [`lint.pep8-naming.extend-ignore-names`] configuration options. For example,\nto allow the use of `klass` as the first argument to class methods, set\nthe [`lint.pep8-naming.extend-ignore-names`] option to `[\"klass\"]`.",
      "example": "```python\nclass Example:\n    @classmethod\n    def function(self, data): ...\n```\n\nUse instead:\n\n```python\nclass Example:\n    @classmethod\n    def function(cls, data): ...\n```"
    },
    {
      "code": "N805",
      "name": "invalid-first-argument-name-for-method",
      "summary": "Checks for instance methods that use a name other than `self` for their\nfirst argument.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-first-argument-name-for-method/",
      "whyBad": "[PEP 8] recommends the use of `self` as first argument for all instance\nmethods:\n\n> Always use self for the first argument to instance methods.\n>\n> If a function arguments name clashes with a reserved keyword, it is generally better to\n> append a single trailing underscore rather than use an abbreviation or spelling corruption.\n> Thus `class_` is better than `clss`. (Perhaps better is to avoid such clashes by using a synonym.)\n\nNames can be excluded from this rule using the [`lint.pep8-naming.ignore-names`]\nor [`lint.pep8-naming.extend-ignore-names`] configuration options. For example,\nto allow the use of `this` as the first argument to instance methods, set\nthe [`lint.pep8-naming.extend-ignore-names`] option to `[\"this\"]`.",
      "example": "```python\nclass Example:\n    def function(cls, data): ...\n```\n\nUse instead:\n\n```python\nclass Example:\n    def function(self, data): ...\n```"
    },
    {
      "code": "N806",
      "name": "non-lowercase-variable-in-function",
      "summary": "Checks for the use of non-lowercase variable names in functions.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-lowercase-variable-in-function/",
      "whyBad": "[PEP 8] recommends that all function variables use lowercase names:\n\n> Function names should be lowercase, with words separated by underscores as necessary to\n> improve readability. Variable names follow the same convention as function names. mixedCase\n> is allowed only in contexts where that's already the prevailing style (e.g. threading.py),\n> to retain backwards compatibility.",
      "example": "```python\ndef my_function(a):\n    B = a + 3\n    return B\n```\n\nUse instead:\n```python\ndef my_function(a):\n    b = a + 3\n    return b\n```"
    },
    {
      "code": "N807",
      "name": "dunder-function-name",
      "summary": "Checks for functions with \"dunder\" names (that is, names with two\nleading and trailing underscores) that are not documented.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/dunder-function-name/",
      "whyBad": "[PEP 8] recommends that only documented \"dunder\" methods are used:\n\n> ...\"magic\" objects or attributes that live in user-controlled\n> namespaces. E.g. `__init__`, `__import__` or `__file__`. Never invent\n> such names; only use them as documented.",
      "example": "```python\ndef __my_function__():\n    pass\n```\n\nUse instead:\n```python\ndef my_function():\n    pass\n```"
    },
    {
      "code": "N811",
      "name": "constant-imported-as-non-constant",
      "summary": "Checks for constant imports that are aliased to non-constant-style\nnames.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/constant-imported-as-non-constant/",
      "whyBad": "[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.",
      "example": "```python\nfrom example import CONSTANT_VALUE as ConstantValue\n```\n\nUse instead:\n```python\nfrom example import CONSTANT_VALUE\n```"
    },
    {
      "code": "N812",
      "name": "lowercase-imported-as-non-lowercase",
      "summary": "Checks for lowercase imports that are aliased to non-lowercase names.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/lowercase-imported-as-non-lowercase/",
      "whyBad": "[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.",
      "example": "```python\nfrom example import myclassname as MyClassName\n```\n\nUse instead:\n```python\nfrom example import myclassname\n```"
    },
    {
      "code": "N813",
      "name": "camelcase-imported-as-lowercase",
      "summary": "Checks for `CamelCase` imports that are aliased to lowercase names.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/camelcase-imported-as-lowercase/",
      "whyBad": "[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.",
      "example": "```python\nfrom example import MyClassName as myclassname\n```\n\nUse instead:\n```python\nfrom example import MyClassName\n```"
    },
    {
      "code": "N814",
      "name": "camelcase-imported-as-constant",
      "summary": "Checks for `CamelCase` imports that are aliased to constant-style names.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/camelcase-imported-as-constant/",
      "whyBad": "[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.",
      "example": "```python\nfrom example import MyClassName as MY_CLASS_NAME\n```\n\nUse instead:\n```python\nfrom example import MyClassName\n```"
    },
    {
      "code": "N815",
      "name": "mixed-case-variable-in-class-scope",
      "summary": "Checks for class variable names that follow the `mixedCase` convention.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mixed-case-variable-in-class-scope/",
      "whyBad": "[PEP 8] recommends that variable names should be lower case and separated\nby underscores (also known as `snake_case`).\n\n> Function names should be lowercase, with words separated by underscores\n> as necessary to improve readability.\n>\n> Variable names follow the same convention as function names.\n>\n> mixedCase is allowed only in contexts where thats already the\n> prevailing style (e.g. threading.py), to retain backwards compatibility.",
      "example": "```python\nclass MyClass:\n    myVariable = \"hello\"\n    another_variable = \"world\"\n```\n\nUse instead:\n```python\nclass MyClass:\n    my_variable = \"hello\"\n    another_variable = \"world\"\n```"
    },
    {
      "code": "N816",
      "name": "mixed-case-variable-in-global-scope",
      "summary": "Checks for global variable names that follow the `mixedCase` convention.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mixed-case-variable-in-global-scope/",
      "whyBad": "[PEP 8] recommends that global variable names should be lower case and\nseparated by underscores (also known as `snake_case`).\n\n> ### Global Variable Names\n> (Lets hope that these variables are meant for use inside one module\n> only.) The conventions are about the same as those for functions.\n>\n> Modules that are designed for use via `from M import *` should use the\n> `__all__` mechanism to prevent exporting globals, or use the older\n> convention of prefixing such globals with an underscore (which you might\n> want to do to indicate these globals are module non-public).\n>\n> ### Function and Variable Names\n> Function names should be lowercase, with words separated by underscores\n> as necessary to improve readability.\n>\n> Variable names follow the same convention as function names.\n>\n> mixedCase is allowed only in contexts where thats already the prevailing\n> style (e.g. threading.py), to retain backwards compatibility.",
      "example": "```python\nmyVariable = \"hello\"\nanother_variable = \"world\"\nyet_anotherVariable = \"foo\"\n```\n\nUse instead:\n```python\nmy_variable = \"hello\"\nanother_variable = \"world\"\nyet_another_variable = \"foo\"\n```"
    },
    {
      "code": "N817",
      "name": "camelcase-imported-as-acronym",
      "summary": "Checks for `CamelCase` imports that are aliased as acronyms.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/camelcase-imported-as-acronym/",
      "whyBad": "[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nNote that this rule is distinct from `camelcase-imported-as-constant`\nto accommodate selective enforcement.\n\nAlso note that import aliases following an import convention according to the\n[`lint.flake8-import-conventions.aliases`] option are allowed.",
      "example": "```python\nfrom example import MyClassName as MCN\n```\n\nUse instead:\n```python\nfrom example import MyClassName\n```"
    },
    {
      "code": "N818",
      "name": "error-suffix-on-exception-name",
      "summary": "Checks for custom exception definitions that omit the `Error` suffix.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/error-suffix-on-exception-name/",
      "whyBad": "The `Error` suffix is recommended by [PEP 8]:\n\n> Because exceptions should be classes, the class naming convention\n> applies here. However, you should use the suffix `\"Error\"` on your\n> exception names (if the exception actually is an error).",
      "example": "```python\nclass Validation(Exception): ...\n```\n\nUse instead:\n\n```python\nclass ValidationError(Exception): ...\n```"
    },
    {
      "code": "N999",
      "name": "invalid-module-name",
      "summary": "Checks for module names that do not follow the `snake_case` naming\nconvention or are otherwise invalid.",
      "category": "pep8-naming",
      "categoryCode": "N",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-module-name/",
      "whyBad": "[PEP 8] recommends the use of the `snake_case` naming convention for\nmodule names:\n\n> Modules should have short, all-lowercase names. Underscores can be used in the\n> module name if it improves readability. Python packages should also have short,\n> all-lowercase names, although the use of underscores is discouraged.\n>\n> When an extension module written in C or C++ has an accompanying Python module that\n> provides a higher level (e.g. more object-oriented) interface, the C/C++ module has\n> a leading underscore (e.g. `_socket`).\n\nFurther, in order for Python modules to be importable, they must be valid\nidentifiers. As such, they cannot start with a digit, or collide with hard\nkeywords, like `import` or `class`.",
      "example": "- Instead of `example-module-name` or `example module name`, use `example_module_name`.\n- Instead of `ExampleModule`, use `example_module`.\n\n[PEP 8]: https://peps.python.org/pep-0008/#package-and-module-names"
    },
    {
      "code": "PD002",
      "name": "pandas-use-of-inplace-argument",
      "summary": "Checks for `inplace=True` usages in `pandas` function and method\ncalls.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-inplace-argument/",
      "whyBad": "Using `inplace=True` encourages mutation rather than immutable data,\nwhich is harder to reason about and may cause bugs. It also removes the\nability to use the method chaining style for `pandas` operations.\n\nFurther, in many cases, `inplace=True` does not provide a performance\nbenefit, as `pandas` will often copy `DataFrames` in the background.",
      "example": "```python\ndf.sort_values(\"col1\", inplace=True)\n```\n\nUse instead:\n```python\nsorted_df = df.sort_values(\"col1\")\n```"
    },
    {
      "code": "PD003",
      "name": "pandas-use-of-dot-is-null",
      "summary": "Checks for uses of `.isnull` on Pandas objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-is-null/",
      "whyBad": "In the Pandas API, `.isna` and `.isnull` are equivalent. For consistency,\nprefer `.isna` over `.isnull`.\n\nAs a name, `.isna` more accurately reflects the behavior of the method,\nsince these methods check for `NaN` and `NaT` values in addition to `None`\nvalues.",
      "example": "```python\nimport pandas as pd\n\nanimals_df = pd.read_csv(\"animals.csv\")\npd.isnull(animals_df)\n```\n\nUse instead:\n```python\nimport pandas as pd\n\nanimals_df = pd.read_csv(\"animals.csv\")\npd.isna(animals_df)\n```"
    },
    {
      "code": "PD004",
      "name": "pandas-use-of-dot-not-null",
      "summary": "Checks for uses of `.notnull` on Pandas objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-not-null/",
      "whyBad": "In the Pandas API, `.notna` and `.notnull` are equivalent. For consistency,\nprefer `.notna` over `.notnull`.\n\nAs a name, `.notna` more accurately reflects the behavior of the method,\nsince these methods check for `NaN` and `NaT` values in addition to `None`\nvalues.",
      "example": "```python\nimport pandas as pd\n\nanimals_df = pd.read_csv(\"animals.csv\")\npd.notnull(animals_df)\n```\n\nUse instead:\n```python\nimport pandas as pd\n\nanimals_df = pd.read_csv(\"animals.csv\")\npd.notna(animals_df)\n```"
    },
    {
      "code": "PD007",
      "name": "pandas-use-of-dot-ix",
      "summary": "Checks for uses of `.ix` on Pandas objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-ix/",
      "whyBad": "The `.ix` method is deprecated as its behavior is ambiguous. Specifically,\nit's often unclear whether `.ix` is indexing by label or by ordinal position.\n\nInstead, prefer the `.loc` method for label-based indexing, and `.iloc` for\nordinal indexing.",
      "example": "```python\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.ix[0]  # 0th row or row with label 0?\n```\n\nUse instead:\n```python\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.iloc[0]  # 0th row.\n```"
    },
    {
      "code": "PD008",
      "name": "pandas-use-of-dot-at",
      "summary": "Checks for uses of `.at` on Pandas objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-at/",
      "whyBad": "The `.at` method selects a single value from a `DataFrame` or Series based on\na label index, and is slightly faster than using `.loc`. However, `.loc` is\nmore idiomatic and versatile, as it can be used to select multiple values at\nonce.\n\nIf performance is an important consideration, convert the object to a NumPy\narray, which will provide a much greater performance boost than using `.at`\nover `.loc`.",
      "example": "```python\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.at[\"Maria\"]\n```\n\nUse instead:\n```python\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.loc[\"Maria\"]\n```"
    },
    {
      "code": "PD009",
      "name": "pandas-use-of-dot-iat",
      "summary": "Checks for uses of `.iat` on Pandas objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-iat/",
      "whyBad": "The `.iat` method selects a single value from a `DataFrame` or Series based\non an ordinal index, and is slightly faster than using `.iloc`. However,\n`.iloc` is more idiomatic and versatile, as it can be used to select\nmultiple values at once.\n\nIf performance is an important consideration, convert the object to a NumPy\narray, which will provide a much greater performance boost than using `.iat`\nover `.iloc`.",
      "example": "```python\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.iat[0]\n```\n\nUse instead:\n```python\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.iloc[0]\n```\n\nOr, using NumPy:\n```python\nimport numpy as np\nimport pandas as pd\n\nstudents_df = pd.read_csv(\"students.csv\")\nstudents_df.to_numpy()[0]\n```"
    },
    {
      "code": "PD010",
      "name": "pandas-use-of-dot-pivot-or-unstack",
      "summary": "Checks for uses of `.pivot` or `.unstack` on Pandas objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-pivot-or-unstack/",
      "whyBad": "Prefer `.pivot_table` to `.pivot` or `.unstack`. `.pivot_table` is more general\nand can be used to implement the same behavior as `.pivot` and `.unstack`.",
      "example": "```python\nimport pandas as pd\n\ndf = pd.read_csv(\"cities.csv\")\ndf.pivot(index=\"city\", columns=\"year\", values=\"population\")\n```\n\nUse instead:\n```python\nimport pandas as pd\n\ndf = pd.read_csv(\"cities.csv\")\ndf.pivot_table(index=\"city\", columns=\"year\", values=\"population\")\n```"
    },
    {
      "code": "PD011",
      "name": "pandas-use-of-dot-values",
      "summary": "Checks for uses of `.values` on Pandas Series and Index objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-values/",
      "whyBad": "The `.values` attribute is ambiguous as its return type is unclear. As\nsuch, it is no longer recommended by the Pandas documentation.\n\nInstead, use `.to_numpy()` to return a NumPy array, or `.array` to return a\nPandas `ExtensionArray`.",
      "example": "```python\nimport pandas as pd\n\nanimals = pd.read_csv(\"animals.csv\").values  # Ambiguous.\n```\n\nUse instead:\n```python\nimport pandas as pd\n\nanimals = pd.read_csv(\"animals.csv\").to_numpy()  # Explicit.\n```"
    },
    {
      "code": "PD012",
      "name": "pandas-use-of-dot-read-table",
      "summary": "Checks for uses of `pd.read_table` to read CSV files.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-read-table/",
      "whyBad": "In the Pandas API, `pd.read_csv` and `pd.read_table` are equivalent apart\nfrom their default separator: `pd.read_csv` defaults to a comma (`,`),\nwhile `pd.read_table` defaults to a tab (`\\t`) as the default separator.\n\nPrefer `pd.read_csv` over `pd.read_table` when reading comma-separated\ndata (like CSV files), as it is more idiomatic.",
      "example": "```python\nimport pandas as pd\n\ncities_df = pd.read_table(\"cities.csv\", sep=\",\")\n```\n\nUse instead:\n```python\nimport pandas as pd\n\ncities_df = pd.read_csv(\"cities.csv\")\n```"
    },
    {
      "code": "PD013",
      "name": "pandas-use-of-dot-stack",
      "summary": "Checks for uses of `.stack` on Pandas objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-dot-stack/",
      "whyBad": "Prefer `.melt` to `.stack`, which has the same functionality but with\nsupport for direct column renaming and no dependence on `MultiIndex`.",
      "example": "```python\nimport pandas as pd\n\ncities_df = pd.read_csv(\"cities.csv\")\ncities_df.set_index(\"city\").stack()\n```\n\nUse instead:\n```python\nimport pandas as pd\n\ncities_df = pd.read_csv(\"cities.csv\")\ncities_df.melt(id_vars=\"city\")\n```"
    },
    {
      "code": "PD015",
      "name": "pandas-use-of-pd-merge",
      "summary": "Checks for uses of `pd.merge` on Pandas objects.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-use-of-pd-merge/",
      "whyBad": "In Pandas, the `.merge` method (exposed on, e.g., `DataFrame` objects) and\nthe `pd.merge` function (exposed on the Pandas module) are equivalent.\n\nFor consistency, prefer calling `.merge` on an object over calling\n`pd.merge` on the Pandas module, as the former is more idiomatic.\n\nFurther, `pd.merge` is not a method, but a function, which prohibits it\nfrom being used in method chains, a common pattern in Pandas code.",
      "example": "```python\nimport pandas as pd\n\ncats_df = pd.read_csv(\"cats.csv\")\ndogs_df = pd.read_csv(\"dogs.csv\")\nrabbits_df = pd.read_csv(\"rabbits.csv\")\npets_df = pd.merge(pd.merge(cats_df, dogs_df), rabbits_df)  # Hard to read.\n```\n\nUse instead:\n```python\nimport pandas as pd\n\ncats_df = pd.read_csv(\"cats.csv\")\ndogs_df = pd.read_csv(\"dogs.csv\")\nrabbits_df = pd.read_csv(\"rabbits.csv\")\npets_df = cats_df.merge(dogs_df).merge(rabbits_df)\n```"
    },
    {
      "code": "PD101",
      "name": "pandas-nunique-constant-series-check",
      "summary": "Check for uses of `.nunique()` to check if a Pandas Series is constant\n(i.e., contains only one unique value).",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-nunique-constant-series-check/",
      "whyBad": "`.nunique()` is computationally inefficient for checking if a Series is\nconstant.\n\nConsider, for example, a Series of length `n` that consists of increasing\ninteger values (e.g., 1, 2, 3, 4). The `.nunique()` method will iterate\nover the entire Series to count the number of unique values. But in this\ncase, we can detect that the Series is non-constant after visiting the\nfirst two values, which are non-equal.\n\nIn general, `.nunique()` requires iterating over the entire Series, while a\nmore efficient approach allows short-circuiting the operation as soon as a\nnon-equal value is found.\n\nInstead of calling `.nunique()`, convert the Series to a NumPy array, and\ncheck if all values in the array are equal to the first observed value.",
      "example": "```python\nimport pandas as pd\n\ndata = pd.Series(range(1000))\nif data.nunique() <= 1:\n    print(\"Series is constant\")\n```\n\nUse instead:\n```python\nimport pandas as pd\n\ndata = pd.Series(range(1000))\narray = data.to_numpy()\nif array.shape[0] == 0 or (array[0] == array).all():\n    print(\"Series is constant\")\n```"
    },
    {
      "code": "PD901",
      "name": "pandas-df-variable-name",
      "summary": "Checks for assignments to the variable `df`.",
      "category": "pandas-vet",
      "categoryCode": "PD",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pandas-df-variable-name/",
      "whyBad": "Although `df` is a common variable name for a Pandas `DataFrame`, it's not a\ngreat variable name for production code, as it's non-descriptive and\nprone to name conflicts.\n\nInstead, use a more descriptive variable name.",
      "example": "```python\nimport pandas as pd\n\ndf = pd.read_csv(\"animals.csv\")\n```\n\nUse instead:\n```python\nimport pandas as pd\n\nanimals = pd.read_csv(\"animals.csv\")\n```"
    },
    {
      "code": "PERF101",
      "name": "unnecessary-list-cast",
      "summary": "Checks for explicit casts to `list` on for-loop iterables.",
      "category": "Perflint",
      "categoryCode": "PERF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-list-cast/",
      "whyBad": "Using a `list()` call to eagerly iterate over an already-iterable type\n(like a tuple, list, or set) is inefficient, as it forces Python to create\na new list unnecessarily.\n\nRemoving the `list()` call will not change the behavior of the code, but\nmay improve performance.\n\nNote that, as with all `perflint` rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.",
      "example": "```python\nitems = (1, 2, 3)\nfor i in list(items):\n    print(i)\n```\n\nUse instead:\n```python\nitems = (1, 2, 3)\nfor i in items:\n    print(i)\n```"
    },
    {
      "code": "PERF102",
      "name": "incorrect-dict-iterator",
      "summary": "Checks for uses of `dict.items()` that discard either the key or the value\nwhen iterating over the dictionary.",
      "category": "Perflint",
      "categoryCode": "PERF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/incorrect-dict-iterator/",
      "whyBad": "If you only need the keys or values of a dictionary, you should use\n`dict.keys()` or `dict.values()` respectively, instead of `dict.items()`.\nThese specialized methods are more efficient than `dict.items()`, as they\navoid allocating tuples for every item in the dictionary. They also\ncommunicate the intent of the code more clearly.\n\nNote that, as with all `perflint` rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.",
      "example": "```python\nobj = {\"a\": 1, \"b\": 2}\nfor key, value in obj.items():\n    print(value)\n```\n\nUse instead:\n```python\nobj = {\"a\": 1, \"b\": 2}\nfor value in obj.values():\n    print(value)\n```"
    },
    {
      "code": "PERF203",
      "name": "try-except-in-loop",
      "summary": "Checks for uses of except handling via `try`-`except` within `for` and\n`while` loops.",
      "category": "Perflint",
      "categoryCode": "PERF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/try-except-in-loop/",
      "whyBad": "Exception handling via `try`-`except` blocks incurs some performance\noverhead, regardless of whether an exception is raised.\n\nTo optimize your code, two techniques are possible:\n1. Refactor your code to put the entire loop into the `try`-`except` block,\n   rather than wrapping each iteration in a separate `try`-`except` block.\n2. Use \"Look Before You Leap\" idioms that attempt to avoid exceptions\n   being raised in the first place, avoiding the need to use `try`-`except`\n   blocks in the first place.\n\nThis rule is only enforced for Python versions prior to 3.11, which\nintroduced \"zero-cost\" exception handling. However, note that even on\nPython 3.11 and newer, refactoring your code to avoid exception handling in\ntight loops can provide a significant speedup in some cases, as zero-cost\nexception handling is only zero-cost in the \"happy path\" where no exception\nis raised in the `try`-`except` block.\n\nAs with all `perflint` rules, this is only intended as a\nmicro-optimization. In many cases, it will have a negligible impact on\nperformance.",
      "example": "```python\nstring_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"]\n\n# `try`/`except` that could be moved out of the loop:\nint_numbers: list[int] = []\nfor num in string_numbers:\n    try:\n        int_numbers.append(int(num))\n    except ValueError as e:\n        print(f\"Couldn't convert to integer: {e}\")\n        break\n\n# `try`/`except` used when \"look before you leap\" idioms could be used:\nnumber_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"}\nfor number in range(5):\n    try:\n        name = number_names[number]\n    except KeyError:\n        continue\n    else:\n        print(f\"The name of {number} is {name}\")\n```\n\nUse instead:\n```python\nstring_numbers: list[str] = [\"1\", \"2\", \"three\", \"4\", \"5\"]\n\nint_numbers: list[int] = []\ntry:\n    for num in string_numbers:\n        int_numbers.append(int(num))\nexcept ValueError as e:\n    print(f\"Couldn't convert to integer: {e}\")\n\nnumber_names: dict[int, str] = {1: \"one\", 3: \"three\", 4: \"four\"}\nfor number in range(5):\n    name = number_names.get(number)\n    if name is not None:\n        print(f\"The name of {number} is {name}\")\n```"
    },
    {
      "code": "PERF401",
      "name": "manual-list-comprehension",
      "summary": "Checks for `for` loops that can be replaced by a list comprehension.",
      "category": "Perflint",
      "categoryCode": "PERF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/manual-list-comprehension/",
      "whyBad": "When creating a transformed list from an existing list using a for-loop,\nprefer a list comprehension. List comprehensions are more readable and\nmore performant.\n\nUsing the below as an example, the list comprehension is ~10% faster on\nPython 3.11, and ~25% faster on Python 3.10.\n\nNote that, as with all `perflint` rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.",
      "example": "```python\noriginal = list(range(10000))\nfiltered = []\nfor i in original:\n    if i % 2:\n        filtered.append(i)\n```\n\nUse instead:\n```python\noriginal = list(range(10000))\nfiltered = [x for x in original if x % 2]\n```\n\nIf you're appending to an existing list, use the `extend` method instead:\n```python\noriginal = list(range(10000))\nfiltered.extend(x for x in original if x % 2)\n```"
    },
    {
      "code": "PERF402",
      "name": "manual-list-copy",
      "summary": "Checks for `for` loops that can be replaced by a making a copy of a list.",
      "category": "Perflint",
      "categoryCode": "PERF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/manual-list-copy/",
      "whyBad": "When creating a copy of an existing list using a for-loop, prefer\n`list` or `list.copy` instead. Making a direct copy is more readable and\nmore performant.\n\nUsing the below as an example, the `list`-based copy is ~2x faster on\nPython 3.11.\n\nNote that, as with all `perflint` rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.",
      "example": "```python\noriginal = list(range(10000))\nfiltered = []\nfor i in original:\n    filtered.append(i)\n```\n\nUse instead:\n```python\noriginal = list(range(10000))\nfiltered = list(original)\n```"
    },
    {
      "code": "PERF403",
      "name": "manual-dict-comprehension",
      "summary": "Checks for `for` loops that can be replaced by a dictionary comprehension.",
      "category": "Perflint",
      "categoryCode": "PERF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/manual-dict-comprehension/",
      "whyBad": "When creating or extending a dictionary in a for-loop, prefer a dictionary\ncomprehension. Comprehensions are more readable and more performant.\n\nFor example, when comparing `{x: x for x in list(range(1000))}` to the `for`\nloop version, the comprehension is ~10% faster on Python 3.11.\n\nNote that, as with all `perflint` rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.",
      "example": "```python\npairs = ((\"a\", 1), (\"b\", 2))\nresult = {}\nfor x, y in pairs:\n    if y % 2:\n        result[x] = y\n```\n\nUse instead:\n```python\npairs = ((\"a\", 1), (\"b\", 2))\nresult = {x: y for x, y in pairs if y % 2}\n```\n\nIf you're appending to an existing dictionary, use the `update` method instead:\n```python\npairs = ((\"a\", 1), (\"b\", 2))\nresult.update({x: y for x, y in pairs if y % 2})\n```"
    },
    {
      "code": "E101",
      "name": "mixed-spaces-and-tabs",
      "summary": "Checks for mixed tabs and spaces in indentation.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mixed-spaces-and-tabs/",
      "whyBad": "Never mix tabs and spaces.\n\nThe most popular way of indenting Python is with spaces only. The\nsecond-most popular way is with tabs only. Code indented with a\nmixture of tabs and spaces should be converted to using spaces\nexclusively.",
      "example": "```python\nif a == 0:\\n        a = 1\\n\\tb = 1\n```\n\nUse instead:\n```python\nif a == 0:\\n    a = 1\\n    b = 1\n```"
    },
    {
      "code": "E111",
      "name": "indentation-with-invalid-multiple",
      "summary": "Checks for indentation with a non-multiple of 4 spaces.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/indentation-with-invalid-multiple/",
      "whyBad": "According to [PEP 8], 4 spaces per indentation level should be preferred.",
      "example": "```python\nif True:\n   a = 1\n```\n\nUse instead:\n```python\nif True:\n    a = 1\n```"
    },
    {
      "code": "E112",
      "name": "no-indented-block",
      "summary": "Checks for indented blocks that are lacking indentation.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-indented-block/",
      "whyBad": "All indented blocks should be indented; otherwise, they are not valid\nPython syntax.",
      "example": "```python\nfor item in items:\npass\n```\n\nUse instead:\n```python\nfor item in items:\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation"
    },
    {
      "code": "E113",
      "name": "unexpected-indentation",
      "summary": "Checks for unexpected indentation.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unexpected-indentation/",
      "whyBad": "Indentation outside of a code block is not valid Python syntax.",
      "example": "```python\na = 1\n    b = 2\n```\n\nUse instead:\n```python\na = 1\nb = 2\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation"
    },
    {
      "code": "E114",
      "name": "indentation-with-invalid-multiple-comment",
      "summary": "Checks for indentation of comments with a non-multiple of 4 spaces.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/indentation-with-invalid-multiple-comment/",
      "whyBad": "According to [PEP 8], 4 spaces per indentation level should be preferred.",
      "example": "```python\nif True:\n   # a = 1\n    ...\n```\n\nUse instead:\n```python\nif True:\n    # a = 1\n    ...\n```"
    },
    {
      "code": "E115",
      "name": "no-indented-block-comment",
      "summary": "Checks for comments in a code blocks that are lacking indentation.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-indented-block-comment/",
      "whyBad": "Comments within an indented block should themselves be indented, to\nindicate that they are part of the block.",
      "example": "```python\nfor item in items:\n# Hi\n    pass\n```\n\nUse instead:\n```python\nfor item in items:\n    # Hi\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation"
    },
    {
      "code": "E116",
      "name": "unexpected-indentation-comment",
      "summary": "Checks for unexpected indentation of comment.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unexpected-indentation-comment/",
      "whyBad": "Comments should match the indentation of the containing code block.",
      "example": "```python\na = 1\n    # b = 2\n```\n\nUse instead:\n```python\na = 1"
    },
    {
      "code": "E117",
      "name": "over-indented",
      "summary": "Checks for over-indented code.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/over-indented/",
      "whyBad": "According to [PEP 8], 4 spaces per indentation level should be preferred. Increased\nindentation can lead to inconsistent formatting, which can hurt\nreadability.",
      "example": "```python\nfor item in items:\n      pass\n```\n\nUse instead:\n```python\nfor item in items:\n    pass\n```"
    },
    {
      "code": "E201",
      "name": "whitespace-after-open-bracket",
      "summary": "Checks for the use of extraneous whitespace after \"(\", \"[\" or \"{\".",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/whitespace-after-open-bracket/",
      "whyBad": "[PEP 8] recommends the omission of whitespace in the following cases:\n- \"Immediately inside parentheses, brackets or braces.\"\n- \"Immediately before a comma, semicolon, or colon.\"",
      "example": "```python\nspam( ham[1], {eggs: 2})\nspam(ham[ 1], {eggs: 2})\nspam(ham[1], { eggs: 2})\n```\n\nUse instead:\n```python\nspam(ham[1], {eggs: 2})\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#pet-peeves"
    },
    {
      "code": "E202",
      "name": "whitespace-before-close-bracket",
      "summary": "Checks for the use of extraneous whitespace before \")\", \"]\" or \"}\".",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/whitespace-before-close-bracket/",
      "whyBad": "[PEP 8] recommends the omission of whitespace in the following cases:\n- \"Immediately inside parentheses, brackets or braces.\"\n- \"Immediately before a comma, semicolon, or colon.\"",
      "example": "```python\nspam(ham[1], {eggs: 2} )\nspam(ham[1 ], {eggs: 2})\nspam(ham[1], {eggs: 2 })\n```\n\nUse instead:\n```python\nspam(ham[1], {eggs: 2})\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#pet-peeves"
    },
    {
      "code": "E203",
      "name": "whitespace-before-punctuation",
      "summary": "Checks for the use of extraneous whitespace before \",\", \";\" or \":\".",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/whitespace-before-punctuation/",
      "whyBad": "[PEP 8] recommends the omission of whitespace in the following cases:\n- \"Immediately inside parentheses, brackets or braces.\"\n- \"Immediately before a comma, semicolon, or colon.\"",
      "example": "```python\nif x == 4: print(x, y); x, y = y , x\n```\n\nUse instead:\n```python\nif x == 4: print(x, y); x, y = y, x\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#pet-peeves"
    },
    {
      "code": "E204",
      "name": "whitespace-after-decorator",
      "summary": "Checks for trailing whitespace after a decorator's opening `@`.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/whitespace-after-decorator/",
      "whyBad": "Including whitespace after the `@` symbol is not compliant with\n[PEP 8].",
      "example": "```python\n@ decorator\ndef func():\n   pass\n```\n\nUse instead:\n```python\n@decorator\ndef func():\n  pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#maximum-line-length"
    },
    {
      "code": "E211",
      "name": "whitespace-before-parameters",
      "summary": "Checks for extraneous whitespace immediately preceding an open parenthesis\nor bracket.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/whitespace-before-parameters/",
      "whyBad": "According to [PEP 8], open parentheses and brackets should not be preceded\nby any trailing whitespace.",
      "example": "```python\nspam (1)\n```\n\nUse instead:\n```python\nspam(1)\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#pet-peeves"
    },
    {
      "code": "E221",
      "name": "multiple-spaces-before-operator",
      "summary": "Checks for extraneous whitespace before an operator.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-spaces-before-operator/",
      "whyBad": "According to [PEP 8], operators should be surrounded by at most a single space on either\nside.",
      "example": "```python\na = 4  + 5\n```\n\nUse instead:\n```python\na = 4 + 5\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements"
    },
    {
      "code": "E222",
      "name": "multiple-spaces-after-operator",
      "summary": "Checks for extraneous whitespace after an operator.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-spaces-after-operator/",
      "whyBad": "According to [PEP 8], operators should be surrounded by at most a single space on either\nside.",
      "example": "```python\na = 4 +  5\n```\n\nUse instead:\n```python\na = 4 + 5\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements"
    },
    {
      "code": "E223",
      "name": "tab-before-operator",
      "summary": "Checks for extraneous tabs before an operator.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/tab-before-operator/",
      "whyBad": "According to [PEP 8], operators should be surrounded by at most a single space on either\nside.",
      "example": "```python\na = 4\\t+ 5\n```\n\nUse instead:\n```python\na = 4 + 5\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements"
    },
    {
      "code": "E224",
      "name": "tab-after-operator",
      "summary": "Checks for extraneous tabs after an operator.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/tab-after-operator/",
      "whyBad": "According to [PEP 8], operators should be surrounded by at most a single space on either\nside.",
      "example": "```python\na = 4 +\\t5\n```\n\nUse instead:\n```python\na = 4 + 5\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements"
    },
    {
      "code": "E225",
      "name": "missing-whitespace-around-operator",
      "summary": "Checks for missing whitespace around all operators.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-whitespace-around-operator/",
      "whyBad": "According to [PEP 8], there should be one space before and after all\nassignment (`=`), augmented assignment (`+=`, `-=`, etc.), comparison,\nand Booleans operators.",
      "example": "```python\nif number==42:\n    print('you have found the meaning of life')\n```\n\nUse instead:\n```python\nif number == 42:\n    print('you have found the meaning of life')\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#pet-peeves"
    },
    {
      "code": "E226",
      "name": "missing-whitespace-around-arithmetic-operator",
      "summary": "Checks for missing whitespace arithmetic operators.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-whitespace-around-arithmetic-operator/",
      "whyBad": "[PEP 8] recommends never using more than one space, and always having the\nsame amount of whitespace on both sides of a binary operator.\n\nFor consistency, this rule enforces one space before and after an\narithmetic operator (`+`, `-`, `/`, and `*`).\n\n(Note that [PEP 8] suggests only adding whitespace around the operator with\nthe lowest precedence, but that authors should \"use [their] own judgment\".)",
      "example": "```python\nnumber = 40+2\n```\n\nUse instead:\n```python\nnumber = 40 + 2\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations"
    },
    {
      "code": "E227",
      "name": "missing-whitespace-around-bitwise-or-shift-operator",
      "summary": "Checks for missing whitespace around bitwise and shift operators.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-whitespace-around-bitwise-or-shift-operator/",
      "whyBad": "[PEP 8] recommends never using more than one space, and always having the\nsame amount of whitespace on both sides of a binary operator.\n\nFor consistency, this rule enforces one space before and after bitwise and\nshift operators (`<<`, `>>`, `&`, `|`, `^`).\n\n(Note that [PEP 8] suggests only adding whitespace around the operator with\nthe lowest precedence, but that authors should \"use [their] own judgment\".)",
      "example": "```python\nx = 128<<1\n```\n\nUse instead:\n```python\nx = 128 << 1\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations"
    },
    {
      "code": "E228",
      "name": "missing-whitespace-around-modulo-operator",
      "summary": "Checks for missing whitespace around the modulo operator.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-whitespace-around-modulo-operator/",
      "whyBad": "[PEP 8] recommends never using more than one space, and always having the\nsame amount of whitespace on both sides of a binary operator.\n\nFor consistency, this rule enforces one space before and after a modulo\noperator (`%`).\n\n(Note that [PEP 8] suggests only adding whitespace around the operator with\nthe lowest precedence, but that authors should \"use [their] own judgment\".)",
      "example": "```python\nremainder = 10%2\n```\n\nUse instead:\n```python\nremainder = 10 % 2\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations"
    },
    {
      "code": "E231",
      "name": "missing-whitespace",
      "summary": "Checks for missing whitespace after `,`, `;`, and `:`.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-whitespace/",
      "whyBad": "Missing whitespace after `,`, `;`, and `:` makes the code harder to read.",
      "example": "```python\na = (1,2)\n```\n\nUse instead:\n```python\na = (1, 2)\n```"
    },
    {
      "code": "E241",
      "name": "multiple-spaces-after-comma",
      "summary": "Checks for extraneous whitespace after a comma.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-spaces-after-comma/",
      "whyBad": "Consistency is good. This rule helps ensure you have a consistent\nformatting style across your project.",
      "example": "```python\na = 4,    5\n```\n\nUse instead:\n```python\na = 4, 5\n```"
    },
    {
      "code": "E242",
      "name": "tab-after-comma",
      "summary": "Checks for extraneous tabs after a comma.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/tab-after-comma/",
      "whyBad": "Commas should be followed by one space, never tabs.",
      "example": "```python\na = 4,\\t5\n```\n\nUse instead:\n```python\na = 4, 5\n```"
    },
    {
      "code": "E251",
      "name": "unexpected-spaces-around-keyword-parameter-equals",
      "summary": "Checks for missing whitespace around the equals sign in an unannotated\nfunction keyword parameter.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unexpected-spaces-around-keyword-parameter-equals/",
      "whyBad": "According to [PEP 8], there should be no spaces around the equals sign in a\nkeyword parameter, if it is unannotated:\n\n> Dont use spaces around the = sign when used to indicate a keyword\n> argument, or when used to indicate a default value for an unannotated\n> function parameter.",
      "example": "```python\ndef add(a = 0) -> int:\n    return a + 1\n```\n\nUse instead:\n```python\ndef add(a=0) -> int:\n    return a + 1\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements"
    },
    {
      "code": "E252",
      "name": "missing-whitespace-around-parameter-equals",
      "summary": "Checks for missing whitespace around the equals sign in an annotated\nfunction keyword parameter.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-whitespace-around-parameter-equals/",
      "whyBad": "According to [PEP 8], the spaces around the equals sign in a keyword\nparameter should only be omitted when the parameter is unannotated:\n\n> Dont use spaces around the = sign when used to indicate a keyword\n> argument, or when used to indicate a default value for an unannotated\n> function parameter.",
      "example": "```python\ndef add(a: int=0) -> int:\n    return a + 1\n```\n\nUse instead:\n```python\ndef add(a: int = 0) -> int:\n    return a + 1\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements"
    },
    {
      "code": "E261",
      "name": "too-few-spaces-before-inline-comment",
      "summary": "Checks if inline comments are separated by at least two spaces.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-few-spaces-before-inline-comment/",
      "whyBad": "An inline comment is a comment on the same line as a statement.\n\nPer [PEP 8], inline comments should be separated by at least two spaces from\nthe preceding statement.",
      "example": "```python\nx = x + 1 # Increment x\n```\n\nUse instead:\n```python\nx = x + 1  # Increment x\nx = x + 1    # Increment x\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#comments"
    },
    {
      "code": "E262",
      "name": "no-space-after-inline-comment",
      "summary": "Checks if one space is used after inline comments.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-space-after-inline-comment/",
      "whyBad": "An inline comment is a comment on the same line as a statement.\n\nPer [PEP 8], inline comments should start with a # and a single space.",
      "example": "```python\nx = x + 1  #Increment x\nx = x + 1  #  Increment x\nx = x + 1  # \\xa0Increment x\n```\n\nUse instead:\n```python\nx = x + 1  # Increment x\nx = x + 1    # Increment x\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#comments"
    },
    {
      "code": "E265",
      "name": "no-space-after-block-comment",
      "summary": "Checks for block comments that lack a single space after the leading `#` character.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-space-after-block-comment/",
      "whyBad": "Per [PEP 8], \"Block comments generally consist of one or more paragraphs built\nout of complete sentences, with each sentence ending in a period.\"\n\nBlock comments should start with a `#` followed by a single space.\n\nShebangs (lines starting with `#!`, at the top of a file) are exempt from this\nrule.",
      "example": "```python\n#Block comment\n```\n\nUse instead:\n```python\n# Block comment\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#comments"
    },
    {
      "code": "E266",
      "name": "multiple-leading-hashes-for-block-comment",
      "summary": "Checks for block comments that start with multiple leading `#` characters.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-leading-hashes-for-block-comment/",
      "whyBad": "Per [PEP 8], \"Block comments generally consist of one or more paragraphs built\nout of complete sentences, with each sentence ending in a period.\"\n\nEach line of a block comment should start with a `#` followed by a single space.\n\nShebangs (lines starting with `#!`, at the top of a file) are exempt from this\nrule.",
      "example": "```python\n### Block comment\n```\n\nUse instead:\n```python\n# Block comment\n```\n\nAlternatively, this rule makes an exception for comments that consist\nsolely of `#` characters, as in:\n\n```python\n##############\n# Block header\n##############\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#comments"
    },
    {
      "code": "E271",
      "name": "multiple-spaces-after-keyword",
      "summary": "Checks for extraneous whitespace after keywords.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-spaces-after-keyword/",
      "whyBad": "",
      "example": "```python\nTrue and  False\n```\n\nUse instead:\n```python\nTrue and False\n```"
    },
    {
      "code": "E272",
      "name": "multiple-spaces-before-keyword",
      "summary": "Checks for extraneous whitespace before keywords.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-spaces-before-keyword/",
      "whyBad": "",
      "example": "```python\nx  and y\n```\n\nUse instead:\n```python\nx and y\n```"
    },
    {
      "code": "E273",
      "name": "tab-after-keyword",
      "summary": "Checks for extraneous tabs after keywords.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/tab-after-keyword/",
      "whyBad": "",
      "example": "```python\nTrue and\\tFalse\n```\n\nUse instead:\n```python\nTrue and False\n```"
    },
    {
      "code": "E274",
      "name": "tab-before-keyword",
      "summary": "Checks for extraneous tabs before keywords.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/tab-before-keyword/",
      "whyBad": "",
      "example": "```python\nTrue\\tand False\n```\n\nUse instead:\n```python\nTrue and False\n```"
    },
    {
      "code": "E275",
      "name": "missing-whitespace-after-keyword",
      "summary": "Checks for missing whitespace after keywords.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-whitespace-after-keyword/",
      "whyBad": "Missing whitespace after keywords makes the code harder to read.",
      "example": "```python\nif(True):\n    pass\n```\n\nUse instead:\n```python\nif (True):\n    pass\n```"
    },
    {
      "code": "E301",
      "name": "blank-line-between-methods",
      "summary": "Checks for missing blank lines between methods of a class.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-line-between-methods/",
      "whyBad": "PEP 8 recommends exactly one blank line between methods of a class.",
      "example": "```python\nclass MyClass(object):\n    def func1():\n        pass\n    def func2():\n        pass\n```\n\nUse instead:\n```python\nclass MyClass(object):\n    def func1():\n        pass\n\n    def func2():\n        pass\n```"
    },
    {
      "code": "E302",
      "name": "blank-lines-top-level",
      "summary": "Checks for missing blank lines between top level functions and classes.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-lines-top-level/",
      "whyBad": "PEP 8 recommends exactly two blank lines between top level functions and classes.\n\nThe rule respects the [`lint.isort.lines-after-imports`] setting when\ndetermining the required number of blank lines between top-level `import`\nstatements and function or class definitions for compatibility with isort.",
      "example": "```python\ndef func1():\n    pass\ndef func2():\n    pass\n```\n\nUse instead:\n```python\ndef func1():\n    pass\n\n\ndef func2():\n    pass\n```"
    },
    {
      "code": "E303",
      "name": "too-many-blank-lines",
      "summary": "Checks for extraneous blank lines.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-blank-lines/",
      "whyBad": "PEP 8 recommends using blank lines as follows:\n- No more than two blank lines between top-level statements.\n- No more than one blank line between non-top-level statements.",
      "example": "```python\ndef func1():\n    pass\n\n\n\ndef func2():\n    pass\n```\n\nUse instead:\n```python\ndef func1():\n    pass\n\n\ndef func2():\n    pass\n```"
    },
    {
      "code": "E304",
      "name": "blank-line-after-decorator",
      "summary": "Checks for extraneous blank line(s) after function decorators.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-line-after-decorator/",
      "whyBad": "There should be no blank lines between a decorator and the object it is decorating.",
      "example": "```python\nclass User(object):\n\n    @property\n\n    def name(self):\n        pass\n```\n\nUse instead:\n```python\nclass User(object):\n\n    @property\n    def name(self):\n        pass\n```"
    },
    {
      "code": "E305",
      "name": "blank-lines-after-function-or-class",
      "summary": "Checks for missing blank lines after the end of function or class.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-lines-after-function-or-class/",
      "whyBad": "PEP 8 recommends using blank lines as follows:\n- Two blank lines are expected between functions and classes\n- One blank line is expected between methods of a class.",
      "example": "```python\nclass User(object):\n    pass\nuser = User()\n```\n\nUse instead:\n```python\nclass User(object):\n    pass\n\n\nuser = User()\n```"
    },
    {
      "code": "E306",
      "name": "blank-lines-before-nested-definition",
      "summary": "Checks for 1 blank line between nested function or class definitions.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-lines-before-nested-definition/",
      "whyBad": "PEP 8 recommends using blank lines as follows:\n- Two blank lines are expected between functions and classes\n- One blank line is expected between methods of a class.",
      "example": "```python\ndef outer():\n    def inner():\n        pass\n    def inner2():\n        pass\n```\n\nUse instead:\n```python\ndef outer():\n    def inner():\n        pass\n\n    def inner2():\n        pass\n```"
    },
    {
      "code": "E401",
      "name": "multiple-imports-on-one-line",
      "summary": "Check for multiple imports on one line.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-imports-on-one-line/",
      "whyBad": "According to [PEP 8], \"imports should usually be on separate lines.\"",
      "example": "```python\nimport sys, os\n```\n\nUse instead:\n```python\nimport os\nimport sys\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#imports"
    },
    {
      "code": "E402",
      "name": "module-import-not-at-top-of-file",
      "summary": "Checks for imports that are not at the top of the file.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/module-import-not-at-top-of-file/",
      "whyBad": "According to [PEP 8], \"imports are always put at the top of the file, just after any\nmodule comments and docstrings, and before module globals and constants.\"\n\nThis rule makes an exception for both `sys.path` modifications (allowing for\n`sys.path.insert`, `sys.path.append`, etc.) and `os.environ` modifications\nbetween imports.",
      "example": "```python\n\"One string\"\n\"Two string\"\na = 1\nimport os\nfrom sys import x\n```\n\nUse instead:\n```python\nimport os\nfrom sys import x\n\n\"One string\"\n\"Two string\"\na = 1\n```"
    },
    {
      "code": "E501",
      "name": "line-too-long",
      "summary": "Checks for lines that exceed the specified maximum character length.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/line-too-long/",
      "whyBad": "Overlong lines can hurt readability. [PEP 8], for example, recommends\nlimiting lines to 79 characters. By default, this rule enforces a limit\nof 88 characters for compatibility with Black and the Ruff formatter,\nthough that limit is configurable via the [`line-length`] setting.\n\nIn the interest of pragmatism, this rule makes a few exceptions when\ndetermining whether a line is overlong. Namely, it:\n\n1. Ignores lines that consist of a single \"word\" (i.e., without any\n   whitespace between its characters).\n2. Ignores lines that end with a URL, as long as the URL starts before\n   the line-length threshold.\n3. Ignores line that end with a pragma comment (e.g., `# type: ignore`\n   or `# noqa`), as long as the pragma comment starts before the\n   line-length threshold. That is, a line will not be flagged as\n   overlong if a pragma comment _causes_ it to exceed the line length.\n   (This behavior aligns with that of the Ruff formatter.)\n4. Ignores SPDX license identifiers and copyright notices\n   (e.g., `# SPDX-License-Identifier: MIT`), which are machine-readable\n   and should _not_ wrap over multiple lines.\n\nIf [`lint.pycodestyle.ignore-overlong-task-comments`] is `true`, this rule will\nalso ignore comments that start with any of the specified [`lint.task-tags`]\n(e.g., `# TODO:`).",
      "example": "```python\nmy_function(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)\n```\n\nUse instead:\n```python\nmy_function(\n    param1, param2, param3, param4, param5,\n    param6, param7, param8, param9, param10\n)\n```"
    },
    {
      "code": "E502",
      "name": "redundant-backslash",
      "summary": "Checks for redundant backslashes between brackets.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-backslash/",
      "whyBad": "Explicit line joins using a backslash are redundant between brackets.",
      "example": "```python\nx = (2 + \\\n    2)\n```\n\nUse instead:\n```python\nx = (2 +\n    2)\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#maximum-line-length"
    },
    {
      "code": "E701",
      "name": "multiple-statements-on-one-line-colon",
      "summary": "Checks for compound statements (multiple statements on the same line).",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-statements-on-one-line-colon/",
      "whyBad": "According to [PEP 8], \"compound statements are generally discouraged\".",
      "example": "```python\nif foo == \"blah\": do_blah_thing()\n```\n\nUse instead:\n```python\nif foo == \"blah\":\n    do_blah_thing()\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations"
    },
    {
      "code": "E702",
      "name": "multiple-statements-on-one-line-semicolon",
      "summary": "Checks for multiline statements on one line.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-statements-on-one-line-semicolon/",
      "whyBad": "According to [PEP 8], including multi-clause statements on the same line is\ndiscouraged.",
      "example": "```python\ndo_one(); do_two(); do_three()\n```\n\nUse instead:\n```python\ndo_one()\ndo_two()\ndo_three()\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations"
    },
    {
      "code": "E703",
      "name": "useless-semicolon",
      "summary": "Checks for statements that end with an unnecessary semicolon.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-semicolon/",
      "whyBad": "A trailing semicolon is unnecessary and should be removed.",
      "example": "```python\ndo_four();  # useless semicolon\n```\n\nUse instead:\n```python\ndo_four()\n```"
    },
    {
      "code": "E711",
      "name": "none-comparison",
      "summary": "Checks for comparisons to `None` which are not using the `is` operator.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/none-comparison/",
      "whyBad": "According to [PEP 8], \"Comparisons to singletons like None should always be done with\n`is` or `is not`, never the equality operators.\"",
      "example": "```python\nif arg != None:\n    pass\nif None == arg:\n    pass\n```\n\nUse instead:\n```python\nif arg is not None:\n    pass\n```"
    },
    {
      "code": "E712",
      "name": "true-false-comparison",
      "summary": "Checks for equality comparisons to boolean literals.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/true-false-comparison/",
      "whyBad": "[PEP 8] recommends against using the equality operators `==` and `!=` to\ncompare values to `True` or `False`.\n\nInstead, use `if cond:` or `if not cond:` to check for truth values.\n\nIf you intend to check if a value is the boolean literal `True` or `False`,\nconsider using `is` or `is not` to check for identity instead.",
      "example": "```python\nif foo == True:\n    ...\n\nif bar == False:\n    ...\n```\n\nUse instead:\n```python\nif foo:\n    ...\n\nif not bar:\n    ...\n```"
    },
    {
      "code": "E713",
      "name": "not-in-test",
      "summary": "Checks for membership tests using `not {element} in {collection}`.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/not-in-test/",
      "whyBad": "Testing membership with `{element} not in {collection}` is more readable.",
      "example": "```python\nZ = not X in Y\nif not X.B in Y:\n    pass\n```\n\nUse instead:\n```python\nZ = X not in Y\nif X.B not in Y:\n    pass\n```"
    },
    {
      "code": "E714",
      "name": "not-is-test",
      "summary": "Checks for identity comparisons using `not {foo} is {bar}`.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/not-is-test/",
      "whyBad": "According to [PEP8], testing for an object's identity with `is not` is more\nreadable.",
      "example": "```python\nif not X is Y:\n    pass\nZ = not X.B is Y\n```\n\nUse instead:\n```python\nif X is not Y:\n    pass\nZ = X.B is not Y\n```\n\n[PEP8]: https://peps.python.org/pep-0008/#programming-recommendations"
    },
    {
      "code": "E721",
      "name": "type-comparison",
      "summary": "Checks for object type comparisons using `==` and other comparison\noperators.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-comparison/",
      "whyBad": "Unlike a direct type comparison, `isinstance` will also check if an object\nis an instance of a class or a subclass thereof.\n\nIf you want to check for an exact type match, use `is` or `is not`."
    },
    {
      "code": "E722",
      "name": "bare-except",
      "summary": "Checks for bare `except` catches in `try`-`except` statements.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bare-except/",
      "whyBad": "A bare `except` catches `BaseException` which includes\n`KeyboardInterrupt`, `SystemExit`, `Exception`, and others. Catching\n`BaseException` can make it hard to interrupt the program (e.g., with\nCtrl-C) and can disguise other problems.",
      "example": "```python\ntry:\n    raise KeyboardInterrupt(\"You probably don't mean to break CTRL-C.\")\nexcept:\n    print(\"But a bare `except` will ignore keyboard interrupts.\")\n```\n\nUse instead:\n```python\ntry:\n    do_something_that_might_break()\nexcept MoreSpecificException as e:\n    handle_error(e)\n```\n\nIf you actually need to catch an unknown error, use `Exception` which will\ncatch regular program errors but not important system exceptions.\n\n```python\ndef run_a_function(some_other_fn):\n    try:\n        some_other_fn()\n    except Exception as e:\n        print(f\"How exceptional! {e}\")\n```"
    },
    {
      "code": "E731",
      "name": "lambda-assignment",
      "summary": "Checks for lambda expressions which are assigned to a variable.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/lambda-assignment/",
      "whyBad": "Per PEP 8, you should \"Always use a def statement instead of an assignment\nstatement that binds a lambda expression directly to an identifier.\"\n\nUsing a `def` statement leads to better tracebacks, and the assignment\nitself negates the primary benefit of using a `lambda` expression (i.e.,\nthat it can be embedded inside another expression).",
      "example": "```python\nf = lambda x: 2 * x\n```\n\nUse instead:\n```python\ndef f(x):\n    return 2 * x\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#programming-recommendations"
    },
    {
      "code": "E741",
      "name": "ambiguous-variable-name",
      "summary": "Checks for the use of the characters 'l', 'O', or 'I' as variable names.\n\nNote: This rule is automatically disabled for all stub files\n(files with `.pyi` extensions). The rule has little relevance for authors\nof stubs: a well-written stub should aim to faithfully represent the\ninterface of the equivalent .py file as it exists at runtime, including any\nambiguously named variables in the runtime module.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ambiguous-variable-name/",
      "whyBad": "In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.",
      "example": "```python\nl = 0\nO = 123\nI = 42\n```\n\nUse instead:\n```python\nL = 0\no = 123\ni = 42\n```"
    },
    {
      "code": "E742",
      "name": "ambiguous-class-name",
      "summary": "Checks for the use of the characters 'l', 'O', or 'I' as class names.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ambiguous-class-name/",
      "whyBad": "In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.",
      "example": "```python\nclass I(object): ...\n```\n\nUse instead:\n\n```python\nclass Integer(object): ...\n```"
    },
    {
      "code": "E743",
      "name": "ambiguous-function-name",
      "summary": "Checks for the use of the characters 'l', 'O', or 'I' as function names.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ambiguous-function-name/",
      "whyBad": "In some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.",
      "example": "```python\ndef l(x): ...\n```\n\nUse instead:\n\n```python\ndef long_name(x): ...\n```"
    },
    {
      "code": "E902",
      "name": "io-error",
      "summary": "This is not a regular diagnostic; instead, it's raised when a file cannot be read\nfrom disk.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/io-error/",
      "whyBad": "An `IOError` indicates an error in the development setup. For example, the user may\nnot have permissions to read a given file, or the filesystem may contain a broken\nsymlink.",
      "example": "On Linux or macOS:\n```shell\n$ echo 'print(\"hello world!\")' > a.py\n$ chmod 000 a.py\n$ ruff a.py\na.py:1:1: E902 Permission denied (os error 13)\nFound 1 error.\n```"
    },
    {
      "code": "E999",
      "name": "syntax-error",
      "summary": "Checks for code that contains syntax errors.",
      "category": "pycodestyle",
      "categoryCode": "E",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/syntax-error/",
      "whyBad": "Code with syntax errors cannot be executed. Such errors are likely a\nmistake.",
      "example": "```python\nx =\n```\n\nUse instead:\n```python\nx = 1\n```"
    },
    {
      "code": "W191",
      "name": "tab-indentation",
      "summary": "Checks for indentation that uses tabs.",
      "category": "pycodestyle",
      "categoryCode": "W",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/tab-indentation/",
      "whyBad": "According to [PEP 8], spaces are preferred over tabs (unless used to remain\nconsistent with code that is already indented with tabs)."
    },
    {
      "code": "W291",
      "name": "trailing-whitespace",
      "summary": "Checks for superfluous trailing whitespace.",
      "category": "pycodestyle",
      "categoryCode": "W",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/trailing-whitespace/",
      "whyBad": "According to [PEP 8], \"avoid trailing whitespace anywhere. Because its usually\ninvisible, it can be confusing\"",
      "example": "```python\nspam(1) \\n#\n```\n\nUse instead:\n```python\nspam(1)\\n#\n```"
    },
    {
      "code": "W292",
      "name": "missing-newline-at-end-of-file",
      "summary": "Checks for files missing a new line at the end of the file.",
      "category": "pycodestyle",
      "categoryCode": "W",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-newline-at-end-of-file/",
      "whyBad": "Trailing blank lines in a file are superfluous.\n\nHowever, the last line of the file should end with a newline.",
      "example": "```python\nspam(1)\n```\n\nUse instead:\n```python\nspam(1)\\n\n```"
    },
    {
      "code": "W293",
      "name": "blank-line-with-whitespace",
      "summary": "Checks for superfluous whitespace in blank lines.",
      "category": "pycodestyle",
      "categoryCode": "W",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-line-with-whitespace/",
      "whyBad": "According to [PEP 8], \"avoid trailing whitespace anywhere. Because its usually\ninvisible, it can be confusing\"",
      "example": "```python\nclass Foo(object):\\n    \\n    bang = 12\n```\n\nUse instead:\n```python\nclass Foo(object):\\n\\n    bang = 12\n```"
    },
    {
      "code": "W391",
      "name": "too-many-newlines-at-end-of-file",
      "summary": "Checks for files with multiple trailing blank lines.\n\nIn the case of notebooks, this check is applied to\neach cell separately.",
      "category": "pycodestyle",
      "categoryCode": "W",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-newlines-at-end-of-file/",
      "whyBad": "Trailing blank lines in a file are superfluous.\n\nHowever, the last line of the file should end with a newline.",
      "example": "```python\nspam(1)\\n\\n\\n\n```\n\nUse instead:\n```python\nspam(1)\\n\n```"
    },
    {
      "code": "W505",
      "name": "doc-line-too-long",
      "summary": "Checks for doc lines that exceed the specified maximum character length.",
      "category": "pycodestyle",
      "categoryCode": "W",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/doc-line-too-long/",
      "whyBad": "For flowing long blocks of text (docstrings or comments), overlong lines\ncan hurt readability. [PEP 8], for example, recommends that such lines be\nlimited to 72 characters, while this rule enforces the limit specified by\nthe [`lint.pycodestyle.max-doc-length`] setting. (If no value is provided, this\nrule will be ignored, even if it's added to your `--select` list.)\n\nIn the context of this rule, a \"doc line\" is defined as a line consisting\nof either a standalone comment or a standalone string, like a docstring.\n\nIn the interest of pragmatism, this rule makes a few exceptions when\ndetermining whether a line is overlong. Namely, it:\n\n1. Ignores lines that consist of a single \"word\" (i.e., without any\n   whitespace between its characters).\n2. Ignores lines that end with a URL, as long as the URL starts before\n   the line-length threshold.\n3. Ignores line that end with a pragma comment (e.g., `# type: ignore`\n   or `# noqa`), as long as the pragma comment starts before the\n   line-length threshold. That is, a line will not be flagged as\n   overlong if a pragma comment _causes_ it to exceed the line length.\n   (This behavior aligns with that of the Ruff formatter.)\n\nIf [`lint.pycodestyle.ignore-overlong-task-comments`] is `true`, this rule will\nalso ignore comments that start with any of the specified [`lint.task-tags`]\n(e.g., `# TODO:`).",
      "example": "```python\ndef function(x):\n    \"\"\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis auctor purus ut ex fermentum, at maximus est hendrerit.\"\"\"\n```\n\nUse instead:\n```python\ndef function(x):\n    \"\"\"\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n    Duis auctor purus ut ex fermentum, at maximus est hendrerit.\n    \"\"\"\n```"
    },
    {
      "code": "W605",
      "name": "invalid-escape-sequence",
      "summary": "Checks for invalid escape sequences.",
      "category": "pycodestyle",
      "categoryCode": "W",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-escape-sequence/",
      "whyBad": "Invalid escape sequences are deprecated in Python 3.6.",
      "example": "```python\nregex = \"\\.png$\"\n```\n\nUse instead:\n```python\nregex = r\"\\.png$\"\n```\n\nOr, if the string already contains a valid escape sequence:\n```python\nvalue = \"new line\\nand invalid escape \\_ here\"\n```\n\nUse instead:\n```python\nvalue = \"new line\\nand invalid escape \\\\_ here\"\n```"
    },
    {
      "code": "DOC102",
      "name": "docstring-extraneous-parameter",
      "summary": "Checks for function docstrings that include parameters which are not\nin the function signature.",
      "category": "pydoclint",
      "categoryCode": "DOC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-extraneous-parameter/",
      "whyBad": "If a docstring documents a parameter which is not in the function signature,\nit can be misleading to users and/or a sign of incomplete documentation or\nrefactors.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n        acceleration: Rate of change of speed.\n\n    Returns:\n        Speed as distance divided by time.\n    \"\"\"\n    return distance / time\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n    \"\"\"\n    return distance / time\n```"
    },
    {
      "code": "DOC201",
      "name": "docstring-missing-returns",
      "summary": "Checks for functions with `return` statements that do not have \"Returns\"\nsections in their docstrings.",
      "category": "pydoclint",
      "categoryCode": "DOC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-missing-returns/",
      "whyBad": "A missing \"Returns\" section is a sign of incomplete documentation.\n\nThis rule is not enforced for abstract methods or functions that only return\n`None`. It is also ignored for \"stub functions\": functions where the body only\nconsists of `pass`, `...`, `raise NotImplementedError`, or similar.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n    \"\"\"\n    return distance / time\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n    \"\"\"\n    return distance / time\n```"
    },
    {
      "code": "DOC202",
      "name": "docstring-extraneous-returns",
      "summary": "Checks for function docstrings with unnecessary \"Returns\" sections.",
      "category": "pydoclint",
      "categoryCode": "DOC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-extraneous-returns/",
      "whyBad": "A function without an explicit `return` statement should not have a\n\"Returns\" section in its docstring.\n\nThis rule is not enforced for abstract methods. It is also ignored for\n\"stub functions\": functions where the body only consists of `pass`, `...`,\n`raise NotImplementedError`, or similar.",
      "example": "```python\ndef say_hello(n: int) -> None:\n    \"\"\"Says hello to the user.\n\n    Args:\n        n: Number of times to say hello.\n\n    Returns:\n        Doesn't return anything.\n    \"\"\"\n    for _ in range(n):\n        print(\"Hello!\")\n```\n\nUse instead:\n```python\ndef say_hello(n: int) -> None:\n    \"\"\"Says hello to the user.\n\n    Args:\n        n: Number of times to say hello.\n    \"\"\"\n    for _ in range(n):\n        print(\"Hello!\")\n```"
    },
    {
      "code": "DOC402",
      "name": "docstring-missing-yields",
      "summary": "Checks for functions with `yield` statements that do not have \"Yields\" sections in\ntheir docstrings.",
      "category": "pydoclint",
      "categoryCode": "DOC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-missing-yields/",
      "whyBad": "A missing \"Yields\" section is a sign of incomplete documentation.\n\nThis rule is not enforced for abstract methods or functions that only yield `None`.\nIt is also ignored for \"stub functions\": functions where the body only consists\nof `pass`, `...`, `raise NotImplementedError`, or similar.",
      "example": "```python\ndef count_to_n(n: int) -> int:\n    \"\"\"Generate integers up to *n*.\n\n    Args:\n        n: The number at which to stop counting.\n    \"\"\"\n    for i in range(1, n + 1):\n        yield i\n```\n\nUse instead:\n```python\ndef count_to_n(n: int) -> int:\n    \"\"\"Generate integers up to *n*.\n\n    Args:\n        n: The number at which to stop counting.\n\n    Yields:\n        int: The number we're at in the count.\n    \"\"\"\n    for i in range(1, n + 1):\n        yield i\n```"
    },
    {
      "code": "DOC403",
      "name": "docstring-extraneous-yields",
      "summary": "Checks for function docstrings with unnecessary \"Yields\" sections.",
      "category": "pydoclint",
      "categoryCode": "DOC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-extraneous-yields/",
      "whyBad": "A function that doesn't yield anything should not have a \"Yields\" section\nin its docstring.\n\nThis rule is not enforced for abstract methods. It is also ignored for\n\"stub functions\": functions where the body only consists of `pass`, `...`,\n`raise NotImplementedError`, or similar.",
      "example": "```python\ndef say_hello(n: int) -> None:\n    \"\"\"Says hello to the user.\n\n    Args:\n        n: Number of times to say hello.\n\n    Yields:\n        Doesn't yield anything.\n    \"\"\"\n    for _ in range(n):\n        print(\"Hello!\")\n```\n\nUse instead:\n```python\ndef say_hello(n: int) -> None:\n    \"\"\"Says hello to the user.\n\n    Args:\n        n: Number of times to say hello.\n    \"\"\"\n    for _ in range(n):\n        print(\"Hello!\")\n```"
    },
    {
      "code": "DOC501",
      "name": "docstring-missing-exception",
      "summary": "Checks for function docstrings that do not document all explicitly raised\nexceptions.",
      "category": "pydoclint",
      "categoryCode": "DOC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-missing-exception/",
      "whyBad": "A function should document all exceptions that are directly raised in some\ncircumstances. Failing to document an exception that could be raised\ncan be misleading to users and/or a sign of incomplete documentation.\n\nThis rule is not enforced for abstract methods. It is also ignored for\n\"stub functions\": functions where the body only consists of `pass`, `...`,\n`raise NotImplementedError`, or similar.",
      "example": "```python\nclass FasterThanLightError(ArithmeticError): ...\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\nclass FasterThanLightError(ArithmeticError): ...\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "DOC502",
      "name": "docstring-extraneous-exception",
      "summary": "Checks for function docstrings that state that exceptions could be raised\neven though they are not directly raised in the function body.",
      "category": "pydoclint",
      "categoryCode": "DOC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-extraneous-exception/",
      "whyBad": "Some conventions prefer non-explicit exceptions be omitted from the\ndocstring.\n\nThis rule is not enforced for abstract methods. It is also ignored for\n\"stub functions\": functions where the body only consists of `pass`, `...`,\n`raise NotImplementedError`, or similar.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        ZeroDivisionError: Divided by zero.\n    \"\"\"\n    return distance / time\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n    \"\"\"\n    return distance / time\n```"
    },
    {
      "code": "D100",
      "name": "undocumented-public-module",
      "summary": "Checks for undocumented public module definitions.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-public-module/",
      "whyBad": "Public modules should be documented via docstrings to outline their purpose\nand contents.\n\nGenerally, module docstrings should describe the purpose of the module and\nlist the classes, exceptions, functions, and other objects that are exported\nby the module, alongside a one-line summary of each.\n\nIf the module is a script, the docstring should be usable as its \"usage\"\nmessage.\n\nIf the codebase adheres to a standard format for module docstrings, follow\nthat format for consistency.",
      "example": "```python\nclass FasterThanLightError(ZeroDivisionError): ...\n\n\ndef calculate_speed(distance: float, time: float) -> float: ...\n```\n\nUse instead:\n\n```python\n\"\"\"Utility functions and classes for calculating speed.\n\nThis module provides:\n- FasterThanLightError: exception when FTL speed is calculated;\n- calculate_speed: calculate speed given distance and time.\n\"\"\"\n\n\nclass FasterThanLightError(ZeroDivisionError): ...\n\n\ndef calculate_speed(distance: float, time: float) -> float: ...\n```"
    },
    {
      "code": "D101",
      "name": "undocumented-public-class",
      "summary": "Checks for undocumented public class definitions.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-public-class/",
      "whyBad": "Public classes should be documented via docstrings to outline their purpose\nand behavior.\n\nGenerally, a class docstring should describe the class's purpose and list\nits public attributes and methods.\n\nIf the codebase adheres to a standard format for class docstrings, follow\nthat format for consistency.",
      "example": "```python\nclass Player:\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n```\n\nUse instead (in the NumPy docstring format):\n```python\nclass Player:\n    \"\"\"A player in the game.\n\n    Attributes\n    ----------\n    name : str\n        The name of the player.\n    points : int\n        The number of points the player has.\n\n    Methods\n    -------\n    add_points(points: int) -> None\n        Add points to the player's score.\n    \"\"\"\n\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n```\n\nOr (in the Google docstring format):\n```python\nclass Player:\n    \"\"\"A player in the game.\n\n    Attributes:\n        name: The name of the player.\n        points: The number of points the player has.\n    \"\"\"\n\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n```"
    },
    {
      "code": "D102",
      "name": "undocumented-public-method",
      "summary": "Checks for undocumented public method definitions.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-public-method/",
      "whyBad": "Public methods should be documented via docstrings to outline their purpose\nand behavior.\n\nGenerally, a method docstring should describe the method's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\nIf the codebase adheres to a standard format for method docstrings, follow\nthat format for consistency.\n\nThis rule exempts methods decorated with [`@typing.override`][override],\nsince it is a common practice to document a method on a superclass but not\non an overriding method in a subclass.",
      "example": "```python\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n```\n\nUse instead (in the NumPy docstring format):\n\n```python\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        \"\"\"Print a greeting from the cat.\n\n        Parameters\n        ----------\n        happy : bool, optional\n            Whether the cat is happy, is True by default.\n\n        Raises\n        ------\n        ValueError\n            If the cat is not happy.\n        \"\"\"\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n```\n\nOr (in the Google docstring format):\n\n```python\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        \"\"\"Print a greeting from the cat.\n\n        Args:\n            happy: Whether the cat is happy, is True by default.\n\n        Raises:\n            ValueError: If the cat is not happy.\n        \"\"\"\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n```"
    },
    {
      "code": "D103",
      "name": "undocumented-public-function",
      "summary": "Checks for undocumented public function definitions.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-public-function/",
      "whyBad": "Public functions should be documented via docstrings to outline their\npurpose and behavior.\n\nGenerally, a function docstring should describe the function's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\nIf the codebase adheres to a standard format for function docstrings, follow\nthat format for consistency.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead (using the NumPy docstring format):\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nOr, using the Google docstring format:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D104",
      "name": "undocumented-public-package",
      "summary": "Checks for undocumented public package definitions.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-public-package/",
      "whyBad": "Public packages should be documented via docstrings to outline their\npurpose and contents.\n\nGenerally, package docstrings should list the modules and subpackages that\nare exported by the package.\n\nIf the codebase adheres to a standard format for package docstrings, follow\nthat format for consistency.",
      "example": "```python\n__all__ = [\"Player\", \"Game\"]\n```\n\nUse instead:\n```python\n\"\"\"Game and player management package.\n\nThis package provides classes for managing players and games.\n\"\"\"\n\n__all__ = [\"player\", \"game\"]\n```"
    },
    {
      "code": "D105",
      "name": "undocumented-magic-method",
      "summary": "Checks for undocumented magic method definitions.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-magic-method/",
      "whyBad": "Magic methods (methods with names that start and end with double\nunderscores) are used to implement operator overloading and other special\nbehavior. Such methods should be documented via docstrings to\noutline their behavior.\n\nGenerally, magic method docstrings should describe the method's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\nIf the codebase adheres to a standard format for method docstrings, follow\nthat format for consistency.",
      "example": "```python\nclass Cat(Animal):\n    def __str__(self) -> str:\n        return f\"Cat: {self.name}\"\n\n\ncat = Cat(\"Dusty\")\nprint(cat)  # \"Cat: Dusty\"\n```\n\nUse instead:\n```python\nclass Cat(Animal):\n    def __str__(self) -> str:\n        \"\"\"Return a string representation of the cat.\"\"\"\n        return f\"Cat: {self.name}\"\n\n\ncat = Cat(\"Dusty\")\nprint(cat)  # \"Cat: Dusty\"\n```"
    },
    {
      "code": "D106",
      "name": "undocumented-public-nested-class",
      "summary": "Checks for undocumented public class definitions, for nested classes.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-public-nested-class/",
      "whyBad": "Public classes should be documented via docstrings to outline their\npurpose and behavior.\n\nNested classes do not inherit the docstring of their enclosing class, so\nthey should have their own docstrings.\n\nIf the codebase adheres to a standard format for class docstrings, follow\nthat format for consistency.",
      "example": "```python\nclass Foo:\n    \"\"\"Class Foo.\"\"\"\n\n    class Bar: ...\n\n\nbar = Foo.Bar()\nbar.__doc__  # None\n```\n\nUse instead:\n\n```python\nclass Foo:\n    \"\"\"Class Foo.\"\"\"\n\n    class Bar:\n        \"\"\"Class Bar.\"\"\"\n\n\nbar = Foo.Bar()\nbar.__doc__  # \"Class Bar.\"\n```"
    },
    {
      "code": "D107",
      "name": "undocumented-public-init",
      "summary": "Checks for public `__init__` method definitions that are missing\ndocstrings.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-public-init/",
      "whyBad": "Public `__init__` methods are used to initialize objects. `__init__`\nmethods should be documented via docstrings to describe the method's\nbehavior, arguments, side effects, exceptions, and any other information\nthat may be relevant to the user.\n\nIf the codebase adheres to a standard format for `__init__` method docstrings,\nfollow that format for consistency.",
      "example": "```python\nclass City:\n    def __init__(self, name: str, population: int) -> None:\n        self.name: str = name\n        self.population: int = population\n```\n\nUse instead:\n```python\nclass City:\n    def __init__(self, name: str, population: int) -> None:\n        \"\"\"Initialize a city with a name and population.\"\"\"\n        self.name: str = name\n        self.population: int = population\n```"
    },
    {
      "code": "D200",
      "name": "unnecessary-multiline-docstring",
      "summary": "Checks for single-line docstrings that are broken across multiple lines.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-multiline-docstring/",
      "whyBad": "[PEP 257] recommends that docstrings that _can_ fit on one line should be\nformatted on a single line, for consistency and readability.",
      "example": "```python\ndef average(values: list[float]) -> float:\n    \"\"\"\n    Return the mean of the given values.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```"
    },
    {
      "code": "D201",
      "name": "blank-line-before-function",
      "summary": "Checks for docstrings on functions that are separated by one or more blank\nlines from the function definition.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-line-before-function/",
      "whyBad": "Remove any blank lines between the function definition and its docstring,\nfor consistency.",
      "example": "```python\ndef average(values: list[float]) -> float:\n\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```"
    },
    {
      "code": "D202",
      "name": "blank-line-after-function",
      "summary": "Checks for docstrings on functions that are separated by one or more blank\nlines from the function body.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-line-after-function/",
      "whyBad": "Remove any blank lines between the function body and the function\ndocstring, for consistency.",
      "example": "```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\n    return sum(values) / len(values)\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n    return sum(values) / len(values)\n```"
    },
    {
      "code": "D203",
      "name": "incorrect-blank-line-before-class",
      "summary": "Checks for docstrings on class definitions that are not preceded by a\nblank line.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/incorrect-blank-line-before-class/",
      "whyBad": "Use a blank line to separate the docstring from the class definition, for\nconsistency.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is disabled when using the `google`,\n`numpy`, and `pep257` conventions.\n\nFor an alternative, see [D211].",
      "example": "```python\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n```\n\nUse instead:\n\n```python\nclass PhotoMetadata:\n\n    \"\"\"Metadata about a photo.\"\"\"\n```"
    },
    {
      "code": "D204",
      "name": "incorrect-blank-line-after-class",
      "summary": "Checks for class methods that are not separated from the class's docstring\nby a blank line.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/incorrect-blank-line-after-class/",
      "whyBad": "[PEP 257] recommends the use of a blank line to separate a class's\ndocstring from its methods.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `numpy` and `pep257`\nconventions, and disabled when using the `google` convention.",
      "example": "```python\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n    def __init__(self, file: Path):\n        ...\n```\n\nUse instead:\n```python\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n\n    def __init__(self, file: Path):\n        ...\n```"
    },
    {
      "code": "D205",
      "name": "missing-blank-line-after-summary",
      "summary": "Checks for docstring summary lines that are not separated from the docstring\ndescription by one blank line.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-blank-line-after-summary/",
      "whyBad": "[PEP 257] recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"",
      "example": "```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n    Sort the list in ascending order and return a copy of the\n    result using the bubble sort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the\n    result using the bubble sort algorithm.\n    \"\"\"\n```"
    },
    {
      "code": "D206",
      "name": "docstring-tab-indentation",
      "summary": "Checks for docstrings that are indented with tabs.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-tab-indentation/",
      "whyBad": "[PEP 8] recommends using spaces over tabs for indentation.",
      "example": "```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n\tSort the list in ascending order and return a copy of the result using the bubble\n\tsort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```"
    },
    {
      "code": "D207",
      "name": "under-indentation",
      "summary": "Checks for under-indented docstrings.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/under-indentation/",
      "whyBad": "[PEP 257] recommends that docstrings be indented to the same level as their\nopening quotes. Avoid under-indenting docstrings, for consistency.",
      "example": "```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\nSort the list in ascending order and return a copy of the result using the bubble sort\nalgorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```"
    },
    {
      "code": "D208",
      "name": "over-indentation",
      "summary": "Checks for over-indented docstrings.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/over-indentation/",
      "whyBad": "[PEP 257] recommends that docstrings be indented to the same level as their\nopening quotes. Avoid over-indenting docstrings, for consistency.",
      "example": "```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n        Sort the list in ascending order and return a copy of the result using the\n        bubble sort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```"
    },
    {
      "code": "D209",
      "name": "new-line-after-last-paragraph",
      "summary": "Checks for multi-line docstrings whose closing quotes are not on their\nown line.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/new-line-after-last-paragraph/",
      "whyBad": "[PEP 257] recommends that the closing quotes of a multi-line docstring be\non their own line, for consistency and compatibility with documentation\ntools that may need to parse the docstring.",
      "example": "```python\ndef sort_list(l: List[int]) -> List[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: List[int]) -> List[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```"
    },
    {
      "code": "D210",
      "name": "surrounding-whitespace",
      "summary": "Checks for surrounding whitespace in docstrings.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/surrounding-whitespace/",
      "whyBad": "Remove surrounding whitespace from the docstring, for consistency.",
      "example": "```python\ndef factorial(n: int) -> int:\n    \"\"\" Return the factorial of n. \"\"\"\n```\n\nUse instead:\n```python\ndef factorial(n: int) -> int:\n    \"\"\"Return the factorial of n.\"\"\"\n```"
    },
    {
      "code": "D211",
      "name": "blank-line-before-class",
      "summary": "Checks for docstrings on class definitions that are preceded by a blank\nline.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-line-before-class/",
      "whyBad": "Avoid introducing any blank lines between a class definition and its\ndocstring, for consistency.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google`,\n`numpy`, and `pep257` conventions.\n\nFor an alternative, see [D203].",
      "example": "```python\nclass PhotoMetadata:\n\n    \"\"\"Metadata about a photo.\"\"\"\n```\n\nUse instead:\n\n```python\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n```"
    },
    {
      "code": "D212",
      "name": "multi-line-summary-first-line",
      "summary": "Checks for docstring summary lines that are not positioned on the first\nphysical line of the docstring.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multi-line-summary-first-line/",
      "whyBad": "[PEP 257] recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"\n\nThe summary line should be located on the first physical line of the\ndocstring, immediately after the opening quotes.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google`\nconvention, and disabled when using the `numpy` and `pep257` conventions.\n\nFor an alternative, see [D213].",
      "example": "```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"\n    Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```"
    },
    {
      "code": "D213",
      "name": "multi-line-summary-second-line",
      "summary": "Checks for docstring summary lines that are not positioned on the second\nphysical line of the docstring.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multi-line-summary-second-line/",
      "whyBad": "[PEP 257] recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"\n\nThe summary line should be located on the second physical line of the\ndocstring, immediately after the opening quotes and the blank line.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is disabled when using the `google`,\n`numpy`, and `pep257` conventions.\n\nFor an alternative, see [D212].",
      "example": "```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"\n    Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```"
    },
    {
      "code": "D214",
      "name": "overindented-section",
      "summary": "Checks for over-indented sections in docstrings.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/overindented-section/",
      "whyBad": "This rule enforces a consistent style for docstrings with multiple\nsections.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. The convention is that all sections should use\nconsistent indentation. In each section, the header should match the\nindentation of the docstring's opening quotes, and the body should be\nindented one level further.\n\nThis rule is enabled when using the `numpy` and `google` conventions, and\ndisabled when using the `pep257` convention.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n        Args:\n            distance: Distance traveled.\n            time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D215",
      "name": "overindented-section-underline",
      "summary": "Checks for over-indented section underlines in docstrings.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/overindented-section-underline/",
      "whyBad": "This rule enforces a consistent style for multiline numpy-style docstrings,\nand helps prevent incorrect syntax in docstrings using reStructuredText.\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a section header and a section body, and there should be a series of\nunderline characters in the line following the header. The underline should\nhave the same indentation as the header.\n\nThis rule enforces a consistent style for multiline numpy-style docstrings\nwith sections. If your docstring uses reStructuredText, the rule also\nhelps protect against incorrect reStructuredText syntax, which would cause\nerrors if you tried to use a tool such as Sphinx to generate documentation\nfrom the docstring.\n\nThis rule is enabled when using the `numpy` convention, and disabled when\nusing the `google` or `pep257` conventions.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n        ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n          -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n      ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D300",
      "name": "triple-single-quotes",
      "summary": "Checks for docstrings that use `'''triple single quotes'''` instead of\n`\"\"\"triple double quotes\"\"\"`.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/triple-single-quotes/",
      "whyBad": "[PEP 257](https://peps.python.org/pep-0257/#what-is-a-docstring) recommends\nthe use of `\"\"\"triple double quotes\"\"\"` for docstrings, to ensure\nconsistency.",
      "example": "```python\ndef kos_root():\n    '''Return the pathname of the KOS root directory.'''\n```\n\nUse instead:\n```python\ndef kos_root():\n    \"\"\"Return the pathname of the KOS root directory.\"\"\"\n```"
    },
    {
      "code": "D301",
      "name": "escape-sequence-in-docstring",
      "summary": "Checks for docstrings that include backslashes, but are not defined as\nraw string literals.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/escape-sequence-in-docstring/",
      "whyBad": "In Python, backslashes are typically used to escape characters in strings.\nIn raw strings (those prefixed with an `r`), however, backslashes are\ntreated as literal characters.\n\n[PEP 257](https://peps.python.org/pep-0257/#what-is-a-docstring) recommends\nthe use of raw strings (i.e., `r\"\"\"raw triple double quotes\"\"\"`) for\ndocstrings that include backslashes. The use of a raw string ensures that\nany backslashes are treated as literal characters, and not as escape\nsequences, which avoids confusion.",
      "example": "```python\ndef foobar():\n    \"\"\"Docstring for foo\\bar.\"\"\"\n\n\nfoobar.__doc__  # \"Docstring for foar.\"\n```\n\nUse instead:\n```python\ndef foobar():\n    r\"\"\"Docstring for foo\\bar.\"\"\"\n\n\nfoobar.__doc__  # \"Docstring for foo\\bar.\"\n```"
    },
    {
      "code": "D400",
      "name": "missing-trailing-period",
      "summary": "Checks for docstrings in which the first line does not end in a period.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-trailing-period/",
      "whyBad": "[PEP 257] recommends that the first line of a docstring is written in the\nform of a command, ending in a period.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `numpy` and\n`pep257` conventions, and disabled when using the `google` convention.",
      "example": "```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```"
    },
    {
      "code": "D401",
      "name": "non-imperative-mood",
      "summary": "Checks for docstring first lines that are not in an imperative mood.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-imperative-mood/",
      "whyBad": "[PEP 257] recommends that the first line of a docstring be written in the\nimperative mood, for consistency.\n\nHint: to rewrite the docstring in the imperative, phrase the first line as\nif it were a command.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `numpy` and\n`pep257` conventions, and disabled when using the `google` conventions.",
      "example": "```python\ndef average(values: list[float]) -> float:\n    \"\"\"Returns the mean of the given values.\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```"
    },
    {
      "code": "D402",
      "name": "signature-in-docstring",
      "summary": "Checks for function docstrings that include the function's signature in\nthe summary line.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/signature-in-docstring/",
      "whyBad": "[PEP 257] recommends against including a function's signature in its\ndocstring. Instead, consider using type annotations as a form of\ndocumentation for the function's parameters and return value.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google` and\n`pep257` conventions, and disabled when using the `numpy` convention.",
      "example": "```python\ndef foo(a, b):\n    \"\"\"foo(a: int, b: int) -> list[int]\"\"\"\n```\n\nUse instead:\n```python\ndef foo(a: int, b: int) -> list[int]:\n    \"\"\"Return a list of a and b.\"\"\"\n```"
    },
    {
      "code": "D403",
      "name": "first-word-uncapitalized",
      "summary": "Checks for docstrings that do not start with a capital letter.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/first-word-uncapitalized/",
      "whyBad": "The first non-whitespace character in a docstring should be\ncapitalized for grammatical correctness and consistency.",
      "example": "```python\ndef average(values: list[float]) -> float:\n    \"\"\"return the mean of the given values.\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```"
    },
    {
      "code": "D404",
      "name": "docstring-starts-with-this",
      "summary": "Checks for docstrings that start with `This`.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/docstring-starts-with-this/",
      "whyBad": "[PEP 257] recommends that the first line of a docstring be written in the\nimperative mood, for consistency.\n\nHint: to rewrite the docstring in the imperative, phrase the first line as\nif it were a command.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `numpy`\nconvention,, and disabled when using the `google` and `pep257` conventions.",
      "example": "```python\ndef average(values: list[float]) -> float:\n    \"\"\"This function returns the mean of the given values.\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```"
    },
    {
      "code": "D405",
      "name": "non-capitalized-section-name",
      "summary": "Checks for section headers in docstrings that do not begin with capital\nletters.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-capitalized-section-name/",
      "whyBad": "For stylistic consistency, all section headers in a docstring should be\ncapitalized.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections. Each section typically has\na header and a body.\n\nThis rule is enabled when using the `numpy` and `google` conventions, and\ndisabled when using the `pep257` convention.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    returns:\n        Speed as distance divided by time.\n\n    raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D406",
      "name": "missing-new-line-after-section-name",
      "summary": "Checks for section headers in docstrings that are followed by non-newline\ncharacters.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-new-line-after-section-name/",
      "whyBad": "This rule enforces a consistent style for multiline numpy-style docstrings.\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a section header and a section body. The section header should be\nfollowed by a newline, rather than by some other character (like a colon).\n\nThis rule is enabled when using the `numpy` convention, and disabled\nwhen using the `google` or `pep257` conventions.",
      "example": "```python\n# The `Parameters`, `Returns` and `Raises` section headers are all followed"
    },
    {
      "code": "D407",
      "name": "missing-dashed-underline-after-section",
      "summary": "Checks for section headers in docstrings that are not followed by\nunderlines.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-dashed-underline-after-section/",
      "whyBad": "This rule enforces a consistent style for multiline numpy-style docstrings,\nand helps prevent incorrect syntax in docstrings using reStructuredText.\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a section header and a section body, and the header should be followed\nby a series of underline characters in the following line.\n\nThis rule enforces a consistent style for multiline numpy-style docstrings\nwith sections. If your docstring uses reStructuredText, the rule also\nhelps protect against incorrect reStructuredText syntax, which would cause\nerrors if you tried to use a tool such as Sphinx to generate documentation\nfrom the docstring.\n\nThis rule is enabled when using the `numpy` convention, and disabled\nwhen using the `google` or `pep257` conventions.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n\n    float\n        Speed as distance divided by time.\n\n    Raises\n\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D408",
      "name": "missing-section-underline-after-name",
      "summary": "Checks for section underlines in docstrings that are not on the line\nimmediately following the section name.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-section-underline-after-name/",
      "whyBad": "This rule enforces a consistent style for multiline numpy-style docstrings,\nand helps prevent incorrect syntax in docstrings using reStructuredText.\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a header and a body. There should be a series of underline characters\nin the line immediately below the header.\n\nThis rule enforces a consistent style for multiline numpy-style docstrings\nwith sections. If your docstring uses reStructuredText, the rule also\nhelps protect against incorrect reStructuredText syntax, which would cause\nerrors if you tried to use a tool such as Sphinx to generate documentation\nfrom the docstring.\n\nThis rule is enabled when using the `numpy` convention, and disabled\nwhen using the `google` or `pep257` conventions.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D409",
      "name": "mismatched-section-underline-length",
      "summary": "Checks for section underlines in docstrings that do not match the length of\nthe corresponding section header.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mismatched-section-underline-length/",
      "whyBad": "This rule enforces a consistent style for multiline numpy-style docstrings,\nand helps prevent incorrect syntax in docstrings using reStructuredText.\n\nMultiline numpy-style docstrings are typically composed of a summary line,\nfollowed by a blank line, followed by a series of sections. Each section\nhas a section header and a section body, and there should be a series of\nunderline characters in the line following the header. The length of the\nunderline should exactly match the length of the section header.\n\nThis rule enforces a consistent style for multiline numpy-style docstrings\nwith sections. If your docstring uses reStructuredText, the rule also\nhelps protect against incorrect reStructuredText syntax, which would cause\nerrors if you tried to use a tool such as Sphinx to generate documentation\nfrom the docstring.\n\nThis rule is enabled when using the `numpy` convention, and disabled\nwhen using the `google` or `pep257` conventions.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ---\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    ---\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ---\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D410",
      "name": "no-blank-line-after-section",
      "summary": "Checks for docstring sections that are not separated by a single blank\nline.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-blank-line-after-section/",
      "whyBad": "This rule enforces consistency in your docstrings, and helps ensure\ncompatibility with documentation tooling.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. If a multiline numpy-style or Google-style docstring\nconsists of multiple sections, each section should be separated by a single\nblank line.\n\nThis rule is enabled when using the `numpy` and `google` conventions, and\ndisabled when using the `pep257` convention.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D411",
      "name": "no-blank-line-before-section",
      "summary": "Checks for docstring sections that are not separated by a blank line.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-blank-line-before-section/",
      "whyBad": "This rule enforces consistency in numpy-style and Google-style docstrings,\nand helps ensure compatibility with documentation tooling.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. Sections should be separated by a single blank line.\n\nThis rule is enabled when using the `numpy` and `google` conventions, and\ndisabled when using the `pep257` convention.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D412",
      "name": "blank-lines-between-header-and-content",
      "summary": "Checks for docstring sections that contain blank lines between a section\nheader and a section body.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blank-lines-between-header-and-content/",
      "whyBad": "This rule enforces a consistent style for multiline docstrings.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. There should be no blank lines between a section header\nand a section body.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D413",
      "name": "missing-blank-line-after-last-section",
      "summary": "Checks for missing blank lines after the last section of a multiline\ndocstring.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-blank-line-after-last-section/",
      "whyBad": "This rule enforces a consistent style for multiline docstrings.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, the rule is disabled when using the `google`,\n`numpy`, and `pep257` conventions.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D414",
      "name": "empty-docstring-section",
      "summary": "Checks for docstrings with empty sections.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/empty-docstring-section/",
      "whyBad": "An empty section in a multiline docstring likely indicates an unfinished\nor incomplete docstring.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. Each section body should be non-empty; empty sections\nshould either have content added to them, or be removed entirely.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D415",
      "name": "missing-terminal-punctuation",
      "summary": "Checks for docstrings in which the first line does not end in a punctuation\nmark, such as a period, question mark, or exclamation point.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-terminal-punctuation/",
      "whyBad": "The first line of a docstring should end with a period, question mark, or\nexclamation point, for grammatical correctness and consistency.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google`\nconvention, and disabled when using the `numpy` and `pep257` conventions.",
      "example": "```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```"
    },
    {
      "code": "D416",
      "name": "missing-section-name-colon",
      "summary": "Checks for docstring section headers that do not end with a colon.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-section-name-colon/",
      "whyBad": "This rule enforces a consistent style for multiline Google-style\ndocstrings. If a multiline Google-style docstring consists of multiple\nsections, each section header should end with a colon.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nThis rule is enabled when using the `google` convention, and disabled when\nusing the `pep257` and `numpy` conventions.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns\n        Speed as distance divided by time.\n\n    Raises\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D417",
      "name": "undocumented-param",
      "summary": "Checks for function docstrings that do not include documentation for all\nparameters in the function.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undocumented-param/",
      "whyBad": "This rule helps prevent you from leaving Google-style docstrings unfinished\nor incomplete. Multiline Google-style docstrings should describe all\nparameters for the function they are documenting.\n\nMultiline docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body. Function docstrings often include a section for\nfunction arguments; this rule is concerned with that section only.\nNote that this rule only checks docstrings with an arguments (e.g. `Args`) section.\n\nThis rule is enabled when using the `google` convention, and disabled when\nusing the `pep257` and `numpy` conventions.\n\nParameters annotated with `typing.Unpack` are exempt from this rule.\nThis follows the Python typing specification for unpacking keyword arguments.",
      "example": "```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```"
    },
    {
      "code": "D418",
      "name": "overload-with-docstring",
      "summary": "Checks for `@overload` function definitions that contain a docstring.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/overload-with-docstring/",
      "whyBad": "The `@overload` decorator is used to define multiple compatible signatures\nfor a given function, to support type-checking. A series of `@overload`\ndefinitions should be followed by a single non-decorated definition that\ncontains the implementation of the function.\n\n`@overload` function definitions should not contain a docstring; instead,\nthe docstring should be placed on the non-decorated definition that contains\nthe implementation.",
      "example": "```python\nfrom typing import overload\n\n\n@overload\ndef factorial(n: int) -> int:\n    \"\"\"Return the factorial of n.\"\"\"\n\n\n@overload\ndef factorial(n: float) -> float:\n    \"\"\"Return the factorial of n.\"\"\"\n\n\ndef factorial(n):\n    \"\"\"Return the factorial of n.\"\"\"\n\n\nfactorial.__doc__  # \"Return the factorial of n.\"\n```\n\nUse instead:\n\n```python\nfrom typing import overload\n\n\n@overload\ndef factorial(n: int) -> int: ...\n\n\n@overload\ndef factorial(n: float) -> float: ...\n\n\ndef factorial(n):\n    \"\"\"Return the factorial of n.\"\"\"\n\n\nfactorial.__doc__  # \"Return the factorial of n.\"\n```"
    },
    {
      "code": "D419",
      "name": "empty-docstring",
      "summary": "Checks for empty docstrings.",
      "category": "pydocstyle",
      "categoryCode": "D",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/empty-docstring/",
      "whyBad": "An empty docstring is indicative of incomplete documentation. It should either\nbe removed or replaced with a meaningful docstring.",
      "example": "```python\ndef average(values: list[float]) -> float:\n    \"\"\"\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```"
    },
    {
      "code": "F401",
      "name": "unused-import",
      "summary": "Checks for unused imports.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-import/",
      "whyBad": "Unused imports add a performance overhead at runtime, and risk creating\nimport cycles. They also increase the cognitive load of reading the code.\n\nIf an import statement is used to check for the availability or existence\nof a module, consider using `importlib.util.find_spec` instead.\n\nIf an import statement is used to re-export a symbol as part of a module's\npublic interface, consider using a \"redundant\" import alias, which\ninstructs Ruff (and other tools) to respect the re-export, and avoid\nmarking it as unused, as in:\n\n```python\nfrom module import member as member\n```\n\nAlternatively, you can use `__all__` to declare a symbol as part of the module's\ninterface, as in:\n\n```python\n# __init__.py\nimport some_module\n\n__all__ = [\"some_module\"]\n```",
      "example": "```python\nimport numpy as np  # unused import\n\n\ndef area(radius):\n    return 3.14 * radius**2\n```\n\nUse instead:\n\n```python\ndef area(radius):\n    return 3.14 * radius**2\n```\n\nTo check the availability of a module, use `importlib.util.find_spec`:\n\n```python\nfrom importlib.util import find_spec\n\nif find_spec(\"numpy\") is not None:\n    print(\"numpy is installed\")\nelse:\n    print(\"numpy is not installed\")\n```"
    },
    {
      "code": "F402",
      "name": "import-shadowed-by-loop-var",
      "summary": "Checks for import bindings that are shadowed by loop variables.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/import-shadowed-by-loop-var/",
      "whyBad": "Shadowing an import with loop variables makes the code harder to read and\nreason about, as the identify of the imported binding is no longer clear.\nIt's also often indicative of a mistake, as it's unlikely that the loop\nvariable is intended to be used as the imported binding.\n\nConsider using a different name for the loop variable.",
      "example": "```python\nfrom os import path\n\nfor path in files:\n    print(path)\n```\n\nUse instead:\n```python\nfrom os import path\n\n\nfor filename in files:\n    print(filename)\n```"
    },
    {
      "code": "F403",
      "name": "undefined-local-with-import-star",
      "summary": "Checks for the use of wildcard imports.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undefined-local-with-import-star/",
      "whyBad": "Wildcard imports (e.g., `from module import *`) make it hard to determine\nwhich symbols are available in the current namespace, and from which module\nthey were imported. They're also discouraged by [PEP 8].",
      "example": "```python\nfrom math import *\n\n\ndef area(radius):\n    return pi * radius**2\n```\n\nUse instead:\n```python\nfrom math import pi\n\n\ndef area(radius):\n    return pi * radius**2\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#imports"
    },
    {
      "code": "F404",
      "name": "late-future-import",
      "summary": "Checks for `__future__` imports that are not located at the beginning of a\nfile.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/late-future-import/",
      "whyBad": "Imports from `__future__` must be placed the beginning of the file, before any\nother statements (apart from docstrings). The use of `__future__` imports\nelsewhere is invalid and will result in a `SyntaxError`.",
      "example": "```python\nfrom pathlib import Path\n\nfrom __future__ import annotations\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom pathlib import Path\n```"
    },
    {
      "code": "F405",
      "name": "undefined-local-with-import-star-usage",
      "summary": "Checks for names that might be undefined, but may also be defined in a\nwildcard import.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undefined-local-with-import-star-usage/",
      "whyBad": "Wildcard imports (e.g., `from module import *`) make it hard to determine\nwhich symbols are available in the current namespace. If a module contains\na wildcard import, and a name in the current namespace has not been\nexplicitly defined or imported, then it's unclear whether the name is\nundefined or was imported by the wildcard import.\n\nIf the name _is_ defined in via a wildcard import, that member should be\nimported explicitly to avoid confusion.\n\nIf the name is _not_ defined in a wildcard import, it should be defined or\nimported.",
      "example": "```python\nfrom math import *\n\n\ndef area(radius):\n    return pi * radius**2\n```\n\nUse instead:\n```python\nfrom math import pi\n\n\ndef area(radius):\n    return pi * radius**2\n```"
    },
    {
      "code": "F406",
      "name": "undefined-local-with-nested-import-star-usage",
      "summary": "Check for the use of wildcard imports outside of the module namespace.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undefined-local-with-nested-import-star-usage/",
      "whyBad": "The use of wildcard imports outside of the module namespace (e.g., within\nfunctions) can lead to confusion, as the import can shadow local variables.\n\nThough wildcard imports are discouraged by [PEP 8], when necessary, they\nshould be placed in the module namespace (i.e., at the top-level of a\nmodule).",
      "example": "```python\ndef foo():\n    from math import *\n```\n\nUse instead:\n\n```python\nfrom math import *\n\n\ndef foo(): ...\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#imports"
    },
    {
      "code": "F407",
      "name": "future-feature-not-defined",
      "summary": "Checks for `__future__` imports that are not defined in the current Python\nversion.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/future-feature-not-defined/",
      "whyBad": "Importing undefined or unsupported members from the `__future__` module is\na `SyntaxError`."
    },
    {
      "code": "F501",
      "name": "percent-format-invalid-format",
      "summary": "Checks for invalid `printf`-style format strings.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-invalid-format/",
      "whyBad": "Conversion specifiers are required for `printf`-style format strings. These\nspecifiers must contain a `%` character followed by a conversion type.",
      "example": "```python\n\"Hello, %\" % \"world\"\n```\n\nUse instead:\n```python\n\"Hello, %s\" % \"world\"\n```"
    },
    {
      "code": "F502",
      "name": "percent-format-expected-mapping",
      "summary": "Checks for named placeholders in `printf`-style format strings without\nmapping-type values.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-expected-mapping/",
      "whyBad": "When using named placeholders in `printf`-style format strings, the values\nmust be a map type (such as a dictionary). Otherwise, the expression will\nraise a `TypeError`.",
      "example": "```python\n\"%(greeting)s, %(name)s\" % (\"Hello\", \"World\")\n```\n\nUse instead:\n```python\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\nOr:\n```python\n\"%s, %s\" % (\"Hello\", \"World\")\n```"
    },
    {
      "code": "F503",
      "name": "percent-format-expected-sequence",
      "summary": "Checks for uses of mapping-type values in `printf`-style format strings\nwithout named placeholders.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-expected-sequence/",
      "whyBad": "When using mapping-type values (such as `dict`) in `printf`-style format\nstrings, the keys must be named. Otherwise, the expression will raise a\n`TypeError`.",
      "example": "```python\n\"%s, %s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\nUse instead:\n```python\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\nOr:\n```python\n\"%s, %s\" % (\"Hello\", \"World\")\n```"
    },
    {
      "code": "F504",
      "name": "percent-format-extra-named-arguments",
      "summary": "Checks for unused mapping keys in `printf`-style format strings.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-extra-named-arguments/",
      "whyBad": "Unused named placeholders in `printf`-style format strings are unnecessary,\nand likely indicative of a mistake. They should be removed.",
      "example": "```python\n\"Hello, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\nUse instead:\n```python\n\"Hello, %(name)s\" % {\"name\": \"World\"}\n```"
    },
    {
      "code": "F505",
      "name": "percent-format-missing-argument",
      "summary": "Checks for named placeholders in `printf`-style format strings that are not\npresent in the provided mapping.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-missing-argument/",
      "whyBad": "Named placeholders that lack a corresponding value in the provided mapping\nwill raise a `KeyError`.",
      "example": "```python\n\"%(greeting)s, %(name)s\" % {\"name\": \"world\"}\n```\n\nUse instead:\n```python\n\"Hello, %(name)s\" % {\"name\": \"world\"}\n```"
    },
    {
      "code": "F506",
      "name": "percent-format-mixed-positional-and-named",
      "summary": "Checks for `printf`-style format strings that have mixed positional and\nnamed placeholders.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-mixed-positional-and-named/",
      "whyBad": "Python does not support mixing positional and named placeholders in\n`printf`-style format strings. The use of mixed placeholders will raise a\n`TypeError` at runtime.",
      "example": "```python\n\"%s, %(name)s\" % (\"Hello\", {\"name\": \"World\"})\n```\n\nUse instead:\n```python\n\"%s, %s\" % (\"Hello\", \"World\")\n```\n\nOr:\n```python\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```"
    },
    {
      "code": "F507",
      "name": "percent-format-positional-count-mismatch",
      "summary": "Checks for `printf`-style format strings that have a mismatch between the\nnumber of positional placeholders and the number of substitution values.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-positional-count-mismatch/",
      "whyBad": "When a `printf`-style format string is provided with too many or too few\nsubstitution values, it will raise a `TypeError` at runtime.",
      "example": "```python\n\"%s, %s\" % (\"Hello\", \"world\", \"!\")\n```\n\nUse instead:\n```python\n\"%s, %s\" % (\"Hello\", \"world\")\n```"
    },
    {
      "code": "F508",
      "name": "percent-format-star-requires-sequence",
      "summary": "Checks for `printf`-style format strings that use the `*` specifier with\nnon-tuple values.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-star-requires-sequence/",
      "whyBad": "The use of the `*` specifier with non-tuple values will raise a\n`TypeError` at runtime.",
      "example": "```python\nfrom math import pi\n\n\"%(n).*f\" % {\"n\": (2, pi)}\n```\n\nUse instead:\n```python\nfrom math import pi\n\n\"%.*f\" % (2, pi)  # 3.14\n```"
    },
    {
      "code": "F509",
      "name": "percent-format-unsupported-format-character",
      "summary": "Checks for `printf`-style format strings with invalid format characters.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/percent-format-unsupported-format-character/",
      "whyBad": "In `printf`-style format strings, the `%` character is used to indicate\nplaceholders. If a `%` character is not followed by a valid format\ncharacter, it will raise a `ValueError` at runtime.",
      "example": "```python\n\"Hello, %S\" % \"world\"\n```\n\nUse instead:\n```python\n\"Hello, %s\" % \"world\"\n```"
    },
    {
      "code": "F521",
      "name": "string-dot-format-invalid-format",
      "summary": "Checks for `str.format` calls with invalid format strings.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/string-dot-format-invalid-format/",
      "whyBad": "Invalid format strings will raise a `ValueError`.",
      "example": "```python\n\"{\".format(foo)\n```\n\nUse instead:\n```python\n\"{}\".format(foo)\n```"
    },
    {
      "code": "F522",
      "name": "string-dot-format-extra-named-arguments",
      "summary": "Checks for `str.format` calls with unused keyword arguments.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/string-dot-format-extra-named-arguments/",
      "whyBad": "Unused keyword arguments are redundant, and often indicative of a mistake.\nThey should be removed.",
      "example": "```python\n\"Hello, {name}\".format(greeting=\"Hello\", name=\"World\")\n```\n\nUse instead:\n```python\n\"Hello, {name}\".format(name=\"World\")\n```"
    },
    {
      "code": "F523",
      "name": "string-dot-format-extra-positional-arguments",
      "summary": "Checks for `str.format` calls with unused positional arguments.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/string-dot-format-extra-positional-arguments/",
      "whyBad": "Unused positional arguments are redundant, and often indicative of a mistake.\nThey should be removed.",
      "example": "```python\n\"Hello, {0}\".format(\"world\", \"!\")\n```\n\nUse instead:\n```python\n\"Hello, {0}\".format(\"world\")\n```"
    },
    {
      "code": "F524",
      "name": "string-dot-format-missing-arguments",
      "summary": "Checks for `str.format` calls with placeholders that are missing arguments.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/string-dot-format-missing-arguments/",
      "whyBad": "In `str.format` calls, omitting arguments for placeholders will raise a\n`KeyError` at runtime.",
      "example": "```python\n\"{greeting}, {name}\".format(name=\"World\")\n```\n\nUse instead:\n```python\n\"{greeting}, {name}\".format(greeting=\"Hello\", name=\"World\")\n```"
    },
    {
      "code": "F525",
      "name": "string-dot-format-mixing-automatic",
      "summary": "Checks for `str.format` calls that mix automatic and manual numbering.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/string-dot-format-mixing-automatic/",
      "whyBad": "In `str.format` calls, mixing automatic and manual numbering will raise a\n`ValueError` at runtime.",
      "example": "```python\n\"{0}, {}\".format(\"Hello\", \"World\")\n```\n\nUse instead:\n```python\n\"{0}, {1}\".format(\"Hello\", \"World\")\n```\n\nOr:\n```python\n\"{}, {}\".format(\"Hello\", \"World\")\n```"
    },
    {
      "code": "F541",
      "name": "f-string-missing-placeholders",
      "summary": "Checks for f-strings that do not contain any placeholder expressions.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/f-string-missing-placeholders/",
      "whyBad": "f-strings are a convenient way to format strings, but they are not\nnecessary if there are no placeholder expressions to format. In this\ncase, a regular string should be used instead, as an f-string without\nplaceholders can be confusing for readers, who may expect such a\nplaceholder to be present.\n\nAn f-string without any placeholders could also indicate that the\nauthor forgot to add a placeholder expression.",
      "example": "```python\nf\"Hello, world!\"\n```\n\nUse instead:\n```python\n\"Hello, world!\"\n```\n\n**Note:** to maintain compatibility with PyFlakes, this rule only flags\nf-strings that are part of an implicit concatenation if _none_ of the\nf-string segments contain placeholder expressions.\n\nFor example:\n\n```python\n# Will not be flagged.\n(\n    f\"Hello,\"\n    f\" {name}!\"\n)\n\n# Will be flagged.\n(\n    f\"Hello,\"\n    f\" World!\"\n)\n```\n\nSee [#10885](https://github.com/astral-sh/ruff/issues/10885) for more."
    },
    {
      "code": "F601",
      "name": "multi-value-repeated-key-literal",
      "summary": "Checks for dictionary literals that associate multiple values with the\nsame key.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multi-value-repeated-key-literal/",
      "whyBad": "Dictionary keys should be unique. If a key is associated with multiple values,\nthe earlier values will be overwritten. Including multiple values for the\nsame key in a dictionary literal is likely a mistake.",
      "example": "```python\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n    \"baz\": 3,\n}\nfoo[\"baz\"]  # 3\n```\n\nUse instead:\n```python\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n}\nfoo[\"baz\"]  # 2\n```"
    },
    {
      "code": "F602",
      "name": "multi-value-repeated-key-variable",
      "summary": "Checks for dictionary keys that are repeated with different values.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multi-value-repeated-key-variable/",
      "whyBad": "Dictionary keys should be unique. If a key is repeated with a different\nvalue, the first values will be overwritten and the key will correspond to\nthe last value. This is likely a mistake.",
      "example": "```python\nfoo = {\n    bar: 1,\n    baz: 2,\n    baz: 3,\n}\nfoo[baz]  # 3\n```\n\nUse instead:\n```python\nfoo = {\n    bar: 1,\n    baz: 2,\n}\nfoo[baz]  # 2\n```"
    },
    {
      "code": "F621",
      "name": "expressions-in-star-assignment",
      "summary": "Checks for the use of too many expressions in starred assignment statements.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/expressions-in-star-assignment/",
      "whyBad": "In assignment statements, starred expressions can be used to unpack iterables.\n\nIn Python 3, no more than `1 << 8` assignments are allowed before a starred\nexpression, and no more than `1 << 24` expressions are allowed after a starred\nexpression."
    },
    {
      "code": "F622",
      "name": "multiple-starred-expressions",
      "summary": "Checks for the use of multiple starred expressions in assignment statements.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/multiple-starred-expressions/",
      "whyBad": "In assignment statements, starred expressions can be used to unpack iterables.\nIncluding more than one starred expression on the left-hand-side of an\nassignment will cause a `SyntaxError`, as it is unclear which expression\nshould receive the remaining values.",
      "example": "```python\n*foo, *bar, baz = (1, 2, 3)\n```"
    },
    {
      "code": "F631",
      "name": "assert-tuple",
      "summary": "Checks for `assert` statements that use non-empty tuples as test\nconditions.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assert-tuple/",
      "whyBad": "Non-empty tuples are always `True`, so an `assert` statement with a\nnon-empty tuple as its test condition will always pass. This is likely a\nmistake.",
      "example": "```python\nassert (some_condition,)\n```\n\nUse instead:\n```python\nassert some_condition\n```"
    },
    {
      "code": "F632",
      "name": "is-literal",
      "summary": "Checks for `is` and `is not` comparisons against literals, like integers,\nstrings, or lists.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/is-literal/",
      "whyBad": "The `is` and `is not` comparators operate on identity, in that they check\nwhether two objects are the same object. If the objects are not the same\nobject, the comparison will always be `False`. Using `is` and `is not` with\nconstant literals often works \"by accident\", but are not guaranteed to produce\nthe expected result.\n\nAs of Python 3.8, using `is` and `is not` with constant literals will produce\na `SyntaxWarning`.\n\nThis rule will also flag `is` and `is not` comparisons against non-constant\nliterals, like lists, sets, and dictionaries. While such comparisons will\nnot raise a `SyntaxWarning`, they are still likely to be incorrect, as they\nwill compare the identities of the objects instead of their values, which\nwill always evaluate to `False`.\n\nInstead, use `==` and `!=` to compare literals, which will compare the\nvalues of the objects instead of their identities.",
      "example": "```python\nx = 200\nif x is 200:\n    print(\"It's 200!\")\n```\n\nUse instead:\n```python\nx = 200\nif x == 200:\n    print(\"It's 200!\")\n```"
    },
    {
      "code": "F633",
      "name": "invalid-print-syntax",
      "summary": "Checks for `print` statements that use the `>>` syntax.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-print-syntax/",
      "whyBad": "In Python 2, the `print` statement can be used with the `>>` syntax to\nprint to a file-like object. This `print >> sys.stderr` syntax no\nlonger exists in Python 3, where `print` is only a function, not a\nstatement.\n\nInstead, use the `file` keyword argument to the `print` function, the\n`sys.stderr.write` function, or the `logging` module.",
      "example": "```python\nfrom __future__ import print_function\nimport sys\n\nprint >> sys.stderr, \"Hello, world!\"\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\", file=sys.stderr)\n```\n\nOr:\n```python\nimport sys\n\nsys.stderr.write(\"Hello, world!\\n\")\n```\n\nOr:\n```python\nimport logging\n\nlogging.error(\"Hello, world!\")\n```"
    },
    {
      "code": "F634",
      "name": "if-tuple",
      "summary": "Checks for `if` statements that use non-empty tuples as test conditions.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-tuple/",
      "whyBad": "Non-empty tuples are always `True`, so an `if` statement with a non-empty\ntuple as its test condition will always pass. This is likely a mistake.",
      "example": "```python\nif (False,):\n    print(\"This will always run\")\n```\n\nUse instead:\n```python\nif False:\n    print(\"This will never run\")\n```"
    },
    {
      "code": "F701",
      "name": "break-outside-loop",
      "summary": "Checks for `break` statements outside of loops.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/break-outside-loop/",
      "whyBad": "The use of a `break` statement outside of a `for` or `while` loop will\nraise a `SyntaxError`.",
      "example": "```python\ndef foo():\n    break\n```"
    },
    {
      "code": "F702",
      "name": "continue-outside-loop",
      "summary": "Checks for `continue` statements outside of loops.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/continue-outside-loop/",
      "whyBad": "The use of a `continue` statement outside of a `for` or `while` loop will\nraise a `SyntaxError`.",
      "example": "```python\ndef foo():\n    continue  # SyntaxError\n```"
    },
    {
      "code": "F704",
      "name": "yield-outside-function",
      "summary": "Checks for `yield`, `yield from`, and `await` usages outside of functions.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/yield-outside-function/",
      "whyBad": "The use of `yield`, `yield from`, or `await` outside of a function will\nraise a `SyntaxError`.",
      "example": "```python\nclass Foo:\n    yield 1\n```"
    },
    {
      "code": "F706",
      "name": "return-outside-function",
      "summary": "Checks for `return` statements outside of functions.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/return-outside-function/",
      "whyBad": "The use of a `return` statement outside of a function will raise a\n`SyntaxError`.",
      "example": "```python\nclass Foo:\n    return 1\n```"
    },
    {
      "code": "F707",
      "name": "default-except-not-last",
      "summary": "Checks for `except` blocks that handle all exceptions, but are not the last\n`except` block in a `try` statement.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/default-except-not-last/",
      "whyBad": "When an exception is raised within a `try` block, the `except` blocks are\nevaluated in order, and the first matching block is executed. If an `except`\nblock handles all exceptions, but isn't the last block, Python will raise a\n`SyntaxError`, as the following blocks would never be executed.",
      "example": "```python\ndef reciprocal(n):\n    try:\n        reciprocal = 1 / n\n    except:\n        print(\"An exception occurred.\")\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero.\")\n    else:\n        return reciprocal\n```\n\nUse instead:\n```python\ndef reciprocal(n):\n    try:\n        reciprocal = 1 / n\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero.\")\n    except:\n        print(\"An exception occurred.\")\n    else:\n        return reciprocal\n```"
    },
    {
      "code": "F722",
      "name": "forward-annotation-syntax-error",
      "summary": "Checks for forward annotations that include invalid syntax.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/forward-annotation-syntax-error/",
      "whyBad": "In Python, type annotations can be quoted as strings literals to enable\nreferences to types that have not yet been defined, known as \"forward\nreferences\".\n\nHowever, these quoted annotations must be valid Python expressions. The use\nof invalid syntax in a quoted annotation won't raise a `SyntaxError`, but\nwill instead raise an error when type checking is performed.",
      "example": "```python\ndef foo() -> \"/\": ...\n```"
    },
    {
      "code": "F811",
      "name": "redefined-while-unused",
      "summary": "Checks for variable definitions that redefine (or \"shadow\") unused\nvariables.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redefined-while-unused/",
      "whyBad": "Redefinitions of unused names are unnecessary and often indicative of a\nmistake.",
      "example": "```python\nimport foo\nimport bar\nimport foo  # Redefinition of unused `foo` from line 1\n```\n\nUse instead:\n```python\nimport foo\nimport bar\n```"
    },
    {
      "code": "F821",
      "name": "undefined-name",
      "summary": "Checks for uses of undefined names.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undefined-name/",
      "whyBad": "An undefined name is likely to raise `NameError` at runtime.",
      "example": "```python\ndef double():\n    return n * 2  # raises `NameError` if `n` is undefined when `double` is called\n```\n\nUse instead:\n```python\ndef double(n):\n    return n * 2\n```"
    },
    {
      "code": "F822",
      "name": "undefined-export",
      "summary": "Checks for undefined names in `__all__`.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undefined-export/",
      "whyBad": "In Python, the `__all__` variable is used to define the names that are\nexported when a module is imported as a wildcard (e.g.,\n`from foo import *`). The names in `__all__` must be defined in the module,\nbut are included as strings.\n\nIncluding an undefined name in `__all__` is likely to raise `NameError` at\nruntime, when the module is imported.\n\nIn [preview], this rule will flag undefined names in `__init__.py` file,\neven if those names implicitly refer to other modules in the package. Users\nthat rely on implicit exports should disable this rule in `__init__.py`\nfiles via [`lint.per-file-ignores`].",
      "example": "```python\nfrom foo import bar\n\n\n__all__ = [\"bar\", \"baz\"]  # undefined name `baz` in `__all__`\n```\n\nUse instead:\n```python\nfrom foo import bar, baz\n\n\n__all__ = [\"bar\", \"baz\"]\n```"
    },
    {
      "code": "F823",
      "name": "undefined-local",
      "summary": "Checks for undefined local variables.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/undefined-local/",
      "whyBad": "Referencing a local variable before it has been assigned will raise\nan `UnboundLocalError` at runtime.",
      "example": "```python\nx = 1\n\n\ndef foo():\n    x += 1\n```\n\nUse instead:\n```python\nx = 1\n\n\ndef foo():\n    global x\n    x += 1\n```"
    },
    {
      "code": "F841",
      "name": "unused-variable",
      "summary": "Checks for the presence of unused variables in function scopes.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-variable/",
      "whyBad": "A variable that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\n[`lint.dummy-variable-rgx`] pattern.",
      "example": "```python\ndef foo():\n    x = 1\n    y = 2\n    return x\n```\n\nUse instead:\n```python\ndef foo():\n    x = 1\n    return x\n```"
    },
    {
      "code": "F842",
      "name": "unused-annotation",
      "summary": "Checks for local variables that are annotated but never used.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-annotation/",
      "whyBad": "Annotations are used to provide type hints to static type checkers. If a\nvariable is annotated but never used, the annotation is unnecessary.",
      "example": "```python\ndef foo():\n    bar: int\n```"
    },
    {
      "code": "F901",
      "name": "raise-not-implemented",
      "summary": "Checks for `raise` statements that raise `NotImplemented`.",
      "category": "Pyflakes",
      "categoryCode": "F",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/raise-not-implemented/",
      "whyBad": "`NotImplemented` is an exception used by binary special methods to indicate\nthat an operation is not implemented with respect to a particular type.\n\n`NotImplemented` should not be raised directly. Instead, raise\n`NotImplementedError`, which is used to indicate that the method is\nabstract or not implemented in the derived class.",
      "example": "```python\nclass Foo:\n    def bar(self):\n        raise NotImplemented\n```\n\nUse instead:\n```python\nclass Foo:\n    def bar(self):\n        raise NotImplementedError\n```"
    },
    {
      "code": "PGH001",
      "name": "eval",
      "summary": "Checks for uses of the builtin `eval()` function.",
      "category": "pygrep-hooks",
      "categoryCode": "PGH",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/eval/",
      "whyBad": "The `eval()` function is insecure as it enables arbitrary code execution.",
      "example": "```python\ndef foo():\n    x = eval(input(\"Enter a number: \"))\n    ...\n```\n\nUse instead:\n```python\ndef foo():\n    x = input(\"Enter a number: \")\n    ...\n```"
    },
    {
      "code": "PGH002",
      "name": "deprecated-log-warn",
      "summary": "Check for usages of the deprecated `warn` method from the `logging` module.",
      "category": "pygrep-hooks",
      "categoryCode": "PGH",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/deprecated-log-warn/",
      "whyBad": "The `warn` method is deprecated. Use `warning` instead.",
      "example": "```python\nimport logging\n\n\ndef foo():\n    logging.warn(\"Something happened\")\n```\n\nUse instead:\n```python\nimport logging\n\n\ndef foo():\n    logging.warning(\"Something happened\")\n```"
    },
    {
      "code": "PGH003",
      "name": "blanket-type-ignore",
      "summary": "Check for `type: ignore` annotations that suppress all type warnings, as\nopposed to targeting specific type warnings.",
      "category": "pygrep-hooks",
      "categoryCode": "PGH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blanket-type-ignore/",
      "whyBad": "Suppressing all warnings can hide issues in the code.\n\nBlanket `type: ignore` annotations are also more difficult to interpret and\nmaintain, as the annotation does not clarify which warnings are intended\nto be suppressed.",
      "example": "```python\nfrom foo import secrets  # type: ignore\n```\n\nUse instead:\n```python\nfrom foo import secrets  # type: ignore[attr-defined]\n```"
    },
    {
      "code": "PGH004",
      "name": "blanket-noqa",
      "summary": "Check for `noqa` annotations that suppress all diagnostics, as opposed to\ntargeting specific diagnostics.",
      "category": "pygrep-hooks",
      "categoryCode": "PGH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/blanket-noqa/",
      "whyBad": "Suppressing all diagnostics can hide issues in the code.\n\nBlanket `noqa` annotations are also more difficult to interpret and\nmaintain, as the annotation does not clarify which diagnostics are intended\nto be suppressed.",
      "example": "```python\nfrom .base import *  # noqa\n```\n\nUse instead:\n```python\nfrom .base import *  # noqa: F403\n```"
    },
    {
      "code": "PGH005",
      "name": "invalid-mock-access",
      "summary": "Checks for common mistakes when using mock objects.",
      "category": "pygrep-hooks",
      "categoryCode": "PGH",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-mock-access/",
      "whyBad": "The `mock` module exposes an assertion API that can be used to verify that\nmock objects undergo expected interactions. This rule checks for common\nmistakes when using this API.\n\nFor example, it checks for mock attribute accesses that should be replaced\nwith mock method calls.",
      "example": "```python\nmy_mock.assert_called\n```\n\nUse instead:\n```python\nmy_mock.assert_called()\n```"
    },
    {
      "code": "PLC0105",
      "name": "type-name-incorrect-variance",
      "summary": "Checks for type names that do not match the variance of their associated\ntype parameter.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-name-incorrect-variance/",
      "whyBad": "[PEP 484] recommends the use of the `_co` and `_contra` suffixes for\ncovariant and contravariant type parameters, respectively (while invariant\ntype parameters should not have any such suffix).",
      "example": "```python\nfrom typing import TypeVar\n\nT = TypeVar(\"T\", covariant=True)\nU = TypeVar(\"U\", contravariant=True)\nV_co = TypeVar(\"V_co\")\n```\n\nUse instead:\n```python\nfrom typing import TypeVar\n\nT_co = TypeVar(\"T_co\", covariant=True)\nU_contra = TypeVar(\"U_contra\", contravariant=True)\nV = TypeVar(\"V\")\n```"
    },
    {
      "code": "PLC0131",
      "name": "type-bivariance",
      "summary": "Checks for `TypeVar` and `ParamSpec` definitions in which the type is\nboth covariant and contravariant.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-bivariance/",
      "whyBad": "By default, Python's generic types are invariant, but can be marked as\neither covariant or contravariant via the `covariant` and `contravariant`\nkeyword arguments. While the API does allow you to mark a type as both\ncovariant and contravariant, this is not supported by the type system,\nand should be avoided.\n\nInstead, change the variance of the type to be either covariant,\ncontravariant, or invariant. If you want to describe both covariance and\ncontravariance, consider using two separate type parameters.\n\nFor context: an \"invariant\" generic type only accepts values that exactly\nmatch the type parameter; for example, `list[Dog]` accepts only `list[Dog]`,\nnot `list[Animal]` (superclass) or `list[Bulldog]` (subclass). This is\nthe default behavior for Python's generic types.\n\nA \"covariant\" generic type accepts subclasses of the type parameter; for\nexample, `Sequence[Animal]` accepts `Sequence[Dog]`. A \"contravariant\"\ngeneric type accepts superclasses of the type parameter; for example,\n`Callable[Dog]` accepts `Callable[Animal]`.",
      "example": "```python\nfrom typing import TypeVar\n\nT = TypeVar(\"T\", covariant=True, contravariant=True)\n```\n\nUse instead:\n```python\nfrom typing import TypeVar\n\nT_co = TypeVar(\"T_co\", covariant=True)\nT_contra = TypeVar(\"T_contra\", contravariant=True)\n```"
    },
    {
      "code": "PLC0132",
      "name": "type-param-name-mismatch",
      "summary": "Checks for `TypeVar`, `TypeVarTuple`, `ParamSpec`, and `NewType`\ndefinitions in which the name of the type parameter does not match the name\nof the variable to which it is assigned.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-param-name-mismatch/",
      "whyBad": "When defining a `TypeVar` or a related type parameter, Python allows you to\nprovide a name for the type parameter. According to [PEP 484], the name\nprovided to the `TypeVar` constructor must be equal to the name of the\nvariable to which it is assigned.",
      "example": "```python\nfrom typing import TypeVar\n\nT = TypeVar(\"U\")\n```\n\nUse instead:\n```python\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n```"
    },
    {
      "code": "PLC0205",
      "name": "single-string-slots",
      "summary": "Checks for single strings assigned to `__slots__`.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/single-string-slots/",
      "whyBad": "In Python, the `__slots__` attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when `__slots__` is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\nAny string iterable may be assigned to `__slots__` (most commonly, a\n`tuple` of strings). If a string is assigned to `__slots__`, it is\ninterpreted as a single attribute name, rather than an iterable of attribute\nnames. This can cause confusion, as users that iterate over the `__slots__`\nvalue may expect to iterate over a sequence of attributes, but would instead\niterate over the characters of the string.\n\nTo use a single string attribute in `__slots__`, wrap the string in an\niterable container type, like a `tuple`.",
      "example": "```python\nclass Person:\n    __slots__: str = \"name\"\n\n    def __init__(self, name: str) -> None:\n        self.name = name\n```\n\nUse instead:\n```python\nclass Person:\n    __slots__: tuple[str, ...] = (\"name\",)\n\n    def __init__(self, name: str) -> None:\n        self.name = name\n```"
    },
    {
      "code": "PLC0206",
      "name": "dict-index-missing-items",
      "summary": "Checks for dictionary iterations that extract the dictionary value\nvia explicit indexing, instead of using `.items()`.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/dict-index-missing-items/",
      "whyBad": "Iterating over a dictionary with `.items()` is semantically clearer\nand more efficient than extracting the value with the key.",
      "example": "```python\nORCHESTRA = {\n    \"violin\": \"strings\",\n    \"oboe\": \"woodwind\",\n    \"tuba\": \"brass\",\n    \"gong\": \"percussion\",\n}\n\nfor instrument in ORCHESTRA:\n    print(f\"{instrument}: {ORCHESTRA[instrument]}\")\n```\n\nUse instead:\n```python\nORCHESTRA = {\n    \"violin\": \"strings\",\n    \"oboe\": \"woodwind\",\n    \"tuba\": \"brass\",\n    \"gong\": \"percussion\",\n}\n\nfor instrument, section in ORCHESTRA.items():\n    print(f\"{instrument}: {section}\")\n```"
    },
    {
      "code": "PLC0207",
      "name": "missing-maxsplit-arg",
      "summary": "Checks for access to the first or last element of `str.split()` or `str.rsplit()` without\n`maxsplit=1`",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-maxsplit-arg/",
      "whyBad": "Calling `str.split()` or `str.rsplit()` without passing `maxsplit=1` splits on every delimiter in the\nstring. When accessing only the first or last element of the result, it\nwould be more efficient to only split once.",
      "example": "```python\nurl = \"www.example.com\"\nprefix = url.split(\".\")[0]\n```\n\nUse instead:\n```python\nurl = \"www.example.com\"\nprefix = url.split(\".\", maxsplit=1)[0]\n```\n\nTo access the last element, use `str.rsplit()` instead of `str.split()`:\n```python\nurl = \"www.example.com\"\nsuffix = url.rsplit(\".\", maxsplit=1)[-1]\n```"
    },
    {
      "code": "PLC0208",
      "name": "iteration-over-set",
      "summary": "Checks for iteration over a `set` literal where each element in the set is\nitself a literal value.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/iteration-over-set/",
      "whyBad": "Iterating over a `set` is less efficient than iterating over a sequence\ntype, like `list` or `tuple`.",
      "example": "```python\nfor number in {1, 2, 3}:\n    ...\n```\n\nUse instead:\n```python\nfor number in (1, 2, 3):\n    ...\n```"
    },
    {
      "code": "PLC0414",
      "name": "useless-import-alias",
      "summary": "Checks for import aliases that do not rename the original package.\nThis rule does not apply in `__init__.py` files.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-import-alias/",
      "whyBad": "The import alias is redundant and should be removed to avoid confusion.",
      "example": "```python\nimport numpy as numpy\n```\n\nUse instead:\n```python\nimport numpy as np\n```\n\nor\n\n```python\nimport numpy\n```"
    },
    {
      "code": "PLC0415",
      "name": "import-outside-top-level",
      "summary": "Checks for `import` statements outside of a module's top-level scope, such\nas within a function or class definition.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/import-outside-top-level/",
      "whyBad": "[PEP 8] recommends placing imports not only at the top-level of a module,\nbut at the very top of the file, \"just after any module comments and\ndocstrings, and before module globals and constants.\"\n\n`import` statements have effects that are global in scope; defining them at\nthe top level has a number of benefits. For example, it makes it easier to\nidentify the dependencies of a module, and ensures that any invalid imports\nare caught regardless of whether a specific function is called or class is\ninstantiated.\n\nAn import statement would typically be placed within a function only to\navoid a circular dependency, to defer a costly module load, or to avoid\nloading a dependency altogether in a certain runtime environment.",
      "example": "```python\ndef print_python_version():\n    import platform\n\n    print(platform.python_version())\n```\n\nUse instead:\n```python\nimport platform\n\n\ndef print_python_version():\n    print(platform.python_version())\n```"
    },
    {
      "code": "PLC1802",
      "name": "len-test",
      "summary": "Checks for `len` calls on sequences in a boolean test context.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/len-test/",
      "whyBad": "Empty sequences are considered false in a boolean context.\nYou can either remove the call to `len`\nor compare the length against a scalar.",
      "example": "```python\nfruits = [\"orange\", \"apple\"]\nvegetables = []\n\nif len(fruits):\n    print(fruits)\n\nif not len(vegetables):\n    print(vegetables)\n```\n\nUse instead:\n```python\nfruits = [\"orange\", \"apple\"]\nvegetables = []\n\nif fruits:\n    print(fruits)\n\nif not vegetables:\n    print(vegetables)\n```"
    },
    {
      "code": "PLC1901",
      "name": "compare-to-empty-string",
      "summary": "Checks for comparisons to empty strings.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/compare-to-empty-string/",
      "whyBad": "An empty string is falsy, so it is unnecessary to compare it to `\"\"`. If\nthe value can be something else Python considers falsy, such as `None`,\n`0`, or another empty container, then the code is not equivalent.",
      "example": "```python\nx: str = ...\n\nif x == \"\":\n    print(\"x is empty\")\n```\n\nUse instead:\n```python\nx: str = ...\n\nif not x:\n    print(\"x is empty\")\n```"
    },
    {
      "code": "PLC2401",
      "name": "non-ascii-name",
      "summary": "Checks for the use of non-ASCII characters in variable names.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-ascii-name/",
      "whyBad": "The use of non-ASCII characters in variable names can cause confusion\nand compatibility issues (see: [PEP 672]).",
      "example": "```python\npple_count: int\n```\n\nUse instead:\n```python\napple_count: int\n```\n\n[PEP 672]: https://peps.python.org/pep-0672/"
    },
    {
      "code": "PLC2403",
      "name": "non-ascii-import-name",
      "summary": "Checks for the use of non-ASCII characters in import statements.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-ascii-import-name/",
      "whyBad": "The use of non-ASCII characters in import statements can cause confusion\nand compatibility issues (see: [PEP 672]).",
      "example": "```python\nimport br\n```\n\nUse instead:\n```python\nimport bar\n```\n\nIf the module is third-party, use an ASCII-only alias:\n```python\nimport br as bar\n```\n\n[PEP 672]: https://peps.python.org/pep-0672/"
    },
    {
      "code": "PLC2701",
      "name": "import-private-name",
      "summary": "Checks for import statements that import a private name (a name starting\nwith an underscore `_`) from another module.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/import-private-name/",
      "whyBad": "[PEP 8] states that names starting with an underscore are private. Thus,\nthey are not intended to be used outside of the module in which they are\ndefined.\n\nFurther, as private imports are not considered part of the public API, they\nare prone to unexpected changes, especially outside of semantic versioning.\n\nInstead, consider using the public API of the module.\n\nThis rule ignores private name imports that are exclusively used in type\nannotations. Ideally, types would be public; however, this is not always\npossible when using third-party libraries.",
      "example": "```python\nfrom foo import _bar\n```"
    },
    {
      "code": "PLC2801",
      "name": "unnecessary-dunder-call",
      "summary": "Checks for explicit use of dunder methods, like `__str__` and `__add__`.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-dunder-call/",
      "whyBad": "Dunder names are not meant to be called explicitly and, in most cases, can\nbe replaced with builtins or operators.",
      "example": "```python\nthree = (3.0).__str__()\ntwelve = \"1\".__add__(\"2\")\n\n\ndef is_greater_than_two(x: int) -> bool:\n    return x.__gt__(2)\n```\n\nUse instead:\n```python\nthree = str(3.0)\ntwelve = \"1\" + \"2\"\n\n\ndef is_greater_than_two(x: int) -> bool:\n    return x > 2\n```"
    },
    {
      "code": "PLC3002",
      "name": "unnecessary-direct-lambda-call",
      "summary": "Checks for unnecessary direct calls to lambda expressions.",
      "category": "Pylint",
      "categoryCode": "PLC",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-direct-lambda-call/",
      "whyBad": "Calling a lambda expression directly is unnecessary. The expression can be\nexecuted inline instead to improve readability.",
      "example": "```python\narea = (lambda r: 3.14 * r**2)(radius)\n```\n\nUse instead:\n```python\narea = 3.14 * radius**2\n```"
    },
    {
      "code": "PLE0100",
      "name": "yield-in-init",
      "summary": "Checks for `__init__` methods that are turned into generators by the\ninclusion of `yield` or `yield from` expressions.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/yield-in-init/",
      "whyBad": "The `__init__` method is the constructor for a given Python class,\nresponsible for initializing, rather than creating, new objects.\n\nThe `__init__` method has to return `None`. By including a `yield` or\n`yield from` expression in an `__init__`, the method will return a\ngenerator object when called at runtime, resulting in a runtime error.",
      "example": "```python\nclass InitIsGenerator:\n    def __init__(self, i):\n        yield i\n```"
    },
    {
      "code": "PLE0101",
      "name": "return-in-init",
      "summary": "Checks for `__init__` methods that return values.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/return-in-init/",
      "whyBad": "The `__init__` method is the constructor for a given Python class,\nresponsible for initializing, rather than creating, new objects.\n\nThe `__init__` method has to return `None`. Returning any value from\nan `__init__` method will result in a runtime error.",
      "example": "```python\nclass Example:\n    def __init__(self):\n        return []\n```\n\nUse instead:\n```python\nclass Example:\n    def __init__(self):\n        self.value = []\n```"
    },
    {
      "code": "PLE0115",
      "name": "nonlocal-and-global",
      "summary": "Checks for variables which are both declared as both `nonlocal` and\n`global`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/nonlocal-and-global/",
      "whyBad": "A `nonlocal` variable is a variable that is defined in the nearest\nenclosing scope, but not in the global scope, while a `global` variable is\na variable that is defined in the global scope.\n\nDeclaring a variable as both `nonlocal` and `global` is contradictory and\nwill raise a `SyntaxError`.",
      "example": "```python\ncounter = 0\n\n\ndef increment():\n    global counter\n    nonlocal counter\n    counter += 1\n```\n\nUse instead:\n```python\ncounter = 0\n\n\ndef increment():\n    global counter\n    counter += 1\n```"
    },
    {
      "code": "PLE0116",
      "name": "continue-in-finally",
      "summary": "Checks for `continue` statements inside `finally`",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/continue-in-finally/",
      "whyBad": "`continue` statements were not allowed within `finally` clauses prior to\nPython 3.8. Using a `continue` statement within a `finally` clause can\ncause a `SyntaxError`.",
      "example": "```python\nwhile True:\n    try:\n        pass\n    finally:\n        continue\n```\n\nUse instead:\n```python\nwhile True:\n    try:\n        pass\n    except Exception:\n        pass\n    else:\n        continue\n```"
    },
    {
      "code": "PLE0117",
      "name": "nonlocal-without-binding",
      "summary": "Checks for `nonlocal` names without bindings.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/nonlocal-without-binding/",
      "whyBad": "`nonlocal` names must be bound to a name in an outer scope.\nViolating this rule leads to a `SyntaxError` at runtime.",
      "example": "```python\ndef foo():\n    def get_bar(self):\n        nonlocal bar\n        ...\n```\n\nUse instead:\n```python\ndef foo():\n    bar = 1\n\n    def get_bar(self):\n        nonlocal bar\n        ...\n```"
    },
    {
      "code": "PLE0118",
      "name": "load-before-global-declaration",
      "summary": "Checks for uses of names that are declared as `global` prior to the\nrelevant `global` declaration.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/load-before-global-declaration/",
      "whyBad": "The `global` declaration applies to the entire scope. Using a name that's\ndeclared as `global` in a given scope prior to the relevant `global`\ndeclaration is a `SyntaxError`.",
      "example": "```python\ncounter = 1\n\n\ndef increment():\n    print(f\"Adding 1 to {counter}\")\n    global counter\n    counter += 1\n```\n\nUse instead:\n```python\ncounter = 1\n\n\ndef increment():\n    global counter\n    print(f\"Adding 1 to {counter}\")\n    counter += 1\n```"
    },
    {
      "code": "PLE0237",
      "name": "non-slot-assignment",
      "summary": "Checks for assignments to attributes that are not defined in `__slots__`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-slot-assignment/",
      "whyBad": "When using `__slots__`, only the specified attributes are allowed.\nAttempting to assign to an attribute that is not defined in `__slots__`\nwill result in an `AttributeError` at runtime.",
      "example": "```python\nclass Student:\n    __slots__ = (\"name\",)\n\n    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname  # [assigning-non-slot]\n        self.setup()\n\n    def setup(self):\n        pass\n```\n\nUse instead:\n```python\nclass Student:\n    __slots__ = (\"name\", \"surname\")\n\n    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname\n        self.setup()\n\n    def setup(self):\n        pass\n```"
    },
    {
      "code": "PLE0241",
      "name": "duplicate-bases",
      "summary": "Checks for duplicate base classes in class definitions.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/duplicate-bases/",
      "whyBad": "Including duplicate base classes will raise a `TypeError` at runtime.",
      "example": "```python\nclass Foo:\n    pass\n\n\nclass Bar(Foo, Foo):\n    pass\n```\n\nUse instead:\n```python\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n```"
    },
    {
      "code": "PLE0302",
      "name": "unexpected-special-method-signature",
      "summary": "Checks for \"special\" methods that have an unexpected method signature.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unexpected-special-method-signature/",
      "whyBad": "\"Special\" methods, like `__len__`, are expected to adhere to a specific,\nstandard function signature. Implementing a \"special\" method using a\nnon-standard function signature can lead to unexpected and surprising\nbehavior for users of a given class.",
      "example": "```python\nclass Bookshelf:\n    def __init__(self):\n        self._books = [\"Foo\", \"Bar\", \"Baz\"]\n\n    def __len__(self, index):  # __len__ does not except an index parameter\n        return len(self._books)\n\n    def __getitem__(self, index):\n        return self._books[index]\n```\n\nUse instead:\n```python\nclass Bookshelf:\n    def __init__(self):\n        self._books = [\"Foo\", \"Bar\", \"Baz\"]\n\n    def __len__(self):\n        return len(self._books)\n\n    def __getitem__(self, index):\n        return self._books[index]\n```"
    },
    {
      "code": "PLE0303",
      "name": "invalid-length-return-type",
      "summary": "Checks for `__len__` implementations that return values that are not non-negative\nintegers.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-length-return-type/",
      "whyBad": "The `__len__` method should return a non-negative integer. Returning a different\nvalue may cause unexpected behavior.\n\nNote: `bool` is a subclass of `int`, so it's technically valid for `__len__` to\nreturn `True` or `False`. However, for consistency with other rules, Ruff will\nstill emit a diagnostic when `__len__` returns a `bool`.",
      "example": "```python\nclass Foo:\n    def __len__(self):\n        return \"2\"\n```\n\nUse instead:\n```python\nclass Foo:\n    def __len__(self):\n        return 2\n```"
    },
    {
      "code": "PLE0304",
      "name": "invalid-bool-return-type",
      "summary": "Checks for `__bool__` implementations that return a type other than `bool`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-bool-return-type/",
      "whyBad": "The `__bool__` method should return a `bool` object. Returning a different\ntype may cause unexpected behavior.",
      "example": "```python\nclass Foo:\n    def __bool__(self):\n        return 2\n```\n\nUse instead:\n```python\nclass Foo:\n    def __bool__(self):\n        return True\n```"
    },
    {
      "code": "PLE0305",
      "name": "invalid-index-return-type",
      "summary": "Checks for `__index__` implementations that return non-integer values.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-index-return-type/",
      "whyBad": "The `__index__` method should return an integer. Returning a different\ntype may cause unexpected behavior.\n\nNote: `bool` is a subclass of `int`, so it's technically valid for `__index__` to\nreturn `True` or `False`. However, a `DeprecationWarning` (`DeprecationWarning:\n__index__ returned non-int (type bool)`) for such cases was already introduced,\nthus this is a conscious difference between the original pylint rule and the\ncurrent ruff implementation.",
      "example": "```python\nclass Foo:\n    def __index__(self):\n        return \"2\"\n```\n\nUse instead:\n```python\nclass Foo:\n    def __index__(self):\n        return 2\n```"
    },
    {
      "code": "PLE0307",
      "name": "invalid-str-return-type",
      "summary": "Checks for `__str__` implementations that return a type other than `str`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-str-return-type/",
      "whyBad": "The `__str__` method should return a `str` object. Returning a different\ntype may cause unexpected behavior.",
      "example": "```python\nclass Foo:\n    def __str__(self):\n        return True\n```\n\nUse instead:\n```python\nclass Foo:\n    def __str__(self):\n        return \"Foo\"\n```"
    },
    {
      "code": "PLE0308",
      "name": "invalid-bytes-return-type",
      "summary": "Checks for `__bytes__` implementations that return types other than `bytes`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-bytes-return-type/",
      "whyBad": "The `__bytes__` method should return a `bytes` object. Returning a different\ntype may cause unexpected behavior.",
      "example": "```python\nclass Foo:\n    def __bytes__(self):\n        return 2\n```\n\nUse instead:\n```python\nclass Foo:\n    def __bytes__(self):\n        return b\"2\"\n```"
    },
    {
      "code": "PLE0309",
      "name": "invalid-hash-return-type",
      "summary": "Checks for `__hash__` implementations that return non-integer values.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-hash-return-type/",
      "whyBad": "The `__hash__` method should return an integer. Returning a different\ntype may cause unexpected behavior.\n\nNote: `bool` is a subclass of `int`, so it's technically valid for `__hash__` to\nreturn `True` or `False`. However, for consistency with other rules, Ruff will\nstill emit a diagnostic when `__hash__` returns a `bool`.",
      "example": "```python\nclass Foo:\n    def __hash__(self):\n        return \"2\"\n```\n\nUse instead:\n```python\nclass Foo:\n    def __hash__(self):\n        return 2\n```"
    },
    {
      "code": "PLE0604",
      "name": "invalid-all-object",
      "summary": "Checks for the inclusion of invalid objects in `__all__`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-all-object/",
      "whyBad": "In Python, `__all__` should contain a sequence of strings that represent\nthe names of all \"public\" symbols exported by a module.\n\nAssigning anything other than a `tuple` or `list` of strings to `__all__`\nis invalid.",
      "example": "```python\n__all__ = [Foo, 1, None]\n```\n\nUse instead:\n```python\n__all__ = [\"Foo\", \"Bar\", \"Baz\"]\n```"
    },
    {
      "code": "PLE0605",
      "name": "invalid-all-format",
      "summary": "Checks for invalid assignments to `__all__`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-all-format/",
      "whyBad": "In Python, `__all__` should contain a sequence of strings that represent\nthe names of all \"public\" symbols exported by a module.\n\nAssigning anything other than a `tuple` or `list` of strings to `__all__`\nis invalid.",
      "example": "```python\n__all__ = \"Foo\"\n```\n\nUse instead:\n```python\n__all__ = (\"Foo\",)\n```"
    },
    {
      "code": "PLE0643",
      "name": "potential-index-error",
      "summary": "Checks for hard-coded sequence accesses that are known to be out of bounds.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/potential-index-error/",
      "whyBad": "Attempting to access a sequence with an out-of-bounds index will cause an\n`IndexError` to be raised at runtime. When the sequence and index are\ndefined statically (e.g., subscripts on `list` and `tuple` literals, with\ninteger indexes), such errors can be detected ahead of time.",
      "example": "```python\nprint([0, 1, 2][3])\n```"
    },
    {
      "code": "PLE0704",
      "name": "misplaced-bare-raise",
      "summary": "Checks for bare `raise` statements outside of exception handlers.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/misplaced-bare-raise/",
      "whyBad": "A bare `raise` statement without an exception object will re-raise the last\nexception that was active in the current scope, and is typically used\nwithin an exception handler to re-raise the caught exception.\n\nIf a bare `raise` is used outside of an exception handler, it will generate\nan error due to the lack of an active exception.\n\nNote that a bare `raise` within a  `finally` block will work in some cases\n(namely, when the exception is raised within the `try` block), but should\nbe avoided as it can lead to confusing behavior.",
      "example": "```python\nfrom typing import Any\n\n\ndef is_some(obj: Any) -> bool:\n    if obj is None:\n        raise\n```\n\nUse instead:\n```python\nfrom typing import Any\n\n\ndef is_some(obj: Any) -> bool:\n    if obj is None:\n        raise ValueError(\"`obj` cannot be `None`\")\n```"
    },
    {
      "code": "PLE1132",
      "name": "repeated-keyword-argument",
      "summary": "Checks for repeated keyword arguments in function calls.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/repeated-keyword-argument/",
      "whyBad": "Python does not allow repeated keyword arguments in function calls. If a\nfunction is called with the same keyword argument multiple times, the\ninterpreter will raise an exception.",
      "example": "```python\nfunc(1, 2, c=3, **{\"c\": 4})\n```"
    },
    {
      "code": "PLE1141",
      "name": "dict-iter-missing-items",
      "summary": "Checks for dictionary unpacking in a for loop without calling `.items()`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/dict-iter-missing-items/",
      "whyBad": "When iterating over a dictionary in a for loop, if a dictionary is unpacked\nwithout calling `.items()`, it could lead to a runtime error if the keys are not\na tuple of two elements.\n\nIt is likely that you're looking for an iteration over (key, value) pairs which\ncan only be achieved when calling `.items()`.",
      "example": "```python\ndata = {\"Paris\": 2_165_423, \"New York City\": 8_804_190, \"Tokyo\": 13_988_129}\n\nfor city, population in data:\n    print(f\"{city} has population {population}.\")\n```\n\nUse instead:\n```python\ndata = {\"Paris\": 2_165_423, \"New York City\": 8_804_190, \"Tokyo\": 13_988_129}\n\nfor city, population in data.items():\n    print(f\"{city} has population {population}.\")\n```"
    },
    {
      "code": "PLE1142",
      "name": "await-outside-async",
      "summary": "Checks for uses of `await` outside `async` functions.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/await-outside-async/",
      "whyBad": "Using `await` outside an `async` function is a syntax error.",
      "example": "```python\nimport asyncio\n\n\ndef foo():\n    await asyncio.sleep(1)\n```\n\nUse instead:\n```python\nimport asyncio\n\n\nasync def foo():\n    await asyncio.sleep(1)\n```"
    },
    {
      "code": "PLE1205",
      "name": "logging-too-many-args",
      "summary": "Checks for too many positional arguments for a `logging` format string.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-too-many-args/",
      "whyBad": "A `TypeError` will be raised if the statement is run.",
      "example": "```python\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"Error occurred: %s\", type(e), e)\n    raise\n```\n\nUse instead:\n```python\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", type(e), e)\n    raise\n```"
    },
    {
      "code": "PLE1206",
      "name": "logging-too-few-args",
      "summary": "Checks for too few positional arguments for a `logging` format string.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-too-few-args/",
      "whyBad": "A `TypeError` will be raised if the statement is run.",
      "example": "```python\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", e)\n    raise\n```\n\nUse instead:\n```python\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", type(e), e)\n    raise\n```"
    },
    {
      "code": "PLE1300",
      "name": "bad-string-format-character",
      "summary": "Checks for unsupported format types in format strings.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-string-format-character/",
      "whyBad": "An invalid format string character will result in an error at runtime.",
      "example": "```python\n# `z` is not a valid format type.\nprint(\"%z\" % \"1\")\n\nprint(\"{:z}\".format(\"1\"))\n```"
    },
    {
      "code": "PLE1307",
      "name": "bad-string-format-type",
      "summary": "Checks for mismatched argument types in \"old-style\" format strings.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-string-format-type/",
      "whyBad": "The format string is not checked at compile time, so it is easy to\nintroduce bugs by mistyping the format string.",
      "example": "```python\nprint(\"%d\" % \"1\")\n```\n\nUse instead:\n```python\nprint(\"%d\" % 1)\n```"
    },
    {
      "code": "PLE1310",
      "name": "bad-str-strip-call",
      "summary": "Checks duplicate characters in `str.strip` calls.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-str-strip-call/",
      "whyBad": "All characters in `str.strip` calls are removed from both the leading and\ntrailing ends of the string. Including duplicate characters in the call\nis redundant and often indicative of a mistake.\n\nIn Python 3.9 and later, you can use `str.removeprefix` and\n`str.removesuffix` to remove an exact prefix or suffix from a string,\nrespectively, which should be preferred when possible.",
      "example": "```python\n# Evaluates to \"foo\".\n\"bar foo baz\".strip(\"bar baz \")\n```\n\nUse instead:\n```python\n# Evaluates to \"foo\".\n\"bar foo baz\".strip(\"abrz \")  # \"foo\"\n```\n\nOr:\n```python\n# Evaluates to \"foo\".\n\"bar foo baz\".removeprefix(\"bar \").removesuffix(\" baz\")\n```"
    },
    {
      "code": "PLE1507",
      "name": "invalid-envvar-value",
      "summary": "Checks for `os.getenv` calls with an invalid `key` argument.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-envvar-value/",
      "whyBad": "`os.getenv` only supports strings as the first argument (`key`).\n\nIf the provided argument is not a string, `os.getenv` will throw a\n`TypeError` at runtime.",
      "example": "```python\nimport os\n\nos.getenv(1)\n```\n\nUse instead:\n```python\nimport os\n\nos.getenv(\"1\")\n```"
    },
    {
      "code": "PLE1519",
      "name": "singledispatch-method",
      "summary": "Checks for methods decorated with `@singledispatch`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/singledispatch-method/",
      "whyBad": "The `@singledispatch` decorator is intended for use with functions, not methods.\n\nInstead, use the `@singledispatchmethod` decorator, or migrate the method to a\nstandalone function.",
      "example": "```python\nfrom functools import singledispatch\n\n\nclass Class:\n    @singledispatch\n    def method(self, arg): ...\n```\n\nUse instead:\n\n```python\nfrom functools import singledispatchmethod\n\n\nclass Class:\n    @singledispatchmethod\n    def method(self, arg): ...\n```"
    },
    {
      "code": "PLE1520",
      "name": "singledispatchmethod-function",
      "summary": "Checks for non-method functions decorated with `@singledispatchmethod`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/singledispatchmethod-function/",
      "whyBad": "The `@singledispatchmethod` decorator is intended for use with methods, not\nfunctions.\n\nInstead, use the `@singledispatch` decorator.",
      "example": "```python\nfrom functools import singledispatchmethod\n\n\n@singledispatchmethod\ndef func(arg): ...\n```\n\nUse instead:\n\n```python\nfrom functools import singledispatch\n\n\n@singledispatch\ndef func(arg): ...\n```"
    },
    {
      "code": "PLE1700",
      "name": "yield-from-in-async-function",
      "summary": "Checks for uses of `yield from` in async functions.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/yield-from-in-async-function/",
      "whyBad": "Python doesn't support the use of `yield from` in async functions, and will\nraise a `SyntaxError` in such cases.\n\nInstead, considering refactoring the code to use an `async for` loop instead.",
      "example": "```python\nasync def numbers():\n    yield from [1, 2, 3, 4, 5]\n```\n\nUse instead:\n```python\nasync def numbers():\n    async for number in [1, 2, 3, 4, 5]:\n        yield number\n```"
    },
    {
      "code": "PLE2502",
      "name": "bidirectional-unicode",
      "summary": "Checks for bidirectional formatting characters.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bidirectional-unicode/",
      "whyBad": "The interaction between bidirectional formatting characters and the\nsurrounding code can be surprising to those that are unfamiliar\nwith right-to-left writing systems.\n\nIn some cases, bidirectional formatting characters can also be used to\nobfuscate code and introduce or mask security vulnerabilities.",
      "example": "```python\nexample = \"x\" * 100  #    \"x\" is assigned\n```\n\nThe example uses two `RIGHT-TO-LEFT MARK`s to make the `100 * ` appear inside the comment.\nWithout the `RIGHT-TO-LEFT MARK`s, the code looks like this:\n\n```py\nexample = \"x\" * 100  #    \"x\" is assigned\n```"
    },
    {
      "code": "PLE2510",
      "name": "invalid-character-backspace",
      "summary": "Checks for strings that contain the control character `BS`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-character-backspace/",
      "whyBad": "Control characters are displayed differently by different text editors and\nterminals.\n\nBy using the `\\b` sequence in lieu of the `BS` control character, the\nstring will contain the same value, but will render visibly in all editors.",
      "example": "```python\nx = \"\"\n```\n\nUse instead:\n```python\nx = \"\\b\"\n```"
    },
    {
      "code": "PLE2512",
      "name": "invalid-character-sub",
      "summary": "Checks for strings that contain the raw control character `SUB`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-character-sub/",
      "whyBad": "Control characters are displayed differently by different text editors and\nterminals.\n\nBy using the `\\x1a` sequence in lieu of the `SUB` control character, the\nstring will contain the same value, but will render visibly in all editors.",
      "example": "```python\nx = \"\"\n```\n\nUse instead:\n```python\nx = \"\\x1a\"\n```"
    },
    {
      "code": "PLE2513",
      "name": "invalid-character-esc",
      "summary": "Checks for strings that contain the raw control character `ESC`.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-character-esc/",
      "whyBad": "Control characters are displayed differently by different text editors and\nterminals.\n\nBy using the `\\x1b` sequence in lieu of the `ESC` control character, the\nstring will contain the same value, but will render visibly in all editors.",
      "example": "```python\nx = \"\"\n```\n\nUse instead:\n```python\nx = \"\\x1b\"\n```"
    },
    {
      "code": "PLE2514",
      "name": "invalid-character-nul",
      "summary": "Checks for strings that contain the raw control character `NUL` (0 byte).",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-character-nul/",
      "whyBad": "Control characters are displayed differently by different text editors and\nterminals.\n\nBy using the `\\0` sequence in lieu of the `NUL` control character, the\nstring will contain the same value, but will render visibly in all editors.",
      "example": "```python\nx = \"\"\n```\n\nUse instead:\n```python\nx = \"\\0\"\n```"
    },
    {
      "code": "PLE2515",
      "name": "invalid-character-zero-width-space",
      "summary": "Checks for strings that contain the zero width space character.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-character-zero-width-space/",
      "whyBad": "This character is rendered invisibly in some text editors and terminals.\n\nBy using the `\\u200B` sequence, the string will contain the same value,\nbut will render visibly in all editors.",
      "example": "```python\nx = \"Dear Sir/Madam\"\n```\n\nUse instead:\n```python\nx = \"Dear Sir\\u200b/\\u200bMadam\"  # zero width space\n```"
    },
    {
      "code": "PLE4703",
      "name": "modified-iterating-set",
      "summary": "Checks for loops in which a `set` is modified during iteration.",
      "category": "Pylint",
      "categoryCode": "PLE",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/modified-iterating-set/",
      "whyBad": "If a `set` is modified during iteration, it will cause a `RuntimeError`.\n\nIf you need to modify a `set` within a loop, consider iterating over a copy\nof the `set` instead.",
      "example": "```python\nnums = {1, 2, 3}\nfor num in nums:\n    nums.add(num + 5)\n```\n\nUse instead:\n```python\nnums = {1, 2, 3}\nfor num in nums.copy():\n    nums.add(num + 5)\n```"
    },
    {
      "code": "PLR0124",
      "name": "comparison-with-itself",
      "summary": "Checks for operations that compare a name to itself.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/comparison-with-itself/",
      "whyBad": "Comparing a name to itself always results in the same value, and is likely\na mistake.",
      "example": "```python\nfoo == foo\n```\n\nIn some cases, self-comparisons are used to determine whether a float is\nNaN. Instead, prefer `math.isnan`:\n```python\nimport math\n\nmath.isnan(foo)\n```"
    },
    {
      "code": "PLR0133",
      "name": "comparison-of-constant",
      "summary": "Checks for comparisons between constants.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/comparison-of-constant/",
      "whyBad": "Comparing two constants will always resolve to the same value, so the\ncomparison is redundant. Instead, the expression should be replaced\nwith the result of the comparison.",
      "example": "```python\nfoo = 1 == 1\n```\n\nUse instead:\n```python\nfoo = True\n```"
    },
    {
      "code": "PLR0202",
      "name": "no-classmethod-decorator",
      "summary": "Checks for the use of a classmethod being made without the decorator.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-classmethod-decorator/",
      "whyBad": "When it comes to consistency and readability, it's preferred to use the decorator.",
      "example": "```python\nclass Foo:\n    def bar(cls): ...\n\n    bar = classmethod(bar)\n```\n\nUse instead:\n\n```python\nclass Foo:\n    @classmethod\n    def bar(cls): ...\n```"
    },
    {
      "code": "PLR0203",
      "name": "no-staticmethod-decorator",
      "summary": "Checks for the use of a staticmethod being made without the decorator.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-staticmethod-decorator/",
      "whyBad": "When it comes to consistency and readability, it's preferred to use the decorator.",
      "example": "```python\nclass Foo:\n    def bar(arg1, arg2): ...\n\n    bar = staticmethod(bar)\n```\n\nUse instead:\n\n```python\nclass Foo:\n    @staticmethod\n    def bar(arg1, arg2): ...\n```"
    },
    {
      "code": "PLR0206",
      "name": "property-with-parameters",
      "summary": "Checks for property definitions that accept function parameters.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/property-with-parameters/",
      "whyBad": "Properties cannot be called with parameters.\n\nIf you need to pass parameters to a property, create a method with the\ndesired parameters and call that method instead.",
      "example": "```python\nclass Cat:\n    @property\n    def purr(self, volume): ...\n```\n\nUse instead:\n\n```python\nclass Cat:\n    @property\n    def purr(self): ...\n\n    def purr_volume(self, volume): ...\n```"
    },
    {
      "code": "PLR0402",
      "name": "manual-from-import",
      "summary": "Checks for submodule imports that are aliased to the submodule name.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/manual-from-import/",
      "whyBad": "Using the `from` keyword to import the submodule is more concise and\nreadable.",
      "example": "```python\nimport concurrent.futures as futures\n```\n\nUse instead:\n```python\nfrom concurrent import futures\n```"
    },
    {
      "code": "PLR0904",
      "name": "too-many-public-methods",
      "summary": "Checks for classes with too many public methods\n\nBy default, this rule allows up to 20 public methods, as configured by\nthe [`lint.pylint.max-public-methods`] option.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-public-methods/",
      "whyBad": "Classes with many public methods are harder to understand\nand maintain.\n\nInstead, consider refactoring the class into separate classes.",
      "example": "Assuming that `lint.pylint.max-public-methods` is set to 5:\n```python\nclass Linter:\n    def __init__(self):\n        pass\n\n    def pylint(self):\n        pass\n\n    def pylint_settings(self):\n        pass\n\n    def flake8(self):\n        pass\n\n    def flake8_settings(self):\n        pass\n\n    def pydocstyle(self):\n        pass\n\n    def pydocstyle_settings(self):\n        pass\n```\n\nUse instead:\n```python\nclass Linter:\n    def __init__(self):\n        self.pylint = Pylint()\n        self.flake8 = Flake8()\n        self.pydocstyle = Pydocstyle()\n\n    def lint(self):\n        pass\n\n\nclass Pylint:\n    def lint(self):\n        pass\n\n    def settings(self):\n        pass\n\n\nclass Flake8:\n    def lint(self):\n        pass\n\n    def settings(self):\n        pass\n\n\nclass Pydocstyle:\n    def lint(self):\n        pass\n\n    def settings(self):\n        pass\n```"
    },
    {
      "code": "PLR0911",
      "name": "too-many-return-statements",
      "summary": "Checks for functions or methods with too many return statements.\n\nBy default, this rule allows up to six return statements, as configured by\nthe [`lint.pylint.max-returns`] option.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-return-statements/",
      "whyBad": "Functions or methods with many return statements are harder to understand\nand maintain, and often indicative of complex logic.",
      "example": "```python\ndef capital(country: str) -> str | None:\n    if country == \"England\":\n        return \"London\"\n    elif country == \"France\":\n        return \"Paris\"\n    elif country == \"Poland\":\n        return \"Warsaw\"\n    elif country == \"Romania\":\n        return \"Bucharest\"\n    elif country == \"Spain\":\n        return \"Madrid\"\n    elif country == \"Thailand\":\n        return \"Bangkok\"\n    else:\n        return None\n```\n\nUse instead:\n```python\ndef capital(country: str) -> str | None:\n    capitals = {\n        \"England\": \"London\",\n        \"France\": \"Paris\",\n        \"Poland\": \"Warsaw\",\n        \"Romania\": \"Bucharest\",\n        \"Spain\": \"Madrid\",\n        \"Thailand\": \"Bangkok\",\n    }\n    return capitals.get(country)\n```"
    },
    {
      "code": "PLR0912",
      "name": "too-many-branches",
      "summary": "Checks for functions or methods with too many branches, including (nested)\n`if`, `elif`, and `else` branches, `for` loops, `try`-`except` clauses, and\n`match` and `case` statements.\n\nBy default, this rule allows up to 12 branches. This can be configured\nusing the [`lint.pylint.max-branches`] option.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-branches/",
      "whyBad": "Functions or methods with many branches are harder to understand\nand maintain than functions or methods with fewer branches.",
      "example": "Given:\n```python\ndef capital(country):\n    if country == \"Australia\":\n        return \"Canberra\"\n    elif country == \"Brazil\":\n        return \"Brasilia\"\n    elif country == \"Canada\":\n        return \"Ottawa\"\n    elif country == \"England\":\n        return \"London\"\n    elif country == \"France\":\n        return \"Paris\"\n    elif country == \"Germany\":\n        return \"Berlin\"\n    elif country == \"Poland\":\n        return \"Warsaw\"\n    elif country == \"Romania\":\n        return \"Bucharest\"\n    elif country == \"Spain\":\n        return \"Madrid\"\n    elif country == \"Thailand\":\n        return \"Bangkok\"\n    elif country == \"Turkey\":\n        return \"Ankara\"\n    elif country == \"United States\":\n        return \"Washington\"\n    else:\n        return \"Unknown\"  # 13th branch\n```\n\nUse instead:\n```python\ndef capital(country):\n    capitals = {\n        \"Australia\": \"Canberra\",\n        \"Brazil\": \"Brasilia\",\n        \"Canada\": \"Ottawa\",\n        \"England\": \"London\",\n        \"France\": \"Paris\",\n        \"Germany\": \"Berlin\",\n        \"Poland\": \"Warsaw\",\n        \"Romania\": \"Bucharest\",\n        \"Spain\": \"Madrid\",\n        \"Thailand\": \"Bangkok\",\n        \"Turkey\": \"Ankara\",\n        \"United States\": \"Washington\",\n    }\n    city = capitals.get(country, \"Unknown\")\n    return city\n```\n\nGiven:\n```python\ndef grades_to_average_number(grades):\n    numbers = []\n    for grade in grades:  # 1st branch\n        if len(grade) not in {1, 2}:\n            raise ValueError(f\"Invalid grade: {grade}\")\n\n        if len(grade) == 2 and grade[1] not in {\"+\", \"-\"}:\n            raise ValueError(f\"Invalid grade: {grade}\")\n\n        letter = grade[0]\n\n        if letter in {\"F\", \"E\"}:\n            number = 0.0\n        elif letter == \"D\":\n            number = 1.0\n        elif letter == \"C\":\n            number = 2.0\n        elif letter == \"B\":\n            number = 3.0\n        elif letter == \"A\":\n            number = 4.0\n        else:\n            raise ValueError(f\"Invalid grade: {grade}\")\n\n        modifier = 0.0\n        if letter != \"F\" and grade[-1] == \"+\":\n            modifier = 0.3\n        elif letter != \"F\" and grade[-1] == \"-\":\n            modifier = -0.3\n\n        numbers.append(max(0.0, min(number + modifier, 4.0)))\n\n    try:\n        return sum(numbers) / len(numbers)\n    except ZeroDivisionError:  # 13th branch\n        return 0\n```\n\nUse instead:\n```python\ndef grades_to_average_number(grades):\n    grade_values = {\"F\": 0.0, \"E\": 0.0, \"D\": 1.0, \"C\": 2.0, \"B\": 3.0, \"A\": 4.0}\n    modifier_values = {\"+\": 0.3, \"-\": -0.3}\n\n    numbers = []\n    for grade in grades:\n        if len(grade) not in {1, 2}:\n            raise ValueError(f\"Invalid grade: {grade}\")\n\n        letter = grade[0]\n        if letter not in grade_values:\n            raise ValueError(f\"Invalid grade: {grade}\")\n        number = grade_values[letter]\n\n        if len(grade) == 2 and grade[1] not in modifier_values:\n            raise ValueError(f\"Invalid grade: {grade}\")\n        modifier = modifier_values.get(grade[-1], 0.0)\n\n        if letter == \"F\":\n            numbers.append(0.0)\n        else:\n            numbers.append(max(0.0, min(number + modifier, 4.0)))\n\n    try:\n        return sum(numbers) / len(numbers)\n    except ZeroDivisionError:\n        return 0\n```"
    },
    {
      "code": "PLR0913",
      "name": "too-many-arguments",
      "summary": "Checks for function definitions that include too many arguments.\n\nBy default, this rule allows up to five arguments, as configured by the\n[`lint.pylint.max-args`] option.\n\nThis rule exempts methods decorated with [`@typing.override`][override].\nChanging the signature of a subclass method may cause type checkers to\ncomplain about a violation of the Liskov Substitution Principle if it\nmeans that the method now incompatibly overrides a method defined on a\nsuperclass. Explicitly decorating an overriding method with `@override`\nsignals to Ruff that the method is intended to override a superclass\nmethod and that a type checker will enforce that it does so; Ruff\ntherefore knows that it should not enforce rules about methods having\ntoo many arguments.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-arguments/",
      "whyBad": "Functions with many arguments are harder to understand, maintain, and call.\nConsider refactoring functions with many arguments into smaller functions\nwith fewer arguments, or using objects to group related arguments.",
      "example": "```python\ndef calculate_position(x_pos, y_pos, z_pos, x_vel, y_vel, z_vel, time):\n    new_x = x_pos + x_vel * time\n    new_y = y_pos + y_vel * time\n    new_z = z_pos + z_vel * time\n    return new_x, new_y, new_z\n```\n\nUse instead:\n```python\nfrom typing import NamedTuple\n\n\nclass Vector(NamedTuple):\n    x: float\n    y: float\n    z: float\n\n\ndef calculate_position(pos: Vector, vel: Vector, time: float) -> Vector:\n    return Vector(*(p + v * time for p, v in zip(pos, vel)))\n```"
    },
    {
      "code": "PLR0914",
      "name": "too-many-locals",
      "summary": "Checks for functions that include too many local variables.\n\nBy default, this rule allows up to fifteen locals, as configured by the\n[`lint.pylint.max-locals`] option.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-locals/",
      "whyBad": "Functions with many local variables are harder to understand and maintain.\n\nConsider refactoring functions with many local variables into smaller\nfunctions with fewer assignments."
    },
    {
      "code": "PLR0915",
      "name": "too-many-statements",
      "summary": "Checks for functions or methods with too many statements.\n\nBy default, this rule allows up to 50 statements, as configured by the\n[`lint.pylint.max-statements`] option.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-statements/",
      "whyBad": "Functions or methods with many statements are harder to understand\nand maintain.\n\nInstead, consider refactoring the function or method into smaller\nfunctions or methods, or identifying generalizable patterns and\nreplacing them with generic logic or abstractions.",
      "example": "```python\ndef is_even(number: int) -> bool:\n    if number == 0:\n        return True\n    elif number == 1:\n        return False\n    elif number == 2:\n        return True\n    elif number == 3:\n        return False\n    elif number == 4:\n        return True\n    elif number == 5:\n        return False\n    else:\n        ...\n```\n\nUse instead:\n```python\ndef is_even(number: int) -> bool:\n    return number % 2 == 0\n```"
    },
    {
      "code": "PLR0916",
      "name": "too-many-boolean-expressions",
      "summary": "Checks for too many Boolean expressions in an `if` statement.\n\nBy default, this rule allows up to 5 expressions. This can be configured\nusing the [`lint.pylint.max-bool-expr`] option.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-boolean-expressions/",
      "whyBad": "`if` statements with many Boolean expressions are harder to understand\nand maintain. Consider assigning the result of the Boolean expression,\nor any of its sub-expressions, to a variable.",
      "example": "```python\nif a and b and c and d and e and f and g and h:\n    ...\n```"
    },
    {
      "code": "PLR0917",
      "name": "too-many-positional-arguments",
      "summary": "Checks for function definitions that include too many positional arguments.\n\nBy default, this rule allows up to five arguments, as configured by the\n[`lint.pylint.max-positional-args`] option.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-positional-arguments/",
      "whyBad": "Functions with many arguments are harder to understand, maintain, and call.\nThis is especially true for functions with many positional arguments, as\nproviding arguments positionally is more error-prone and less clear to\nreaders than providing arguments by name.\n\nConsider refactoring functions with many arguments into smaller functions\nwith fewer arguments, using objects to group related arguments, or migrating to\n[keyword-only arguments](https://docs.python.org/3/tutorial/controlflow.html#special-parameters).\n\nThis rule exempts methods decorated with [`@typing.override`][override].\nChanging the signature of a subclass method may cause type checkers to\ncomplain about a violation of the Liskov Substitution Principle if it\nmeans that the method now incompatibly overrides a method defined on a\nsuperclass. Explicitly decorating an overriding method with `@override`\nsignals to Ruff that the method is intended to override a superclass\nmethod and that a type checker will enforce that it does so; Ruff\ntherefore knows that it should not enforce rules about methods having\ntoo many arguments.",
      "example": "```python\ndef plot(x, y, z, color, mark, add_trendline): ...\n\n\nplot(1, 2, 3, \"r\", \"*\", True)\n```\n\nUse instead:\n\n```python\ndef plot(x, y, z, *, color, mark, add_trendline): ...\n\n\nplot(1, 2, 3, color=\"r\", mark=\"*\", add_trendline=True)\n```"
    },
    {
      "code": "PLR1701",
      "name": "repeated-isinstance-calls",
      "summary": "Checks for repeated `isinstance` calls on the same object.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/repeated-isinstance-calls/",
      "whyBad": "Repeated `isinstance` calls on the same object can be merged into a\nsingle call.",
      "example": "```python\ndef is_number(x):\n    return isinstance(x, int) or isinstance(x, float) or isinstance(x, complex)\n```\n\nUse instead:\n```python\ndef is_number(x):\n    return isinstance(x, (int, float, complex))\n```\n\nOr, for Python 3.10 and later:\n\n```python\ndef is_number(x):\n    return isinstance(x, int | float | complex)\n```"
    },
    {
      "code": "PLR1702",
      "name": "too-many-nested-blocks",
      "summary": "Checks for functions or methods with too many nested blocks.\n\nBy default, this rule allows up to five nested blocks.\nThis can be configured using the [`lint.pylint.max-nested-blocks`] option.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/too-many-nested-blocks/",
      "whyBad": "Functions or methods with too many nested blocks are harder to understand\nand maintain."
    },
    {
      "code": "PLR1704",
      "name": "redefined-argument-from-local",
      "summary": "Checks for variables defined in `for`, `try`, `with` statements\nthat redefine function parameters.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redefined-argument-from-local/",
      "whyBad": "Redefined variables can cause unexpected behavior because of overridden function parameters.\nIf nested functions are declared, an inner function's body can override an outer function's parameters.",
      "example": "```python\ndef show(host_id=10.11):\n    for host_id, host in [[12.13, \"Venus\"], [14.15, \"Mars\"]]:\n        print(host_id, host)\n```\n\nUse instead:\n```python\ndef show(host_id=10.11):\n    for inner_host_id, host in [[12.13, \"Venus\"], [14.15, \"Mars\"]]:\n        print(host_id, inner_host_id, host)\n```"
    },
    {
      "code": "PLR1706",
      "name": "and-or-ternary",
      "summary": "Checks for uses of the known pre-Python 2.5 ternary syntax.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/and-or-ternary/",
      "whyBad": "Prior to the introduction of the if-expression (ternary) operator in Python\n2.5, the only way to express a conditional expression was to use the `and`\nand `or` operators.\n\nThe if-expression construct is clearer and more explicit, and should be\npreferred over the use of `and` and `or` for ternary expressions.",
      "example": "```python\nx, y = 1, 2\nmaximum = x >= y and x or y\n```\n\nUse instead:\n```python\nx, y = 1, 2\nmaximum = x if x >= y else y\n```"
    },
    {
      "code": "PLR1708",
      "name": "stop-iteration-return",
      "summary": "Checks for explicit `raise StopIteration` in generator functions.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/stop-iteration-return/",
      "whyBad": "Raising `StopIteration` in a generator function causes a `RuntimeError`\nwhen the generator is iterated over.\n\nInstead of `raise StopIteration`, use `return` in generator functions.",
      "example": "```python\ndef my_generator():\n    yield 1\n    yield 2\n    raise StopIteration  # This causes RuntimeError at runtime\n```\n\nUse instead:\n```python\ndef my_generator():\n    yield 1\n    yield 2\n    return  # Use return instead\n```"
    },
    {
      "code": "PLR1711",
      "name": "useless-return",
      "summary": "Checks for functions that end with an unnecessary `return` or\n`return None`, and contain no other `return` statements.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-return/",
      "whyBad": "Python implicitly assumes a `None` return at the end of a function, making\nit unnecessary to explicitly write `return None`.",
      "example": "```python\ndef f():\n    print(5)\n    return None\n```\n\nUse instead:\n```python\ndef f():\n    print(5)\n```"
    },
    {
      "code": "PLR1714",
      "name": "repeated-equality-comparison",
      "summary": "Checks for repeated equality comparisons that can be rewritten as a membership\ntest.\n\nThis rule will try to determine if the values are hashable\nand the fix will use a `set` if they are. If unable to determine, the fix\nwill use a `tuple` and suggest the use of a `set`.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/repeated-equality-comparison/",
      "whyBad": "To check if a variable is equal to one of many values, it is common to\nwrite a series of equality comparisons (e.g.,\n`foo == \"bar\" or foo == \"baz\"`).\n\nInstead, prefer to combine the values into a collection and use the `in`\noperator to check for membership, which is more performant and succinct.\nIf the items are hashable, use a `set` for efficiency; otherwise, use a\n`tuple`.",
      "example": "```python\nfoo == \"bar\" or foo == \"baz\" or foo == \"qux\"\n```\n\nUse instead:\n```python\nfoo in {\"bar\", \"baz\", \"qux\"}\n```"
    },
    {
      "code": "PLR1716",
      "name": "boolean-chained-comparison",
      "summary": "Check for chained boolean operations that can be simplified.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/boolean-chained-comparison/",
      "whyBad": "Refactoring the code will improve readability for these cases.",
      "example": "```python\na = int(input())\nb = int(input())\nc = int(input())\nif a < b and b < c:\n    pass\n```\n\nUse instead:\n\n```python\na = int(input())\nb = int(input())\nc = int(input())\nif a < b < c:\n    pass\n```"
    },
    {
      "code": "PLR1722",
      "name": "sys-exit-alias",
      "summary": "Checks for uses of the `exit()` and `quit()`.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sys-exit-alias/",
      "whyBad": "`exit` and `quit` come from the `site` module, which is typically imported\nautomatically during startup. However, it is not _guaranteed_ to be\nimported, and so using these functions may result in a `NameError` at\nruntime. Generally, these constants are intended to be used in an interactive\ninterpreter, and not in programs.\n\nPrefer `sys.exit()`, as the `sys` module is guaranteed to exist in all\ncontexts.",
      "example": "```python\nif __name__ == \"__main__\":\n    exit()\n```\n\nUse instead:\n```python\nimport sys\n\nif __name__ == \"__main__\":\n    sys.exit()\n```"
    },
    {
      "code": "PLR1730",
      "name": "if-stmt-min-max",
      "summary": "Checks for `if` statements that can be replaced with `min()` or `max()`\ncalls.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-stmt-min-max/",
      "whyBad": "An `if` statement that selects the lesser or greater of two sub-expressions\ncan be replaced with a `min()` or `max()` call respectively. Where possible,\nprefer `min()` and `max()`, as they're more concise and readable than the\nequivalent `if` statements.",
      "example": "```python\nif score > highest_score:\n    highest_score = score\n```\n\nUse instead:\n```python\nhighest_score = max(highest_score, score)\n```"
    },
    {
      "code": "PLR1733",
      "name": "unnecessary-dict-index-lookup",
      "summary": "Checks for key-based dict accesses during `.items()` iterations.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-dict-index-lookup/",
      "whyBad": "When iterating over a dict via `.items()`, the current value is already\navailable alongside its key. Using the key to look up the value is\nunnecessary.",
      "example": "```python\nFRUITS = {\"apple\": 1, \"orange\": 10, \"berry\": 22}\n\nfor fruit_name, fruit_count in FRUITS.items():\n    print(FRUITS[fruit_name])\n```\n\nUse instead:\n```python\nFRUITS = {\"apple\": 1, \"orange\": 10, \"berry\": 22}\n\nfor fruit_name, fruit_count in FRUITS.items():\n    print(fruit_count)\n```"
    },
    {
      "code": "PLR1736",
      "name": "unnecessary-list-index-lookup",
      "summary": "Checks for index-based list accesses during `enumerate` iterations.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-list-index-lookup/",
      "whyBad": "When iterating over a list with `enumerate`, the current item is already\navailable alongside its index. Using the index to look up the item is\nunnecessary.",
      "example": "```python\nletters = [\"a\", \"b\", \"c\"]\n\nfor index, letter in enumerate(letters):\n    print(letters[index])\n```\n\nUse instead:\n```python\nletters = [\"a\", \"b\", \"c\"]\n\nfor index, letter in enumerate(letters):\n    print(letter)\n```"
    },
    {
      "code": "PLR2004",
      "name": "magic-value-comparison",
      "summary": "Checks for the use of unnamed numerical constants (\"magic\") values in\ncomparisons.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/magic-value-comparison/",
      "whyBad": "The use of \"magic\" values can make code harder to read and maintain, as\nreaders will have to infer the meaning of the value from the context.\nSuch values are discouraged by [PEP 8].\n\nFor convenience, this rule excludes a variety of common values from the\n\"magic\" value definition, such as `0`, `1`, `\"\"`, and `\"__main__\"`.",
      "example": "```python\ndef apply_discount(price: float) -> float:\n    if price <= 100:\n        return price / 2\n    else:\n        return price\n```\n\nUse instead:\n```python\nMAX_DISCOUNT = 100\n\n\ndef apply_discount(price: float) -> float:\n    if price <= MAX_DISCOUNT:\n        return price / 2\n    else:\n        return price\n```"
    },
    {
      "code": "PLR2044",
      "name": "empty-comment",
      "summary": "Checks for a # symbol appearing on a line not followed by an actual comment.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/empty-comment/",
      "whyBad": "Empty comments don't provide any clarity to the code, and just add clutter.\nEither add a comment or delete the empty comment.",
      "example": "```python\nclass Foo:  #\n    pass\n```\n\nUse instead:\n```python\nclass Foo:\n    pass\n```"
    },
    {
      "code": "PLR5501",
      "name": "collapsible-else-if",
      "summary": "Checks for `else` blocks that consist of a single `if` statement.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/collapsible-else-if/",
      "whyBad": "If an `else` block contains a single `if` statement, it can be collapsed\ninto an `elif`, thus reducing the indentation level.",
      "example": "```python\ndef check_sign(value: int) -> None:\n    if value > 0:\n        print(\"Number is positive.\")\n    else:\n        if value < 0:\n            print(\"Number is negative.\")\n        else:\n            print(\"Number is zero.\")\n```\n\nUse instead:\n```python\ndef check_sign(value: int) -> None:\n    if value > 0:\n        print(\"Number is positive.\")\n    elif value < 0:\n        print(\"Number is negative.\")\n    else:\n        print(\"Number is zero.\")\n```"
    },
    {
      "code": "PLR6104",
      "name": "non-augmented-assignment",
      "summary": "Checks for assignments that can be replaced with augmented assignment\nstatements.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-augmented-assignment/",
      "whyBad": "If the right-hand side of an assignment statement consists of a binary\noperation in which one operand is the same as the assignment target,\nit can be rewritten as an augmented assignment. For example, `x = x + 1`\ncan be rewritten as `x += 1`.\n\nWhen performing such an operation, an augmented assignment is more concise\nand idiomatic.",
      "example": "```python\nx = x + 1\n```\n\nUse instead:\n```python\nx += 1\n```"
    },
    {
      "code": "PLR6201",
      "name": "literal-membership",
      "summary": "Checks for membership tests on `list` and `tuple` literals.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/literal-membership/",
      "whyBad": "When testing for membership in a static sequence, prefer a `set` literal\nover a `list` or `tuple`, as Python optimizes `set` membership tests.",
      "example": "```python\n1 in [1, 2, 3]\n```\n\nUse instead:\n```python\n1 in {1, 2, 3}\n```"
    },
    {
      "code": "PLR6301",
      "name": "no-self-use",
      "summary": "Checks for the presence of unused `self` parameter in methods definitions.",
      "category": "Pylint",
      "categoryCode": "PLR",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/no-self-use/",
      "whyBad": "Unused `self` parameters are usually a sign of a method that could be\nreplaced by a function, class method, or static method.\n\nThis rule exempts methods decorated with [`@typing.override`][override].\nConverting an instance method into a static method or class method may\ncause type checkers to complain about a violation of the Liskov\nSubstitution Principle if it means that the method now incompatibly\noverrides a method defined on a superclass. Explicitly decorating an\noverriding method with `@override` signals to Ruff that the method is\nintended to override a superclass method and that a type checker will\nenforce that it does so; Ruff therefore knows that it should not enforce\nrules about unused `self` parameters on such methods.",
      "example": "```python\nclass Person:\n    def greeting(self):\n        print(\"Greetings friend!\")\n```\n\nUse instead:\n```python\ndef greeting():\n    print(\"Greetings friend!\")\n```\n\nor\n\n```python\nclass Person:\n    @staticmethod\n    def greeting():\n        print(\"Greetings friend!\")\n```\n\n[override]: https://docs.python.org/3/library/typing.html#typing.override"
    },
    {
      "code": "PLW0108",
      "name": "unnecessary-lambda",
      "summary": "Checks for `lambda` definitions that consist of a single function call\nwith the same arguments as the `lambda` itself.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-lambda/",
      "whyBad": "When a `lambda` is used to wrap a function call, and merely propagates\nthe `lambda` arguments to that function, it can typically be replaced with\nthe function itself, removing a level of indirection.",
      "example": "```python\ndf.apply(lambda x: str(x))\n```\n\nUse instead:\n```python\ndf.apply(str)\n```"
    },
    {
      "code": "PLW0120",
      "name": "useless-else-on-loop",
      "summary": "Checks for `else` clauses on loops without a `break` statement.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-else-on-loop/",
      "whyBad": "When a loop includes an `else` statement, the code inside the `else` clause\nwill be executed if the loop terminates \"normally\" (i.e., without a\n`break`).\n\nIf a loop _always_ terminates \"normally\" (i.e., does _not_ contain a\n`break`), then the `else` clause is redundant, as the code inside the\n`else` clause will always be executed.\n\nIn such cases, the code inside the `else` clause can be moved outside the\nloop entirely, and the `else` clause can be removed.",
      "example": "```python\nfor item in items:\n    print(item)\nelse:\n    print(\"All items printed\")\n```\n\nUse instead:\n```python\nfor item in items:\n    print(item)\nprint(\"All items printed\")\n```"
    },
    {
      "code": "PLW0127",
      "name": "self-assigning-variable",
      "summary": "Checks for self-assignment of variables.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/self-assigning-variable/",
      "whyBad": "Self-assignment of variables is redundant and likely a mistake.",
      "example": "```python\ncountry = \"Poland\"\ncountry = country\n```\n\nUse instead:\n```python\ncountry = \"Poland\"\n```"
    },
    {
      "code": "PLW0128",
      "name": "redeclared-assigned-name",
      "summary": "Checks for declared assignments to the same variable multiple times\nin the same assignment.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redeclared-assigned-name/",
      "whyBad": "Assigning a variable multiple times in the same assignment is redundant,\nas the final assignment to the variable is what the value will be.",
      "example": "```python\na, b, a = (1, 2, 3)\nprint(a)  # 3\n```\n\nUse instead:\n```python"
    },
    {
      "code": "PLW0129",
      "name": "assert-on-string-literal",
      "summary": "Checks for `assert` statements that use a string literal as the first\nargument.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assert-on-string-literal/",
      "whyBad": "An `assert` on a non-empty string literal will always pass, while an\n`assert` on an empty string literal will always fail.",
      "example": "```python\nassert \"always true\"\n```"
    },
    {
      "code": "PLW0131",
      "name": "named-expr-without-context",
      "summary": "Checks for uses of named expressions (e.g., `a := 42`) that can be\nreplaced by regular assignment statements (e.g., `a = 42`).",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/named-expr-without-context/",
      "whyBad": "While a top-level named expression is syntactically and semantically valid,\nit's less clear than a regular assignment statement. Named expressions are\nintended to be used in comprehensions and generator expressions, where\nassignment statements are not allowed.",
      "example": "```python\n(a := 42)\n```\n\nUse instead:\n```python\na = 42\n```"
    },
    {
      "code": "PLW0133",
      "name": "useless-exception-statement",
      "summary": "Checks for an exception that is not raised.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-exception-statement/",
      "whyBad": "It's unnecessary to create an exception without raising it. For example,\n`ValueError(\"...\")` on its own will have no effect (unlike\n`raise ValueError(\"...\")`) and is likely a mistake.",
      "example": "```python\nValueError(\"...\")\n```\n\nUse instead:\n```python\nraise ValueError(\"...\")\n```"
    },
    {
      "code": "PLW0177",
      "name": "nan-comparison",
      "summary": "Checks for comparisons against NaN values.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/nan-comparison/",
      "whyBad": "Comparing against a NaN value can lead to unexpected results. For example,\n`float(\"NaN\") == float(\"NaN\")` will return `False` and, in general,\n`x == float(\"NaN\")` will always return `False`, even if `x` is `NaN`.\n\nTo determine whether a value is `NaN`, use `math.isnan` or `np.isnan`\ninstead of comparing against `NaN` directly.",
      "example": "```python\nif x == float(\"NaN\"):\n    pass\n```\n\nUse instead:\n```python\nimport math\n\nif math.isnan(x):\n    pass\n```"
    },
    {
      "code": "PLW0211",
      "name": "bad-staticmethod-argument",
      "summary": "Checks for static methods that use `self` or `cls` as their first argument.\nThis rule also applies to `__new__` methods, which are implicitly static.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-staticmethod-argument/",
      "whyBad": "[PEP 8] recommends the use of `self` and `cls` as the first arguments for\ninstance methods and class methods, respectively. Naming the first argument\nof a static method as `self` or `cls` can be misleading, as static methods\ndo not receive an instance or class reference as their first argument.",
      "example": "```python\nclass Wolf:\n    @staticmethod\n    def eat(self):\n        pass\n```\n\nUse instead:\n```python\nclass Wolf:\n    @staticmethod\n    def eat(sheep):\n        pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#function-and-method-arguments"
    },
    {
      "code": "PLW0244",
      "name": "redefined-slots-in-subclass",
      "summary": "Checks for a re-defined slot in a subclass.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redefined-slots-in-subclass/",
      "whyBad": "If a class defines a slot also defined in a base class, the\ninstance variable defined by the base class slot is inaccessible\n(except by retrieving its descriptor directly from the base class).",
      "example": "```python\nclass Base:\n    __slots__ = (\"a\", \"b\")\n\n\nclass Subclass(Base):\n    __slots__ = (\"a\", \"d\")  # slot \"a\" redefined\n```\n\nUse instead:\n```python\nclass Base:\n    __slots__ = (\"a\", \"b\")\n\n\nclass Subclass(Base):\n    __slots__ = \"d\"\n```"
    },
    {
      "code": "PLW0245",
      "name": "super-without-brackets",
      "summary": "Detects attempts to use `super` without parentheses.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/super-without-brackets/",
      "whyBad": "The [`super()` callable](https://docs.python.org/3/library/functions.html#super)\ncan be used inside method definitions to create a proxy object that\ndelegates attribute access to a superclass of the current class. Attempting\nto access attributes on `super` itself, however, instead of the object\nreturned by a call to `super()`, will raise `AttributeError`.",
      "example": "```python\nclass Animal:\n    @staticmethod\n    def speak():\n        return \"This animal says something.\"\n\n\nclass Dog(Animal):\n    @staticmethod\n    def speak():\n        original_speak = super.speak()  # ERROR: `super.speak()`\n        return f\"{original_speak} But as a dog, it barks!\"\n```\n\nUse instead:\n```python\nclass Animal:\n    @staticmethod\n    def speak():\n        return \"This animal says something.\"\n\n\nclass Dog(Animal):\n    @staticmethod\n    def speak():\n        original_speak = super().speak()  # Correct: `super().speak()`\n        return f\"{original_speak} But as a dog, it barks!\"\n```"
    },
    {
      "code": "PLW0406",
      "name": "import-self",
      "summary": "Checks for import statements that import the current module.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/import-self/",
      "whyBad": "Importing a module from itself is a circular dependency and results\nin an `ImportError` exception.",
      "example": "```python"
    },
    {
      "code": "PLW0602",
      "name": "global-variable-not-assigned",
      "summary": "Checks for `global` variables that are not assigned a value in the current\nscope.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/global-variable-not-assigned/",
      "whyBad": "The `global` keyword allows an inner scope to modify a variable declared\nin the outer scope. If the variable is not modified within the inner scope,\nthere is no need to use `global`.",
      "example": "```python\nDEBUG = True\n\n\ndef foo():\n    global DEBUG\n    if DEBUG:\n        print(\"foo() called\")\n    ...\n```\n\nUse instead:\n```python\nDEBUG = True\n\n\ndef foo():\n    if DEBUG:\n        print(\"foo() called\")\n    ...\n```"
    },
    {
      "code": "PLW0603",
      "name": "global-statement",
      "summary": "Checks for the use of `global` statements to update identifiers.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/global-statement/",
      "whyBad": "Pylint discourages the use of `global` variables as global mutable\nstate is a common source of bugs and confusing behavior.",
      "example": "```python\nvar = 1\n\n\ndef foo():\n    global var  # [global-statement]\n    var = 10\n    print(var)\n\n\nfoo()\nprint(var)\n```\n\nUse instead:\n```python\nvar = 1\n\n\ndef foo():\n    var = 10\n    print(var)\n    return var\n\n\nvar = foo()\nprint(var)\n```"
    },
    {
      "code": "PLW0604",
      "name": "global-at-module-level",
      "summary": "Checks for uses of the `global` keyword at the module level.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/global-at-module-level/",
      "whyBad": "The `global` keyword is used within functions to indicate that a name\nrefers to a global variable, rather than a local variable.\n\nAt the module level, all names are global by default, so the `global`\nkeyword is redundant."
    },
    {
      "code": "PLW0642",
      "name": "self-or-cls-assignment",
      "summary": "Checks for assignment of `self` and `cls` in instance and class methods respectively.\n\nThis check also applies to `__new__` even though this is technically\na static method.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/self-or-cls-assignment/",
      "whyBad": "The identifiers `self` and `cls` are conventional in Python for the first parameter of instance\nmethods and class methods, respectively. Assigning new values to these variables can be\nconfusing for others reading your code; using a different variable name can lead to clearer\ncode.",
      "example": "```python\nclass Version:\n    def add(self, other):\n        self = self + other\n        return self\n\n    @classmethod\n    def superclass(cls):\n        cls = cls.__mro__[-1]\n        return cls\n```\n\nUse instead:\n```python\nclass Version:\n    def add(self, other):\n        new_version = self + other\n        return new_version\n\n    @classmethod\n    def superclass(cls):\n        supercls = cls.__mro__[-1]\n        return supercls\n```"
    },
    {
      "code": "PLW0711",
      "name": "binary-op-exception",
      "summary": "Checks for `except` clauses that attempt to catch multiple\nexceptions with a binary operation (`and` or `or`).",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/binary-op-exception/",
      "whyBad": "A binary operation will not catch multiple exceptions. Instead, the binary\noperation will be evaluated first, and the result of _that_ operation will\nbe caught (for an `or` operation, this is typically the first exception in\nthe list). This is almost never the desired behavior.",
      "example": "```python\ntry:\n    pass\nexcept A or B:\n    pass\n```\n\nUse instead:\n```python\ntry:\n    pass\nexcept (A, B):\n    pass\n```"
    },
    {
      "code": "PLW1501",
      "name": "bad-open-mode",
      "summary": "Check for an invalid `mode` argument in `open` calls.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-open-mode/",
      "whyBad": "The `open` function accepts a `mode` argument that specifies how the file\nshould be opened (e.g., read-only, write-only, append-only, etc.).\n\nPython supports a variety of open modes: `r`, `w`, `a`, and `x`, to control\nreading, writing, appending, and creating, respectively, along with\n`b` (binary mode), `+` (read and write), and `U` (universal newlines),\nthe latter of which is only valid alongside `r`. This rule detects both\ninvalid combinations of modes and invalid characters in the mode string\nitself.",
      "example": "```python\nwith open(\"file\", \"rwx\") as f:\n    content = f.read()\n```\n\nUse instead:\n\n```python\nwith open(\"file\", \"r\") as f:\n    content = f.read()\n```"
    },
    {
      "code": "PLW1507",
      "name": "shallow-copy-environ",
      "summary": "Check for shallow `os.environ` copies.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/shallow-copy-environ/",
      "whyBad": "`os.environ` is not a `dict` object, but rather, a proxy object. As such, mutating a shallow\ncopy of `os.environ` will also mutate the original object.\n\nSee [BPO 15373] for more information.",
      "example": "```python\nimport copy\nimport os\n\nenv = copy.copy(os.environ)\n```\n\nUse instead:\n```python\nimport os\n\nenv = os.environ.copy()\n```"
    },
    {
      "code": "PLW1508",
      "name": "invalid-envvar-default",
      "summary": "Checks for `os.getenv` calls with invalid default values.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-envvar-default/",
      "whyBad": "If an environment variable is set, `os.getenv` will return its value as\na string. If the environment variable is _not_ set, `os.getenv` will\nreturn `None`, or the default value if one is provided.\n\nIf the default value is not a string or `None`, then it will be\ninconsistent with the return type of `os.getenv`, which can lead to\nconfusing behavior.",
      "example": "```python\nimport os\n\nint(os.getenv(\"FOO\", 1))\n```\n\nUse instead:\n```python\nimport os\n\nint(os.getenv(\"FOO\", \"1\"))\n```"
    },
    {
      "code": "PLW1509",
      "name": "subprocess-popen-preexec-fn",
      "summary": "Checks for uses of `subprocess.Popen` with a `preexec_fn` argument.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/subprocess-popen-preexec-fn/",
      "whyBad": "The `preexec_fn` argument is unsafe within threads as it can lead to\ndeadlocks. Furthermore, `preexec_fn` is [targeted for deprecation].\n\nInstead, consider using task-specific arguments such as `env`,\n`start_new_session`, and `process_group`. These are not prone to deadlocks\nand are more explicit.",
      "example": "```python\nimport os, subprocess\n\nsubprocess.Popen(foo, preexec_fn=os.setsid)\nsubprocess.Popen(bar, preexec_fn=os.setpgid(0, 0))\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.Popen(foo, start_new_session=True)\nsubprocess.Popen(bar, process_group=0)  # Introduced in Python 3.11\n```"
    },
    {
      "code": "PLW1510",
      "name": "subprocess-run-without-check",
      "summary": "Checks for uses of `subprocess.run` without an explicit `check` argument.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/subprocess-run-without-check/",
      "whyBad": "By default, `subprocess.run` does not check the return code of the process\nit runs. This can lead to silent failures.\n\nInstead, consider using `check=True` to raise an exception if the process\nfails, or set `check=False` explicitly to mark the behavior as intentional.",
      "example": "```python\nimport subprocess\n\nsubprocess.run([\"ls\", \"nonexistent\"])  # No exception raised.\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.run([\"ls\", \"nonexistent\"], check=True)  # Raises exception.\n```\n\nOr:\n```python\nimport subprocess\n\nsubprocess.run([\"ls\", \"nonexistent\"], check=False)  # Explicitly no check.\n```"
    },
    {
      "code": "PLW1514",
      "name": "unspecified-encoding",
      "summary": "Checks for uses of `open` and related calls without an explicit `encoding`\nargument.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unspecified-encoding/",
      "whyBad": "Using `open` in text mode without an explicit encoding can lead to\nnon-portable code, with differing behavior across platforms. While readers\nmay assume that UTF-8 is the default encoding, in reality, the default\nis locale-specific.\n\nInstead, consider using the `encoding` parameter to enforce a specific\nencoding. [PEP 597] recommends the use of `encoding=\"utf-8\"` as a default,\nand suggests that it may become the default in future versions of Python.\n\nIf a locale-specific encoding is intended, use `encoding=\"locale\"`  on\nPython 3.10 and later, or `locale.getpreferredencoding()` on earlier versions,\nto make the encoding explicit.",
      "example": "```python\nopen(\"file.txt\")\n```\n\nUse instead:\n```python\nopen(\"file.txt\", encoding=\"utf-8\")\n```"
    },
    {
      "code": "PLW1641",
      "name": "eq-without-hash",
      "summary": "Checks for classes that implement `__eq__` but not `__hash__`.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/eq-without-hash/",
      "whyBad": "A class that implements `__eq__` but not `__hash__` will have its hash\nmethod implicitly set to `None`, regardless of if a superclass defines\n`__hash__`. This will cause the class to be unhashable, which will in turn\ncause issues when using instances of the class as keys in a dictionary or\nmembers of a set.",
      "example": "```python\nclass Person:\n    def __init__(self):\n        self.name = \"monty\"\n\n    def __eq__(self, other):\n        return isinstance(other, Person) and other.name == self.name\n```\n\nUse instead:\n\n```python\nclass Person:\n    def __init__(self):\n        self.name = \"monty\"\n\n    def __eq__(self, other):\n        return isinstance(other, Person) and other.name == self.name\n\n    def __hash__(self):\n        return hash(self.name)\n```\n\nIn general, it is unsound to inherit a `__hash__` implementation from a parent class while\noverriding the `__eq__` implementation because the two must be kept in sync. However, an easy\nway to resolve this error in cases where it _is_ sound is to explicitly set `__hash__` to the\nparent class's implementation:\n\n```python\nclass Developer(Person):\n    def __init__(self): ...\n\n    def __eq__(self, other): ...\n\n    __hash__ = Person.__hash__\n```"
    },
    {
      "code": "PLW2101",
      "name": "useless-with-lock",
      "summary": "Checks for lock objects that are created and immediately discarded in\n`with` statements.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-with-lock/",
      "whyBad": "Creating a lock (via `threading.Lock` or similar) in a `with` statement\nhas no effect, as locks are only relevant when shared between threads.\n\nInstead, assign the lock to a variable outside the `with` statement,\nand share that variable between threads.",
      "example": "```python\nimport threading\n\ncounter = 0\n\n\ndef increment():\n    global counter\n\n    with threading.Lock():\n        counter += 1\n```\n\nUse instead:\n```python\nimport threading\n\ncounter = 0\nlock = threading.Lock()\n\n\ndef increment():\n    global counter\n\n    with lock:\n        counter += 1\n```"
    },
    {
      "code": "PLW2901",
      "name": "redefined-loop-name",
      "summary": "Checks for variables defined in `for` loops and `with` statements that\nget overwritten within the body, for example by another `for` loop or\n`with` statement or by direct assignment.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redefined-loop-name/",
      "whyBad": "Redefinition of a loop variable inside the loop's body causes its value\nto differ from the original loop iteration for the remainder of the\nblock, in a way that will likely cause bugs.\n\nIn Python, unlike many other languages, `for` loops and `with`\nstatements don't define their own scopes. Therefore, a nested loop that\nuses the same target variable name as an outer loop will reuse the same\nactual variable, and the value from the last iteration will \"leak out\"\ninto the remainder of the enclosing loop.\n\nWhile this mistake is easy to spot in small examples, it can be hidden\nin larger blocks of code, where the definition and redefinition of the\nvariable may not be visible at the same time.",
      "example": "```python\nfor i in range(10):\n    i = 9\n    print(i)  # prints 9 every iteration\n\nfor i in range(10):\n    for i in range(10):  # original value overwritten\n        pass\n    print(i)  # also prints 9 every iteration\n\nwith path1.open() as f:\n    with path2.open() as f:\n        f = path2.open()\n    print(f.readline())  # prints a line from path2\n```"
    },
    {
      "code": "PLW3201",
      "name": "bad-dunder-method-name",
      "summary": "Checks for dunder methods that have no special meaning in Python 3.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bad-dunder-method-name/",
      "whyBad": "Misspelled or no longer supported dunder name methods may cause your code to not function\nas expected.\n\nSince dunder methods are associated with customizing the behavior\nof a class in Python, introducing a dunder method such as `__foo__`\nthat diverges from standard Python dunder methods could potentially\nconfuse someone reading the code.\n\nThis rule will detect all methods starting and ending with at least\none underscore (e.g., `_str_`), but ignores known dunder methods (like\n`__init__`), as well as methods that are marked with [`@override`][override].\n\nAdditional dunder methods names can be allowed via the\n[`lint.pylint.allow-dunder-method-names`] setting.",
      "example": "```python\nclass Foo:\n    def __init_(self): ...\n```\n\nUse instead:\n\n```python\nclass Foo:\n    def __init__(self): ...\n```"
    },
    {
      "code": "PLW3301",
      "name": "nested-min-max",
      "summary": "Checks for nested `min` and `max` calls.",
      "category": "Pylint",
      "categoryCode": "PLW",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/nested-min-max/",
      "whyBad": "Nested `min` and `max` calls can be flattened into a single call to improve\nreadability.",
      "example": "```python\nminimum = min(1, 2, min(3, 4, 5))\nmaximum = max(1, 2, max(3, 4, 5))\ndiff = maximum - minimum\n```\n\nUse instead:\n\n```python\nminimum = min(1, 2, 3, 4, 5)\nmaximum = max(1, 2, 3, 4, 5)\ndiff = maximum - minimum\n```"
    },
    {
      "code": "UP001",
      "name": "useless-metaclass-type",
      "summary": "Checks for the use of `__metaclass__ = type` in class definitions.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-metaclass-type/",
      "whyBad": "Since Python 3, `__metaclass__ = type` is implied and can thus be omitted.",
      "example": "```python\nclass Foo:\n    __metaclass__ = type\n```\n\nUse instead:\n\n```python\nclass Foo: ...\n```"
    },
    {
      "code": "UP003",
      "name": "type-of-primitive",
      "summary": "Checks for uses of `type` that take a primitive as an argument.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-of-primitive/",
      "whyBad": "`type()` returns the type of a given object. A type of a primitive can\nalways be known in advance and accessed directly, which is more concise\nand explicit than using `type()`.",
      "example": "```python\ntype(1)\n```\n\nUse instead:\n```python\nint\n```"
    },
    {
      "code": "UP004",
      "name": "useless-object-inheritance",
      "summary": "Checks for classes that inherit from `object`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-object-inheritance/",
      "whyBad": "Since Python 3, all classes inherit from `object` by default, so `object` can\nbe omitted from the list of base classes.",
      "example": "```python\nclass Foo(object): ...\n```\n\nUse instead:\n\n```python\nclass Foo: ...\n```"
    },
    {
      "code": "UP005",
      "name": "deprecated-unittest-alias",
      "summary": "Checks for uses of deprecated methods from the `unittest` module.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/deprecated-unittest-alias/",
      "whyBad": "The `unittest` module has deprecated aliases for some of its methods.\nThe deprecated aliases were removed in Python 3.12. Instead of aliases,\nuse their non-deprecated counterparts.",
      "example": "```python\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEquals(1, 1)\n```\n\nUse instead:\n```python\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEqual(1, 1)\n```"
    },
    {
      "code": "UP006",
      "name": "non-pep585-annotation",
      "summary": "Checks for the use of generics that can be replaced with standard library\nvariants based on [PEP 585].",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-pep585-annotation/",
      "whyBad": "[PEP 585] enabled collections in the Python standard library (like `list`)\nto be used as generics directly, instead of importing analogous members\nfrom the `typing` module (like `typing.List`).\n\nWhen available, the [PEP 585] syntax should be used instead of importing\nmembers from the `typing` module, as it's more concise and readable.\nImporting those members from `typing` is considered deprecated as of [PEP\n585].\n\nThis rule is enabled when targeting Python 3.9 or later (see:\n[`target-version`]). By default, it's _also_ enabled for earlier Python\nversions if `from __future__ import annotations` is present, as\n`__future__` annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.9\nby setting [`lint.pyupgrade.keep-runtime-typing`] to `true`.",
      "example": "```python\nfrom typing import List\n\nfoo: List[int] = [1, 2, 3]\n```\n\nUse instead:\n```python\nfoo: list[int] = [1, 2, 3]\n```"
    },
    {
      "code": "UP007",
      "name": "non-pep604-annotation-union",
      "summary": "Check for type annotations that can be rewritten based on [PEP 604] syntax.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-pep604-annotation-union/",
      "whyBad": "[PEP 604] introduced a new syntax for union type annotations based on the\n`|` operator. This syntax is more concise and readable than the previous\n`typing.Union` and `typing.Optional` syntaxes.\n\nThis rule is enabled when targeting Python 3.10 or later (see:\n[`target-version`]). By default, it's _also_ enabled for earlier Python\nversions if `from __future__ import annotations` is present, as\n`__future__` annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.10\nby setting [`lint.pyupgrade.keep-runtime-typing`] to `true`.",
      "example": "```python\nfrom typing import Union\n\nfoo: Union[int, str] = 1\n```\n\nUse instead:\n```python\nfoo: int | str = 1\n```\n\nNote that this rule only checks for usages of `typing.Union`,\nwhile `UP045` checks for `typing.Optional`."
    },
    {
      "code": "UP008",
      "name": "super-call-with-parameters",
      "summary": "Checks for `super` calls that pass redundant arguments.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/super-call-with-parameters/",
      "whyBad": "In Python 3, `super` can be invoked without any arguments when: (1) the\nfirst argument is `__class__`, and (2) the second argument is equivalent to\nthe first argument of the enclosing method.\n\nWhen possible, omit the arguments to `super` to make the code more concise\nand maintainable.",
      "example": "```python\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super(B, self).foo()\n```\n\nUse instead:\n```python\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super().foo()\n```"
    },
    {
      "code": "UP009",
      "name": "utf8-encoding-declaration",
      "summary": "Checks for unnecessary UTF-8 encoding declarations.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/utf8-encoding-declaration/",
      "whyBad": "[PEP 3120] makes UTF-8 the default encoding, so a UTF-8 encoding\ndeclaration is unnecessary.",
      "example": "```python\n# -*- coding: utf-8 -*-\nprint(\"Hello, world!\")\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\")\n```\n\n[PEP 3120]: https://peps.python.org/pep-3120/"
    },
    {
      "code": "UP010",
      "name": "unnecessary-future-import",
      "summary": "Checks for unnecessary `__future__` imports.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-future-import/",
      "whyBad": "The `__future__` module is used to enable features that are not yet\navailable in the current Python version. If a feature is already\navailable in the minimum supported Python version, importing it\nfrom `__future__` is unnecessary and should be removed to avoid\nconfusion.",
      "example": "```python\nfrom __future__ import print_function\n\nprint(\"Hello, world!\")\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\")\n```"
    },
    {
      "code": "UP011",
      "name": "lru-cache-without-parameters",
      "summary": "Checks for unnecessary parentheses on `functools.lru_cache` decorators.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/lru-cache-without-parameters/",
      "whyBad": "Since Python 3.8, `functools.lru_cache` can be used as a decorator without\ntrailing parentheses, as long as no arguments are passed to it.",
      "example": "```python\nimport functools\n\n\n@functools.lru_cache()\ndef foo(): ...\n```\n\nUse instead:\n\n```python\nimport functools\n\n\n@functools.lru_cache\ndef foo(): ...\n```"
    },
    {
      "code": "UP012",
      "name": "unnecessary-encode-utf8",
      "summary": "Checks for unnecessary calls to `encode` as UTF-8.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-encode-utf8/",
      "whyBad": "UTF-8 is the default encoding in Python, so there is no need to call\n`encode` when UTF-8 is the desired encoding. Instead, use a bytes literal.",
      "example": "```python\n\"foo\".encode(\"utf-8\")\n```\n\nUse instead:\n```python\nb\"foo\"\n```"
    },
    {
      "code": "UP013",
      "name": "convert-typed-dict-functional-to-class",
      "summary": "Checks for `TypedDict` declarations that use functional syntax.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/convert-typed-dict-functional-to-class/",
      "whyBad": "`TypedDict` types can be defined either through a functional syntax\n(`Foo = TypedDict(...)`) or a class syntax (`class Foo(TypedDict): ...`).\n\nThe class syntax is more readable and generally preferred over the\nfunctional syntax.\n\nNonetheless, there are some situations in which it is impossible to use\nthe class-based syntax. This rule will not apply to those cases. Namely,\nit is impossible to use the class-based syntax if any `TypedDict` fields are:\n- Not valid [python identifiers] (for example, `@x`)\n- [Python keywords] such as `in`\n- [Private names] such as `__id` that would undergo [name mangling] at runtime\n  if the class-based syntax was used\n- [Dunder names] such as `__int__` that can confuse type checkers if they're used\n  with the class-based syntax.",
      "example": "```python\nfrom typing import TypedDict\n\nFoo = TypedDict(\"Foo\", {\"a\": int, \"b\": str})\n```\n\nUse instead:\n```python\nfrom typing import TypedDict\n\n\nclass Foo(TypedDict):\n    a: int\n    b: str\n```"
    },
    {
      "code": "UP014",
      "name": "convert-named-tuple-functional-to-class",
      "summary": "Checks for `NamedTuple` declarations that use functional syntax.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/convert-named-tuple-functional-to-class/",
      "whyBad": "`NamedTuple` subclasses can be defined either through a functional syntax\n(`Foo = NamedTuple(...)`) or a class syntax (`class Foo(NamedTuple): ...`).\n\nThe class syntax is more readable and generally preferred over the\nfunctional syntax, which exists primarily for backwards compatibility\nwith `collections.namedtuple`.",
      "example": "```python\nfrom typing import NamedTuple\n\nFoo = NamedTuple(\"Foo\", [(\"a\", int), (\"b\", str)])\n```\n\nUse instead:\n```python\nfrom typing import NamedTuple\n\n\nclass Foo(NamedTuple):\n    a: int\n    b: str\n```"
    },
    {
      "code": "UP015",
      "name": "redundant-open-modes",
      "summary": "Checks for redundant `open` mode arguments.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-open-modes/",
      "whyBad": "Redundant `open` mode arguments are unnecessary and should be removed to\navoid confusion.",
      "example": "```python\nwith open(\"foo.txt\", \"r\") as f:\n    ...\n```\n\nUse instead:\n```python\nwith open(\"foo.txt\") as f:\n    ...\n```"
    },
    {
      "code": "UP017",
      "name": "datetime-timezone-utc",
      "summary": "Checks for uses of `datetime.timezone.utc`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/datetime-timezone-utc/",
      "whyBad": "As of Python 3.11, `datetime.UTC` is an alias for `datetime.timezone.utc`.\nThe alias is more readable and generally preferred over the full path.",
      "example": "```python\nimport datetime\n\ndatetime.timezone.utc\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.UTC\n```"
    },
    {
      "code": "UP018",
      "name": "native-literals",
      "summary": "Checks for unnecessary calls to `str`, `bytes`, `int`, `float`, and `bool`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/native-literals/",
      "whyBad": "The mentioned constructors can be replaced with their respective literal\nforms, which are more readable and idiomatic.",
      "example": "```python\nstr(\"foo\")\n```\n\nUse instead:\n```python\n\"foo\"\n```"
    },
    {
      "code": "UP019",
      "name": "typing-text-str-alias",
      "summary": "Checks for uses of `typing.Text`.\n\nIn preview mode, also checks for `typing_extensions.Text`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/typing-text-str-alias/",
      "whyBad": "`typing.Text` is an alias for `str`, and only exists for Python 2\ncompatibility. As of Python 3.11, `typing.Text` is deprecated. Use `str`\ninstead.",
      "example": "```python\nfrom typing import Text\n\nfoo: Text = \"bar\"\n```\n\nUse instead:\n```python\nfoo: str = \"bar\"\n```"
    },
    {
      "code": "UP020",
      "name": "open-alias",
      "summary": "Checks for uses of `io.open`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/open-alias/",
      "whyBad": "In Python 3, `io.open` is an alias for `open`. Prefer using `open` directly,\nas it is more idiomatic.",
      "example": "```python\nimport io\n\nwith io.open(\"file.txt\") as f:\n    ...\n```\n\nUse instead:\n```python\nwith open(\"file.txt\") as f:\n    ...\n```"
    },
    {
      "code": "UP021",
      "name": "replace-universal-newlines",
      "summary": "Checks for uses of `subprocess.run` that set the `universal_newlines`\nkeyword argument.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/replace-universal-newlines/",
      "whyBad": "As of Python 3.7, the `universal_newlines` keyword argument has been\nrenamed to `text`, and now exists for backwards compatibility. The\n`universal_newlines` keyword argument may be removed in a future version of\nPython. Prefer `text`, which is more explicit and readable.",
      "example": "```python\nimport subprocess\n\nsubprocess.run([\"foo\"], universal_newlines=True)\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.run([\"foo\"], text=True)\n```"
    },
    {
      "code": "UP022",
      "name": "replace-stdout-stderr",
      "summary": "Checks for uses of `subprocess.run` that send `stdout` and `stderr` to a\npipe.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/replace-stdout-stderr/",
      "whyBad": "As of Python 3.7, `subprocess.run` has a `capture_output` keyword argument\nthat can be set to `True` to capture `stdout` and `stderr` outputs. This is\nequivalent to setting `stdout` and `stderr` to `subprocess.PIPE`, but is\nmore explicit and readable.",
      "example": "```python\nimport subprocess\n\nsubprocess.run([\"foo\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.run([\"foo\"], capture_output=True)\n```"
    },
    {
      "code": "UP023",
      "name": "deprecated-c-element-tree",
      "summary": "Checks for uses of the `xml.etree.cElementTree` module.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/deprecated-c-element-tree/",
      "whyBad": "In Python 3.3, `xml.etree.cElementTree` was deprecated in favor of\n`xml.etree.ElementTree`.",
      "example": "```python\nfrom xml.etree import cElementTree as ET\n```\n\nUse instead:\n```python\nfrom xml.etree import ElementTree as ET\n```"
    },
    {
      "code": "UP024",
      "name": "os-error-alias",
      "summary": "Checks for uses of exceptions that alias `OSError`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/os-error-alias/",
      "whyBad": "`OSError` is the builtin error type used for exceptions that relate to the\noperating system.\n\nIn Python 3.3, a variety of other exceptions, like `WindowsError` were\naliased to `OSError`. These aliases remain in place for compatibility with\nolder versions of Python, but may be removed in future versions.\n\nPrefer using `OSError` directly, as it is more idiomatic and future-proof.",
      "example": "```python\nraise IOError\n```\n\nUse instead:\n```python\nraise OSError\n```"
    },
    {
      "code": "UP025",
      "name": "unicode-kind-prefix",
      "summary": "Checks for uses of the Unicode kind prefix (`u`) in strings.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unicode-kind-prefix/",
      "whyBad": "In Python 3, all strings are Unicode by default. The Unicode kind prefix is\nunnecessary and should be removed to avoid confusion.",
      "example": "```python\nu\"foo\"\n```\n\nUse instead:\n```python\n\"foo\"\n```"
    },
    {
      "code": "UP026",
      "name": "deprecated-mock-import",
      "summary": "Checks for imports of the `mock` module that should be replaced with\n`unittest.mock`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/deprecated-mock-import/",
      "whyBad": "Since Python 3.3, `mock` has been a part of the standard library as\n`unittest.mock`. The `mock` package is deprecated; use `unittest.mock`\ninstead.",
      "example": "```python\nimport mock\n```\n\nUse instead:\n```python\nfrom unittest import mock\n```"
    },
    {
      "code": "UP027",
      "name": "unpacked-list-comprehension",
      "summary": "Checks for list comprehensions that are immediately unpacked.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unpacked-list-comprehension/",
      "whyBad": "There is no reason to use a list comprehension if the result is immediately\nunpacked. Instead, use a generator expression, which avoids allocating\nan intermediary list.",
      "example": "```python\na, b, c = [foo(x) for x in items]\n```\n\nUse instead:\n```python\na, b, c = (foo(x) for x in items)\n```"
    },
    {
      "code": "UP028",
      "name": "yield-in-for-loop",
      "summary": "Checks for `for` loops that can be replaced with `yield from` expressions.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/yield-in-for-loop/",
      "whyBad": "If a `for` loop only contains a `yield` statement, it can be replaced with a\n`yield from` expression, which is more concise and idiomatic.",
      "example": "```python\ndef bar():\n    for x in foo:\n        yield x\n\n    global y\n    for y in foo:\n        yield y\n```\n\nUse instead:\n```python\ndef bar():\n    yield from foo\n\n    for _element in foo:\n        y = _element\n        yield y\n```"
    },
    {
      "code": "UP029",
      "name": "unnecessary-builtin-import",
      "summary": "Checks for unnecessary imports of builtins.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-builtin-import/",
      "whyBad": "Builtins are always available. Importing them is unnecessary and should be\nremoved to avoid confusion.",
      "example": "```python\nfrom builtins import str\n\nstr(1)\n```\n\nUse instead:\n```python\nstr(1)\n```"
    },
    {
      "code": "UP030",
      "name": "format-literals",
      "summary": "Checks for unnecessary positional indices in format strings.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/format-literals/",
      "whyBad": "In Python 3.1 and later, format strings can use implicit positional\nreferences. For example, `\"{0}, {1}\".format(\"Hello\", \"World\")` can be\nrewritten as `\"{}, {}\".format(\"Hello\", \"World\")`.\n\nIf the positional indices appear exactly in-order, they can be omitted\nin favor of automatic indices to improve readability.",
      "example": "```python\n\"{0}, {1}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n```\n\nUse instead:\n```python\n\"{}, {}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n```\n\nThis fix is marked as unsafe because:\n- Comments attached to arguments are not moved, which can cause comments to mismatch the actual arguments.\n- If arguments have side effects (e.g., print), reordering may change program behavior."
    },
    {
      "code": "UP031",
      "name": "printf-string-formatting",
      "summary": "Checks for `printf`-style string formatting, and offers to replace it with\n`str.format` calls.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/printf-string-formatting/",
      "whyBad": "`printf`-style string formatting has a number of quirks, and leads to less\nreadable code than using `str.format` calls or f-strings. In general, prefer\nthe newer `str.format` and f-strings constructs over `printf`-style string\nformatting.",
      "example": "```python\n\"%s, %s\" % (\"Hello\", \"World\")  # \"Hello, World\"\n```\n\nUse instead:\n\n```python\n\"{}, {}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n```\n\n```python\nf\"{'Hello'}, {'World'}\"  # \"Hello, World\"\n```"
    },
    {
      "code": "UP032",
      "name": "f-string",
      "summary": "Checks for `str.format` calls that can be replaced with f-strings.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/f-string/",
      "whyBad": "f-strings are more readable and generally preferred over `str.format`\ncalls.",
      "example": "```python\n\"{}\".format(foo)\n```\n\nUse instead:\n```python\nf\"{foo}\"\n```"
    },
    {
      "code": "UP033",
      "name": "lru-cache-with-maxsize-none",
      "summary": "Checks for uses of `functools.lru_cache` that set `maxsize=None`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/lru-cache-with-maxsize-none/",
      "whyBad": "Since Python 3.9, `functools.cache` can be used as a drop-in replacement\nfor `functools.lru_cache(maxsize=None)`. When possible, prefer\n`functools.cache` as it is more readable and idiomatic.",
      "example": "```python\nimport functools\n\n\n@functools.lru_cache(maxsize=None)\ndef foo(): ...\n```\n\nUse instead:\n\n```python\nimport functools\n\n\n@functools.cache\ndef foo(): ...\n```"
    },
    {
      "code": "UP034",
      "name": "extraneous-parentheses",
      "summary": "Checks for extraneous parentheses.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/extraneous-parentheses/",
      "whyBad": "Extraneous parentheses are redundant, and can be removed to improve\nreadability while retaining identical semantics.",
      "example": "```python\nprint((\"Hello, world\"))\n```\n\nUse instead:\n```python\nprint(\"Hello, world\")\n```"
    },
    {
      "code": "UP035",
      "name": "deprecated-import",
      "summary": "Checks for uses of deprecated imports based on the minimum supported\nPython version.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/deprecated-import/",
      "whyBad": "Deprecated imports may be removed in future versions of Python, and\nshould be replaced with their new equivalents.\n\nNote that, in some cases, it may be preferable to continue importing\nmembers from `typing_extensions` even after they're added to the Python\nstandard library, as `typing_extensions` can backport bugfixes and\noptimizations from later Python versions. This rule thus avoids flagging\nimports from `typing_extensions` in such cases.",
      "example": "```python\nfrom collections import Sequence\n```\n\nUse instead:\n```python\nfrom collections.abc import Sequence\n```"
    },
    {
      "code": "UP036",
      "name": "outdated-version-block",
      "summary": "Checks for conditional blocks gated on `sys.version_info` comparisons\nthat are outdated for the minimum supported Python version.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/outdated-version-block/",
      "whyBad": "In Python, code can be conditionally executed based on the active\nPython version by comparing against the `sys.version_info` tuple.\n\nIf a code block is only executed for Python versions older than the\nminimum supported version, it should be removed.",
      "example": "```python\nimport sys\n\nif sys.version_info < (3, 0):\n    print(\"py2\")\nelse:\n    print(\"py3\")\n```\n\nUse instead:\n```python\nprint(\"py3\")\n```"
    },
    {
      "code": "UP037",
      "name": "quoted-annotation",
      "summary": "Checks for the presence of unnecessary quotes in type annotations.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/quoted-annotation/",
      "whyBad": "In Python, type annotations can be quoted to avoid forward references.\n\nHowever, if `from __future__ import annotations` is present, Python\nwill always evaluate type annotations in a deferred manner, making\nthe quotes unnecessary.\n\nSimilarly, if the annotation is located in a typing-only context and\nwon't be evaluated by Python at runtime, the quotes will also be\nconsidered unnecessary. For example, Python does not evaluate type\nannotations on assignments in function bodies.",
      "example": "Given:\n\n```python\nfrom __future__ import annotations\n\n\ndef foo(bar: \"Bar\") -> \"Bar\": ...\n```\n\nUse instead:\n\n```python\nfrom __future__ import annotations\n\n\ndef foo(bar: Bar) -> Bar: ...\n```\n\nGiven:\n\n```python\ndef foo() -> None:\n    bar: \"Bar\"\n```\n\nUse instead:\n\n```python\ndef foo() -> None:\n    bar: Bar\n```"
    },
    {
      "code": "UP038",
      "name": "non-pep604-isinstance",
      "summary": "Checks for uses of `isinstance` and `issubclass` that take a tuple\nof types for comparison.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-pep604-isinstance/",
      "whyBad": "Since Python 3.10, `isinstance` and `issubclass` can be passed a\n`|`-separated union of types, which is consistent\nwith the union operator introduced in [PEP 604].\n\nNote that this results in slower code. Ignore this rule if the\nperformance of an `isinstance` or `issubclass` check is a\nconcern, e.g., in a hot loop.",
      "example": "```python\nisinstance(x, (int, float))\n```\n\nUse instead:\n```python\nisinstance(x, int | float)\n```"
    },
    {
      "code": "UP039",
      "name": "unnecessary-class-parentheses",
      "summary": "Checks for class definitions that include unnecessary parentheses after\nthe class name.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-class-parentheses/",
      "whyBad": "If a class definition doesn't have any bases, the parentheses are\nunnecessary.",
      "example": "```python\nclass Foo():\n    ...\n```\n\nUse instead:\n```python\nclass Foo:\n    ...\n```"
    },
    {
      "code": "UP040",
      "name": "non-pep695-type-alias",
      "summary": "Checks for use of `TypeAlias` annotations and `TypeAliasType` assignments\nfor declaring type aliases.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-pep695-type-alias/",
      "whyBad": "The `type` keyword was introduced in Python 3.12 by [PEP 695] for defining\ntype aliases. The `type` keyword is easier to read and provides cleaner\nsupport for generics.",
      "example": "```python\nfrom typing import Annotated, TypeAlias, TypeAliasType\nfrom annotated_types import Gt\n\nListOfInt: TypeAlias = list[int]\nPositiveInt = TypeAliasType(\"PositiveInt\", Annotated[int, Gt(0)])\n```\n\nUse instead:\n```python\nfrom typing import Annotated\nfrom annotated_types import Gt\n\ntype ListOfInt = list[int]\ntype PositiveInt = Annotated[int, Gt(0)]\n```"
    },
    {
      "code": "UP041",
      "name": "timeout-error-alias",
      "summary": "Checks for uses of exceptions that alias `TimeoutError`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/timeout-error-alias/",
      "whyBad": "`TimeoutError` is the builtin error type used for exceptions when a system\nfunction timed out at the system level.\n\nIn Python 3.10, `socket.timeout` was aliased to `TimeoutError`. In Python\n3.11, `asyncio.TimeoutError` was aliased to `TimeoutError`.\n\nThese aliases remain in place for compatibility with older versions of\nPython, but may be removed in future versions.\n\nPrefer using `TimeoutError` directly, as it is more idiomatic and future-proof.",
      "example": "```python\nimport asyncio\n\nraise asyncio.TimeoutError\n```\n\nUse instead:\n```python\nraise TimeoutError\n```"
    },
    {
      "code": "UP042",
      "name": "replace-str-enum",
      "summary": "Checks for classes that inherit from both `str` and `enum.Enum`.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/replace-str-enum/",
      "whyBad": "Python 3.11 introduced `enum.StrEnum`, which is preferred over inheriting\nfrom both `str` and `enum.Enum`.",
      "example": "```python\nimport enum\n\n\nclass Foo(str, enum.Enum): ...\n```\n\nUse instead:\n\n```python\nimport enum\n\n\nclass Foo(enum.StrEnum): ...\n```"
    },
    {
      "code": "UP043",
      "name": "unnecessary-default-type-args",
      "summary": "Checks for unnecessary default type arguments for `Generator` and\n`AsyncGenerator` on Python 3.13+.\nIn [preview], this rule will also apply to stub files.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-default-type-args/",
      "whyBad": "Python 3.13 introduced the ability for type parameters to specify default\nvalues. Following this change, several standard-library classes were\nupdated to add default values for some of their type parameters. For\nexample, `Generator[int]` is now equivalent to\n`Generator[int, None, None]`, as the second and third type parameters of\n`Generator` now default to `None`.\n\nOmitting type arguments that match the default values can make the code\nmore concise and easier to read.",
      "example": "```python\nfrom collections.abc import Generator, AsyncGenerator\n\n\ndef sync_gen() -> Generator[int, None, None]:\n    yield 42\n\n\nasync def async_gen() -> AsyncGenerator[int, None]:\n    yield 42\n```\n\nUse instead:\n\n```python\nfrom collections.abc import Generator, AsyncGenerator\n\n\ndef sync_gen() -> Generator[int]:\n    yield 42\n\n\nasync def async_gen() -> AsyncGenerator[int]:\n    yield 42\n```"
    },
    {
      "code": "UP044",
      "name": "non-pep646-unpack",
      "summary": "Checks for uses of `Unpack[]` on Python 3.11 and above, and suggests\nusing `*` instead.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-pep646-unpack/",
      "whyBad": "[PEP 646] introduced a new syntax for unpacking sequences based on the `*`\noperator. This syntax is more concise and readable than the previous\n`Unpack[]` syntax.",
      "example": "```python\nfrom typing import Unpack\n\n\ndef foo(*args: Unpack[tuple[int, ...]]) -> None:\n    pass\n```\n\nUse instead:\n```python\ndef foo(*args: *tuple[int, ...]) -> None:\n    pass\n```"
    },
    {
      "code": "UP045",
      "name": "non-pep604-annotation-optional",
      "summary": "Check for `typing.Optional` annotations that can be rewritten based on [PEP 604] syntax.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-pep604-annotation-optional/",
      "whyBad": "[PEP 604] introduced a new syntax for union type annotations based on the\n`|` operator. This syntax is more concise and readable than the previous\n`typing.Optional` syntax.\n\nThis rule is enabled when targeting Python 3.10 or later (see:\n[`target-version`]). By default, it's _also_ enabled for earlier Python\nversions if `from __future__ import annotations` is present, as\n`__future__` annotations are not evaluated at runtime. If your code relies\non runtime type annotations (either directly or via a library like\nPydantic), you can disable this behavior for Python versions prior to 3.10\nby setting [`lint.pyupgrade.keep-runtime-typing`] to `true`.",
      "example": "```python\nfrom typing import Optional\n\nfoo: Optional[int] = None\n```\n\nUse instead:\n```python\nfoo: int | None = None\n```"
    },
    {
      "code": "UP046",
      "name": "non-pep695-generic-class",
      "summary": "Checks for use of standalone type variables and parameter specifications in generic classes.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-pep695-generic-class/",
      "whyBad": "Special type parameter syntax was introduced in Python 3.12 by [PEP 695] for defining generic\nclasses. This syntax is easier to read and provides cleaner support for generics.",
      "example": "```python\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass GenericClass(Generic[T]):\n    var: T\n```\n\nUse instead:\n\n```python\nclass GenericClass[T]:\n    var: T\n```"
    },
    {
      "code": "UP047",
      "name": "non-pep695-generic-function",
      "summary": "Checks for use of standalone type variables and parameter specifications in generic functions.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-pep695-generic-function/",
      "whyBad": "Special type parameter syntax was introduced in Python 3.12 by [PEP 695] for defining generic\nfunctions. This syntax is easier to read and provides cleaner support for generics.",
      "example": "```python\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n\n\ndef generic_function(var: T) -> T:\n    return var\n```\n\nUse instead:\n\n```python\ndef generic_function[T](var: T) -> T:\n    return var\n```"
    },
    {
      "code": "UP049",
      "name": "private-type-parameter",
      "summary": "Checks for use of [PEP 695] type parameters with leading underscores in generic classes and\nfunctions.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/private-type-parameter/",
      "whyBad": "[PEP 695] type parameters are already restricted in scope to the class or function in which they\nappear, so leading underscores just hurt readability without the usual privacy benefits.\n\nHowever, neither a diagnostic nor a fix will be emitted for \"sunder\" (`_T_`) or \"dunder\"\n(`__T__`) type parameter names as these are not considered private.",
      "example": "```python\nclass GenericClass[_T]:\n    var: _T\n\n\ndef generic_function[_T](var: _T) -> list[_T]:\n    return var[0]\n```\n\nUse instead:\n\n```python\nclass GenericClass[T]:\n    var: T\n\n\ndef generic_function[T](var: T) -> list[T]:\n    return var[0]\n```"
    },
    {
      "code": "UP050",
      "name": "useless-class-metaclass-type",
      "summary": "Checks for `metaclass=type` in class definitions.",
      "category": "pyupgrade",
      "categoryCode": "UP",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-class-metaclass-type/",
      "whyBad": "Since Python 3, the default metaclass is `type`, so specifying it explicitly is redundant.\n\nEven though `__prepare__` is not required, the default metaclass (`type`) implements it,\nfor the convenience of subclasses calling it via `super()`.",
      "example": "```python\nclass Foo(metaclass=type): ...\n```\n\nUse instead:\n\n```python\nclass Foo: ...\n```"
    },
    {
      "code": "FURB101",
      "name": "read-whole-file",
      "summary": "Checks for uses of `open` and `read` that can be replaced by `pathlib`\nmethods, like `Path.read_text` and `Path.read_bytes`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/read-whole-file/",
      "whyBad": "When reading the entire contents of a file into a variable, it's simpler\nand more concise to use `pathlib` methods like `Path.read_text` and\n`Path.read_bytes` instead of `open` and `read` calls via `with` statements.",
      "example": "```python\nwith open(filename) as f:\n    contents = f.read()\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\ncontents = Path(filename).read_text()\n```"
    },
    {
      "code": "FURB103",
      "name": "write-whole-file",
      "summary": "Checks for uses of `open` and `write` that can be replaced by `pathlib`\nmethods, like `Path.write_text` and `Path.write_bytes`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/write-whole-file/",
      "whyBad": "When writing a single string to a file, it's simpler and more concise\nto use `pathlib` methods like `Path.write_text` and `Path.write_bytes`\ninstead of `open` and `write` calls via `with` statements.",
      "example": "```python\nwith open(filename, \"w\") as f:\n    f.write(contents)\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nPath(filename).write_text(contents)\n```"
    },
    {
      "code": "FURB105",
      "name": "print-empty-string",
      "summary": "Checks for `print` calls with unnecessary empty strings as positional\narguments and unnecessary `sep` keyword arguments.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/print-empty-string/",
      "whyBad": "Prefer calling `print` without any positional arguments, which is\nequivalent and more concise.\n\nSimilarly, when printing one or fewer items, the `sep` keyword argument,\n(used to define the string that separates the `print` arguments) can be\nomitted, as it's redundant when there are no items to separate.",
      "example": "```python\nprint(\"\")\n```\n\nUse instead:\n```python\nprint()\n```"
    },
    {
      "code": "FURB110",
      "name": "if-exp-instead-of-or-operator",
      "summary": "Checks for ternary `if` expressions that can be replaced with the `or`\noperator.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-exp-instead-of-or-operator/",
      "whyBad": "Ternary `if` expressions are more verbose than `or` expressions while\nproviding the same functionality.",
      "example": "```python\nz = x if x else y\n```\n\nUse instead:\n```python\nz = x or y\n```"
    },
    {
      "code": "FURB113",
      "name": "repeated-append",
      "summary": "Checks for consecutive calls to `append`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/repeated-append/",
      "whyBad": "Consecutive calls to `append` can be less efficient than batching them into\na single `extend`. Each `append` resizes the list individually, whereas an\n`extend` can resize the list once for all elements.",
      "example": "```python\nnums = [1, 2, 3]\n\nnums.append(4)\nnums.append(5)\nnums.append(6)\n```\n\nUse instead:\n```python\nnums = [1, 2, 3]\n\nnums.extend((4, 5, 6))\n```"
    },
    {
      "code": "FURB116",
      "name": "f-string-number-format",
      "summary": "Checks for uses of `bin(...)[2:]` (or `hex`, or `oct`) to convert\nan integer into a string.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/f-string-number-format/",
      "whyBad": "When converting an integer to a baseless binary, hexadecimal, or octal\nstring, using f-strings is more concise and readable than using the\n`bin`, `hex`, or `oct` functions followed by a slice.",
      "example": "```python\nprint(bin(1337)[2:])\n```\n\nUse instead:\n```python\nprint(f\"{1337:b}\")\n```"
    },
    {
      "code": "FURB118",
      "name": "reimplemented-operator",
      "summary": "Checks for lambda expressions and function definitions that can be replaced with a function from\nthe `operator` module.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/reimplemented-operator/",
      "whyBad": "The `operator` module provides functions that implement the same functionality as the\ncorresponding operators. For example, `operator.add` is often equivalent to `lambda x, y: x + y`.\nUsing the functions from the `operator` module is more concise and communicates the intent of\nthe code more clearly.",
      "example": "```python\nimport functools\n\nnums = [1, 2, 3]\ntotal = functools.reduce(lambda x, y: x + y, nums)\n```\n\nUse instead:\n```python\nimport functools\nimport operator\n\nnums = [1, 2, 3]\ntotal = functools.reduce(operator.add, nums)\n```"
    },
    {
      "code": "FURB122",
      "name": "for-loop-writes",
      "summary": "Checks for the use of `IOBase.write` in a for loop.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/for-loop-writes/",
      "whyBad": "When writing a batch of elements, it's more idiomatic to use a single method call to\n`IOBase.writelines`, rather than write elements one by one.",
      "example": "```python\nfrom pathlib import Path\n\nwith Path(\"file\").open(\"w\") as f:\n    for line in lines:\n        f.write(line)\n\nwith Path(\"file\").open(\"wb\") as f_b:\n    for line_b in lines_b:\n        f_b.write(line_b.encode())\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\nwith Path(\"file\").open(\"w\") as f:\n    f.writelines(lines)\n\nwith Path(\"file\").open(\"wb\") as f_b:\n    f_b.writelines(line_b.encode() for line_b in lines_b)\n```"
    },
    {
      "code": "FURB129",
      "name": "readlines-in-for",
      "summary": "Checks for uses of `readlines()` when iterating over a file line-by-line.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/readlines-in-for/",
      "whyBad": "Rather than iterating over all lines in a file by calling `readlines()`,\nit's more convenient and performant to iterate over the file object\ndirectly.",
      "example": "```python\nwith open(\"file.txt\") as fp:\n    for line in fp.readlines():\n        ...\n```\n\nUse instead:\n```python\nwith open(\"file.txt\") as fp:\n    for line in fp:\n        ...\n```"
    },
    {
      "code": "FURB131",
      "name": "delete-full-slice",
      "summary": "Checks for `del` statements that delete the entire slice of a list or\ndictionary.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/delete-full-slice/",
      "whyBad": "It is faster and more succinct to remove all items via the `clear()`\nmethod.",
      "example": "```python\nnames = {\"key\": \"value\"}\nnums = [1, 2, 3]\n\ndel names[:]\ndel nums[:]\n```\n\nUse instead:\n```python\nnames = {\"key\": \"value\"}\nnums = [1, 2, 3]\n\nnames.clear()\nnums.clear()\n```"
    },
    {
      "code": "FURB132",
      "name": "check-and-remove-from-set",
      "summary": "Checks for uses of `set.remove` that can be replaced with `set.discard`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/check-and-remove-from-set/",
      "whyBad": "If an element should be removed from a set if it is present, it is more\nsuccinct and idiomatic to use `discard`.",
      "example": "```python\nnums = {123, 456}\n\nif 123 in nums:\n    nums.remove(123)\n```\n\nUse instead:\n```python\nnums = {123, 456}\n\nnums.discard(123)\n```"
    },
    {
      "code": "FURB136",
      "name": "if-expr-min-max",
      "summary": "Checks for `if` expressions that can be replaced with `min()` or `max()`\ncalls.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-expr-min-max/",
      "whyBad": "An `if` expression that selects the lesser or greater of two\nsub-expressions can be replaced with a `min()` or `max()` call\nrespectively. When possible, prefer `min()` and `max()`, as they're more\nconcise and readable than the equivalent `if` expression.",
      "example": "```python\nhighest_score = score1 if score1 > score2 else score2\n```\n\nUse instead:\n```python\nhighest_score = max(score2, score1)\n```"
    },
    {
      "code": "FURB140",
      "name": "reimplemented-starmap",
      "summary": "Checks for generator expressions, list and set comprehensions that can\nbe replaced with `itertools.starmap`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/reimplemented-starmap/",
      "whyBad": "When unpacking values from iterators to pass them directly to\na function, prefer `itertools.starmap`.\n\nUsing `itertools.starmap` is more concise and readable. Furthermore, it is\nmore efficient than generator expressions, and in some versions of Python,\nit is more efficient than comprehensions.",
      "example": "```python\nall(predicate(a, b) for a, b in some_iterable)\n```\n\nUse instead:\n```python\nfrom itertools import starmap\n\n\nall(starmap(predicate, some_iterable))\n```"
    },
    {
      "code": "FURB142",
      "name": "for-loop-set-mutations",
      "summary": "Checks for code that updates a set with the contents of an iterable by\nusing a `for` loop to call `.add()` or `.discard()` on each element\nseparately.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/for-loop-set-mutations/",
      "whyBad": "When adding or removing a batch of elements to or from a set, it's more\nidiomatic to use a single method call rather than adding or removing\nelements one by one.",
      "example": "```python\ns = set()\n\nfor x in (1, 2, 3):\n    s.add(x)\n\nfor x in (1, 2, 3):\n    s.discard(x)\n```\n\nUse instead:\n```python\ns = set()\n\ns.update((1, 2, 3))\ns.difference_update((1, 2, 3))\n```"
    },
    {
      "code": "FURB145",
      "name": "slice-copy",
      "summary": "Checks for unbounded slice expressions to copy a list.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/slice-copy/",
      "whyBad": "The `list.copy` method is more readable and consistent with copying other\ntypes.",
      "example": "```python\na = [1, 2, 3]\nb = a[:]\n```\n\nUse instead:\n```python\na = [1, 2, 3]\nb = a.copy()\n```"
    },
    {
      "code": "FURB148",
      "name": "unnecessary-enumerate",
      "summary": "Checks for uses of `enumerate` that discard either the index or the value\nwhen iterating over a sequence.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-enumerate/",
      "whyBad": "The built-in `enumerate` function is useful when you need both the index and\nvalue of a sequence.\n\nIf you only need the index or values of a sequence, you should iterate over\n`range(len(...))` or the sequence itself, respectively, instead. This is\nmore efficient and communicates the intent of the code more clearly.",
      "example": "```python\nfor index, _ in enumerate(sequence):\n    print(index)\n\nfor _, value in enumerate(sequence):\n    print(value)\n```\n\nUse instead:\n```python\nfor index in range(len(sequence)):\n    print(index)\n\nfor value in sequence:\n    print(value)\n```"
    },
    {
      "code": "FURB152",
      "name": "math-constant",
      "summary": "Checks for literals that are similar to constants in `math` module.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/math-constant/",
      "whyBad": "Hard-coding mathematical constants like  increases code duplication,\nreduces readability, and may lead to a lack of precision.",
      "example": "```python\nA = 3.141592 * r**2\n```\n\nUse instead:\n```python\nA = math.pi * r**2\n```"
    },
    {
      "code": "FURB154",
      "name": "repeated-global",
      "summary": "Checks for consecutive `global` (or `nonlocal`) statements.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/repeated-global/",
      "whyBad": "The `global` and `nonlocal` keywords accepts multiple comma-separated names.\nInstead of using multiple `global` (or `nonlocal`) statements for separate\nvariables, you can use a single statement to declare multiple variables at\nonce.",
      "example": "```python\ndef func():\n    global x\n    global y\n\n    print(x, y)\n```\n\nUse instead:\n```python\ndef func():\n    global x, y\n\n    print(x, y)\n```"
    },
    {
      "code": "FURB156",
      "name": "hardcoded-string-charset",
      "summary": "Checks for uses of hardcoded charsets, which are defined in Python string module.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hardcoded-string-charset/",
      "whyBad": "Usage of named charsets from the standard library is more readable and less error-prone.",
      "example": "```python\nx = \"0123456789\"\ny in \"abcdefghijklmnopqrstuvwxyz\"\n```\n\nUse instead\n```python\nimport string\n\nx = string.digits\ny in string.ascii_lowercase\n```"
    },
    {
      "code": "FURB157",
      "name": "verbose-decimal-constructor",
      "summary": "Checks for unnecessary string literal or float casts in `Decimal`\nconstructors.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/verbose-decimal-constructor/",
      "whyBad": "The `Decimal` constructor accepts a variety of arguments, including\nintegers, floats, and strings. However, it's not necessary to cast\ninteger literals to strings when passing them to the `Decimal`.\n\nSimilarly, `Decimal` accepts `inf`, `-inf`, and `nan` as string literals,\nso there's no need to wrap those values in a `float` call when passing\nthem to the `Decimal` constructor.\n\nPrefer the more concise form of argument passing for `Decimal`\nconstructors, as it's more readable and idiomatic.\n\nNote that this rule does not flag quoted float literals such as `Decimal(\"0.1\")`, which will\nproduce a more precise `Decimal` value than the unquoted `Decimal(0.1)`.",
      "example": "```python\nfrom decimal import Decimal\n\nDecimal(\"0\")\nDecimal(float(\"Infinity\"))\n```\n\nUse instead:\n```python\nfrom decimal import Decimal\n\nDecimal(0)\nDecimal(\"Infinity\")\n```"
    },
    {
      "code": "FURB161",
      "name": "bit-count",
      "summary": "Checks for uses of `bin(...).count(\"1\")` to perform a population count.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/bit-count/",
      "whyBad": "In Python 3.10, a `bit_count()` method was added to the `int` class,\nwhich is more concise and efficient than converting to a binary\nrepresentation via `bin(...)`.",
      "example": "```python\nx = bin(123).count(\"1\")\ny = bin(0b1111011).count(\"1\")\n```\n\nUse instead:\n```python\nx = (123).bit_count()\ny = 0b1111011.bit_count()\n```"
    },
    {
      "code": "FURB162",
      "name": "fromisoformat-replace-z",
      "summary": "Checks for `datetime.fromisoformat()` calls\nwhere the only argument is an inline replacement\nof `Z` with a zero offset timezone.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/fromisoformat-replace-z/",
      "whyBad": "On Python 3.11 and later, `datetime.fromisoformat()` can handle most [ISO 8601][iso-8601]\nformats including ones affixed with `Z`, so such an operation is unnecessary.\n\nMore information on unsupported formats\ncan be found in [the official documentation][fromisoformat].",
      "example": "```python\nfrom datetime import datetime\n\n\ndate = \"2025-01-01T00:00:00Z\"\n\ndatetime.fromisoformat(date.replace(\"Z\", \"+00:00\"))\ndatetime.fromisoformat(date[:-1] + \"-00\")\ndatetime.fromisoformat(date.strip(\"Z\", \"-0000\"))\ndatetime.fromisoformat(date.rstrip(\"Z\", \"-00:00\"))\n```\n\nUse instead:\n\n```python\nfrom datetime import datetime\n\n\ndate = \"2025-01-01T00:00:00Z\"\n\ndatetime.fromisoformat(date)\n```"
    },
    {
      "code": "FURB163",
      "name": "redundant-log-base",
      "summary": "Checks for `math.log` calls with a redundant base.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-log-base/",
      "whyBad": "The default base of `math.log` is `e`, so specifying it explicitly is\nredundant.\n\nInstead of passing 2 or 10 as the base, use `math.log2` or `math.log10`\nrespectively, as these dedicated variants are typically more accurate\nthan `math.log`.",
      "example": "```python\nimport math\n\nmath.log(4, math.e)\nmath.log(4, 2)\nmath.log(4, 10)\n```\n\nUse instead:\n```python\nimport math\n\nmath.log(4)\nmath.log2(4)\nmath.log10(4)\n```"
    },
    {
      "code": "FURB164",
      "name": "unnecessary-from-float",
      "summary": "Checks for unnecessary `from_float` and `from_decimal` usages to construct\n`Decimal` and `Fraction` instances.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-from-float/",
      "whyBad": "Since Python 3.2, the `Fraction` and `Decimal` classes can be constructed\nby passing float or decimal instances to the constructor directly. As such,\nthe use of `from_float` and `from_decimal` methods is unnecessary, and\nshould be avoided in favor of the more concise constructor syntax.\n\nHowever, there are important behavioral differences between the `from_*` methods\nand the constructors:\n- The `from_*` methods validate their argument types and raise `TypeError` for invalid types\n- The constructors accept broader argument types without validation\n- The `from_*` methods have different parameter names than the constructors",
      "example": "```python\nfrom decimal import Decimal\nfrom fractions import Fraction\n\nDecimal.from_float(4.2)\nDecimal.from_float(float(\"inf\"))\nFraction.from_float(4.2)\nFraction.from_decimal(Decimal(\"4.2\"))\n```\n\nUse instead:\n```python\nfrom decimal import Decimal\nfrom fractions import Fraction\n\nDecimal(4.2)\nDecimal(\"inf\")\nFraction(4.2)\nFraction(Decimal(\"4.2\"))\n```"
    },
    {
      "code": "FURB166",
      "name": "int-on-sliced-str",
      "summary": "Checks for uses of `int` with an explicit base in which a string expression\nis stripped of its leading prefix (i.e., `0b`, `0o`, or `0x`).",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/int-on-sliced-str/",
      "whyBad": "Given an integer string with a prefix (e.g., `0xABC`), Python can automatically\ndetermine the base of the integer by the prefix without needing to specify\nit explicitly.\n\nInstead of `int(num[2:], 16)`, use `int(num, 0)`, which will automatically\ndeduce the base based on the prefix.",
      "example": "```python\nnum = \"0xABC\"\n\nif num.startswith(\"0b\"):\n    i = int(num[2:], 2)\nelif num.startswith(\"0o\"):\n    i = int(num[2:], 8)\nelif num.startswith(\"0x\"):\n    i = int(num[2:], 16)\n\nprint(i)\n```\n\nUse instead:\n```python\nnum = \"0xABC\"\n\ni = int(num, 0)\n\nprint(i)\n```"
    },
    {
      "code": "FURB167",
      "name": "regex-flag-alias",
      "summary": "Checks for the use of shorthand aliases for regular expression flags\n(e.g., `re.I` instead of `re.IGNORECASE`).",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/regex-flag-alias/",
      "whyBad": "The regular expression module provides descriptive names for each flag,\nalong with single-letter aliases. Prefer the descriptive names, as they\nare more readable and self-documenting.",
      "example": "```python\nimport re\n\nif re.match(\"^hello\", \"hello world\", re.I):\n    ...\n```\n\nUse instead:\n```python\nimport re\n\nif re.match(\"^hello\", \"hello world\", re.IGNORECASE):\n    ...\n```"
    },
    {
      "code": "FURB168",
      "name": "isinstance-type-none",
      "summary": "Checks for uses of `isinstance` that check if an object is of type `None`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/isinstance-type-none/",
      "whyBad": "There is only ever one instance of `None`, so it is more efficient and\nreadable to use the `is` operator to check if an object is `None`.",
      "example": "```python\nisinstance(obj, type(None))\n```\n\nUse instead:\n```python\nobj is None\n```"
    },
    {
      "code": "FURB169",
      "name": "type-none-comparison",
      "summary": "Checks for uses of `type` that compare the type of an object to the type of `None`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-none-comparison/",
      "whyBad": "There is only ever one instance of `None`, so it is more efficient and\nreadable to use the `is` operator to check if an object is `None`.",
      "example": "```python\ntype(obj) is type(None)\n```\n\nUse instead:\n```python\nobj is None\n```"
    },
    {
      "code": "FURB171",
      "name": "single-item-membership-test",
      "summary": "Checks for membership tests against single-item containers.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/single-item-membership-test/",
      "whyBad": "Performing a membership test against a container (like a `list` or `set`)\nwith a single item is less readable and less efficient than comparing\nagainst the item directly.",
      "example": "```python\n1 in [1]\n```\n\nUse instead:\n```python\n1 == 1\n```"
    },
    {
      "code": "FURB177",
      "name": "implicit-cwd",
      "summary": "Checks for current-directory lookups using `Path().resolve()`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/implicit-cwd/",
      "whyBad": "When looking up the current directory, prefer `Path.cwd()` over\n`Path().resolve()`, as `Path.cwd()` is more explicit in its intent.",
      "example": "```python\nfrom pathlib import Path\n\ncwd = Path().resolve()\n```\n\nUse instead:\n```python\nfrom pathlib import Path\n\ncwd = Path.cwd()\n```"
    },
    {
      "code": "FURB180",
      "name": "meta-class-abc-meta",
      "summary": "Checks for uses of `metaclass=abc.ABCMeta` to define abstract base classes\n(ABCs).",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/meta-class-abc-meta/",
      "whyBad": "Instead of `class C(metaclass=abc.ABCMeta): ...`, use `class C(ABC): ...`\nto define an abstract base class. Inheriting from the `ABC` wrapper class\nis semantically identical to setting `metaclass=abc.ABCMeta`, but more\nsuccinct.",
      "example": "```python\nimport abc\n\n\nclass C(metaclass=abc.ABCMeta):\n    pass\n```\n\nUse instead:\n```python\nimport abc\n\n\nclass C(abc.ABC):\n    pass\n```"
    },
    {
      "code": "FURB181",
      "name": "hashlib-digest-hex",
      "summary": "Checks for the use of `.digest().hex()` on a hashlib hash, like `sha512`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/hashlib-digest-hex/",
      "whyBad": "When generating a hex digest from a hash, it's preferable to use the\n`.hexdigest()` method, rather than calling `.digest()` and then `.hex()`,\nas the former is more concise and readable.",
      "example": "```python\nfrom hashlib import sha512\n\nhashed = sha512(b\"some data\").digest().hex()\n```\n\nUse instead:\n```python\nfrom hashlib import sha512\n\nhashed = sha512(b\"some data\").hexdigest()\n```"
    },
    {
      "code": "FURB187",
      "name": "list-reverse-copy",
      "summary": "Checks for list reversals that can be performed in-place in lieu of\ncreating a new list.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/list-reverse-copy/",
      "whyBad": "When reversing a list, it's more efficient to use the in-place method\n`.reverse()` instead of creating a new list, if the original list is\nno longer needed.",
      "example": "```python\nl = [1, 2, 3]\nl = reversed(l)\n\nl = [1, 2, 3]\nl = list(reversed(l))\n\nl = [1, 2, 3]\nl = l[::-1]\n```\n\nUse instead:\n```python\nl = [1, 2, 3]\nl.reverse()\n```"
    },
    {
      "code": "FURB188",
      "name": "slice-to-remove-prefix-or-suffix",
      "summary": "Checks for code that could be written more idiomatically using\n[`str.removeprefix()`](https://docs.python.org/3/library/stdtypes.html#str.removeprefix)\nor [`str.removesuffix()`](https://docs.python.org/3/library/stdtypes.html#str.removesuffix).\n\nSpecifically, the rule flags code that conditionally removes a prefix or suffix\nusing a slice operation following an `if` test that uses `str.startswith()` or `str.endswith()`.\n\nThe rule is only applied if your project targets Python 3.9 or later.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/slice-to-remove-prefix-or-suffix/",
      "whyBad": "The methods [`str.removeprefix()`](https://docs.python.org/3/library/stdtypes.html#str.removeprefix)\nand [`str.removesuffix()`](https://docs.python.org/3/library/stdtypes.html#str.removesuffix),\nintroduced in Python 3.9, have the same behavior while being more readable and efficient.",
      "example": "```python\ndef example(filename: str, text: str):\n    filename = filename[:-4] if filename.endswith(\".txt\") else filename\n\n    if text.startswith(\"pre\"):\n        text = text[3:]\n```\n\nUse instead:\n```python\ndef example(filename: str, text: str):\n    filename = filename.removesuffix(\".txt\")\n    text = text.removeprefix(\"pre\")\n```"
    },
    {
      "code": "FURB189",
      "name": "subclass-builtin",
      "summary": "Checks for subclasses of `dict`, `list` or `str`.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/subclass-builtin/",
      "whyBad": "Built-in types don't consistently use their own dunder methods. For example,\n`dict.__init__` and `dict.update()` bypass `__setitem__`, making inheritance unreliable.\n\nUse the `UserDict`, `UserList`, and `UserString` objects from the `collections` module\ninstead.",
      "example": "```python\nclass UppercaseDict(dict):\n    def __setitem__(self, key, value):\n        super().__setitem__(key.upper(), value)\n\n\nd = UppercaseDict({\"a\": 1, \"b\": 2})  # Bypasses __setitem__\nprint(d)  # {'a': 1, 'b': 2}\n```\n\nUse instead:\n\n```python\nfrom collections import UserDict\n\n\nclass UppercaseDict(UserDict):\n    def __setitem__(self, key, value):\n        super().__setitem__(key.upper(), value)\n\n\nd = UppercaseDict({\"a\": 1, \"b\": 2})  # Uses __setitem__\nprint(d)  # {'A': 1, 'B': 2}\n```"
    },
    {
      "code": "FURB192",
      "name": "sorted-min-max",
      "summary": "Checks for uses of `sorted()` to retrieve the minimum or maximum value in\na sequence.",
      "category": "refurb",
      "categoryCode": "FURB",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/sorted-min-max/",
      "whyBad": "Using `sorted()` to compute the minimum or maximum value in a sequence is\ninefficient and less readable than using `min()` or `max()` directly.",
      "example": "```python\nnums = [3, 1, 4, 1, 5]\nlowest = sorted(nums)[0]\nhighest = sorted(nums)[-1]\nhighest = sorted(nums, reverse=True)[0]\n```\n\nUse instead:\n```python\nnums = [3, 1, 4, 1, 5]\nlowest = min(nums)\nhighest = max(nums)\n```"
    },
    {
      "code": "RUF001",
      "name": "ambiguous-unicode-character-string",
      "summary": "Checks for ambiguous Unicode characters in strings.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ambiguous-unicode-character-string/",
      "whyBad": "Some Unicode characters are visually similar to ASCII characters, but have\ndifferent code points. For example, `GREEK CAPITAL LETTER ALPHA` (`U+0391`)\nis visually similar, but not identical, to the ASCII character `A`.\n\nThe use of ambiguous Unicode characters can confuse readers, cause subtle\nbugs, and even make malicious code look harmless.\n\nIn [preview], this rule will also flag Unicode characters that are\nconfusable with other, non-preferred Unicode characters. For example, the\nspec recommends `GREEK CAPITAL LETTER OMEGA` over `OHM SIGN`.\n\nYou can omit characters from being flagged as ambiguous via the\n[`lint.allowed-confusables`] setting.",
      "example": "```python\nprint(\"ello, world!\")  # \"\" is the Greek eta (`U+0397`).\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\")  # \"H\" is the Latin capital H (`U+0048`).\n```"
    },
    {
      "code": "RUF002",
      "name": "ambiguous-unicode-character-docstring",
      "summary": "Checks for ambiguous Unicode characters in docstrings.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ambiguous-unicode-character-docstring/",
      "whyBad": "Some Unicode characters are visually similar to ASCII characters, but have\ndifferent code points. For example, `GREEK CAPITAL LETTER ALPHA` (`U+0391`)\nis visually similar, but not identical, to the ASCII character `A`.\n\nThe use of ambiguous Unicode characters can confuse readers, cause subtle\nbugs, and even make malicious code look harmless.\n\nIn [preview], this rule will also flag Unicode characters that are\nconfusable with other, non-preferred Unicode characters. For example, the\nspec recommends `GREEK CAPITAL LETTER OMEGA` over `OHM SIGN`.\n\nYou can omit characters from being flagged as ambiguous via the\n[`lint.allowed-confusables`] setting.",
      "example": "```python\n\"\"\"A lovely docstring (with a `U+FF09` parenthesis.\"\"\"\n```\n\nUse instead:\n```python\n\"\"\"A lovely docstring (with no strange parentheses).\"\"\"\n```"
    },
    {
      "code": "RUF003",
      "name": "ambiguous-unicode-character-comment",
      "summary": "Checks for ambiguous Unicode characters in comments.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ambiguous-unicode-character-comment/",
      "whyBad": "Some Unicode characters are visually similar to ASCII characters, but have\ndifferent code points. For example, `GREEK CAPITAL LETTER ALPHA` (`U+0391`)\nis visually similar, but not identical, to the ASCII character `A`.\n\nThe use of ambiguous Unicode characters can confuse readers, cause subtle\nbugs, and even make malicious code look harmless.\n\nIn [preview], this rule will also flag Unicode characters that are\nconfusable with other, non-preferred Unicode characters. For example, the\nspec recommends `GREEK CAPITAL LETTER OMEGA` over `OHM SIGN`.\n\nYou can omit characters from being flagged as ambiguous via the\n[`lint.allowed-confusables`] setting.",
      "example": "```python\nfoo()  # nqa  # \"\" is Cyrillic (`U+043E`)\n```\n\nUse instead:\n```python\nfoo()  # noqa  # \"o\" is Latin (`U+006F`)\n```"
    },
    {
      "code": "RUF005",
      "name": "collection-literal-concatenation",
      "summary": "Checks for uses of the `+` operator to concatenate collections.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/collection-literal-concatenation/",
      "whyBad": "In Python, the `+` operator can be used to concatenate collections (e.g.,\n`x + y` to concatenate the lists `x` and `y`).\n\nHowever, collections can be concatenated more efficiently using the\nunpacking operator (e.g., `[*x, *y]` to concatenate `x` and `y`).\n\nPrefer the unpacking operator to concatenate collections, as it is more\nreadable and flexible. The `*` operator can unpack any iterable, whereas\n `+` operates only on particular sequences which, in many cases, must be of\nthe same type.",
      "example": "```python\nfoo = [2, 3, 4]\nbar = [1] + foo + [5, 6]\n```\n\nUse instead:\n```python\nfoo = [2, 3, 4]\nbar = [1, *foo, 5, 6]\n```"
    },
    {
      "code": "RUF006",
      "name": "asyncio-dangling-task",
      "summary": "Checks for `asyncio.create_task` and `asyncio.ensure_future` calls\nthat do not store a reference to the returned result.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/asyncio-dangling-task/",
      "whyBad": "Per the `asyncio` documentation, the event loop only retains a weak\nreference to tasks. If the task returned by `asyncio.create_task` and\n`asyncio.ensure_future` is not stored in a variable, or a collection,\nor otherwise referenced, it may be garbage collected at any time. This\ncan lead to unexpected and inconsistent behavior, as your tasks may or\nmay not run to completion.",
      "example": "```python\nimport asyncio\n\nfor i in range(10):\n    # This creates a weak reference to the task, which may be garbage\n    # collected at any time.\n    asyncio.create_task(some_coro(param=i))\n```\n\nUse instead:\n```python\nimport asyncio\n\nbackground_tasks = set()\n\nfor i in range(10):\n    task = asyncio.create_task(some_coro(param=i))\n\n    # Add task to the set. This creates a strong reference.\n    background_tasks.add(task)\n\n    # To prevent keeping references to finished tasks forever,\n    # make each task remove its own reference from the set after\n    # completion:\n    task.add_done_callback(background_tasks.discard)\n```"
    },
    {
      "code": "RUF007",
      "name": "zip-instead-of-pairwise",
      "summary": "Checks for use of `zip()` to iterate over successive pairs of elements.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/zip-instead-of-pairwise/",
      "whyBad": "When iterating over successive pairs of elements, prefer\n`itertools.pairwise()` over `zip()`.\n\n`itertools.pairwise()` is more readable and conveys the intent of the code\nmore clearly.",
      "example": "```python\nletters = \"ABCD\"\nzip(letters, letters[1:])  # (\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")\n```\n\nUse instead:\n```python\nfrom itertools import pairwise\n\nletters = \"ABCD\"\npairwise(letters)  # (\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")\n```"
    },
    {
      "code": "RUF008",
      "name": "mutable-dataclass-default",
      "summary": "Checks for mutable default values in dataclass attributes.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mutable-dataclass-default/",
      "whyBad": "Mutable default values share state across all instances of the dataclass.\nThis can lead to bugs when the attributes are changed in one instance, as\nthose changes will unexpectedly affect all other instances.\n\nInstead of sharing mutable defaults, use the `field(default_factory=...)`\npattern.\n\nIf the default value is intended to be mutable, it must be annotated with\n`typing.ClassVar`; otherwise, a `ValueError` will be raised.",
      "example": "```python\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass A:\n    # A list without a `default_factory` or `ClassVar` annotation\n    # will raise a `ValueError`.\n    mutable_default: list[int] = []\n```\n\nUse instead:\n```python\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = field(default_factory=list)\n```\n\nOr:\n```python\nfrom dataclasses import dataclass\nfrom typing import ClassVar\n\n\n@dataclass\nclass A:\n    mutable_default: ClassVar[list[int]] = []\n```"
    },
    {
      "code": "RUF009",
      "name": "function-call-in-dataclass-default-argument",
      "summary": "Checks for function calls in dataclass attribute defaults.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/function-call-in-dataclass-default-argument/",
      "whyBad": "Function calls are only performed once, at definition time. The returned\nvalue is then reused by all instances of the dataclass. This can lead to\nunexpected behavior when the function call returns a mutable object, as\nchanges to the object will be shared across all instances.\n\nIf a field needs to be initialized with a mutable object, use the\n`field(default_factory=...)` pattern.\n\nAttributes whose default arguments are `NewType` calls\nwhere the original type is immutable are ignored.",
      "example": "```python\nfrom dataclasses import dataclass\n\n\ndef simple_list() -> list[int]:\n    return [1, 2, 3, 4]\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = simple_list()\n```\n\nUse instead:\n```python\nfrom dataclasses import dataclass, field\n\n\ndef creating_list() -> list[int]:\n    return [1, 2, 3, 4]\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = field(default_factory=creating_list)\n```"
    },
    {
      "code": "RUF010",
      "name": "explicit-f-string-type-conversion",
      "summary": "Checks for uses of `str()`, `repr()`, and `ascii()` as explicit type\nconversions within f-strings.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/explicit-f-string-type-conversion/",
      "whyBad": "f-strings support dedicated conversion flags for these types, which are\nmore succinct and idiomatic.\n\nNote that, in many cases, calling `str()` within an f-string is\nunnecessary and can be removed entirely, as the value will be converted\nto a string automatically, the notable exception being for classes that\nimplement a custom `__format__` method.",
      "example": "```python\na = \"some string\"\nf\"{repr(a)}\"\n```\n\nUse instead:\n```python\na = \"some string\"\nf\"{a!r}\"\n```"
    },
    {
      "code": "RUF011",
      "name": "ruff-static-key-dict-comprehension",
      "summary": "Checks for dictionary comprehensions that use a static key, like a string\nliteral or a variable defined outside the comprehension.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ruff-static-key-dict-comprehension/",
      "whyBad": "Using a static key (like a string literal) in a dictionary comprehension\nis usually a mistake, as it will result in a dictionary with only one key,\ndespite the comprehension iterating over multiple values.",
      "example": "```python\ndata = [\"some\", \"Data\"]\n{\"key\": value.upper() for value in data}\n```\n\nUse instead:\n```python\ndata = [\"some\", \"Data\"]\n{value: value.upper() for value in data}\n```\n\n[B035]: https://docs.astral.sh/ruff/rules/static-key-dict-comprehension/"
    },
    {
      "code": "RUF012",
      "name": "mutable-class-default",
      "summary": "Checks for mutable default values in class attributes.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mutable-class-default/",
      "whyBad": "Mutable default values share state across all instances of the class,\nwhile not being obvious. This can lead to bugs when the attributes are\nchanged in one instance, as those changes will unexpectedly affect all\nother instances.\n\nGenerally speaking, you probably want to avoid having mutable default\nvalues in the class body at all; instead, these variables should usually\nbe initialized in `__init__`. However, other possible fixes for the issue\ncan include:\n- Explicitly annotating the variable with [`typing.ClassVar`][ClassVar] to\n  indicate that it is intended to be shared across all instances.\n- Using an immutable data type (e.g. a tuple instead of a list)\n  for the default value.",
      "example": "```python\nclass A:\n    variable_1: list[int] = []\n    variable_2: set[int] = set()\n    variable_3: dict[str, int] = {}\n```\n\nUse instead:\n\n```python\nclass A:\n    def __init__(self) -> None:\n        self.variable_1: list[int] = []\n        self.variable_2: set[int] = set()\n        self.variable_3: dict[str, int] = {}\n```\n\nOr:\n\n```python\nfrom typing import ClassVar\n\n\nclass A:\n    variable_1: ClassVar[list[int]] = []\n    variable_2: ClassVar[set[int]] = set()\n    variable_3: ClassVar[dict[str, int]] = {}\n```\n\nOr:\n\n```python\nclass A:\n    variable_1: list[int] | None = None\n    variable_2: set[int] | None = None\n    variable_3: dict[str, int] | None = None\n```\n\nOr:\n\n```python\nfrom collections.abc import Sequence, Mapping, Set as AbstractSet\nfrom types import MappingProxyType\n\n\nclass A:\n    variable_1: Sequence[int] = ()\n    variable_2: AbstractSet[int] = frozenset()\n    variable_3: Mapping[str, int] = MappingProxyType({})\n```\n\n[ClassVar]: https://docs.python.org/3/library/typing.html#typing.ClassVar"
    },
    {
      "code": "RUF013",
      "name": "implicit-optional",
      "summary": "Checks for the use of implicit `Optional` in type annotations when the\ndefault parameter value is `None`.\n\nIf [`lint.future-annotations`] is set to `true`, `from __future__ import\nannotations` will be added if doing so would allow using the `|` operator on\na Python version before 3.10.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/implicit-optional/",
      "whyBad": "Implicit `Optional` is prohibited by [PEP 484]. It is confusing and\ninconsistent with the rest of the type system.\n\nIt's recommended to use `Optional[T]` instead. For Python 3.10 and later,\nyou can also use `T | None`.",
      "example": "```python\ndef foo(arg: int = None):\n    pass\n```\n\nUse instead:\n```python\nfrom typing import Optional\n\n\ndef foo(arg: Optional[int] = None):\n    pass\n```\n\nOr, for Python 3.10 and later:\n```python\ndef foo(arg: int | None = None):\n    pass\n```\n\nIf you want to use the `|` operator in Python 3.9 and earlier, you can\nuse future imports:\n```python\nfrom __future__ import annotations\n\n\ndef foo(arg: int | None = None):\n    pass\n```"
    },
    {
      "code": "RUF015",
      "name": "unnecessary-iterable-allocation-for-first-element",
      "summary": "Checks the following constructs, all of which can be replaced by\n`next(iter(...))`:\n\n- `list(...)[0]`\n- `tuple(...)[0]`\n- `list(i for i in ...)[0]`\n- `[i for i in ...][0]`\n- `list(...).pop(0)`",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-iterable-allocation-for-first-element/",
      "whyBad": "Calling e.g. `list(...)` will create a new list of the entire collection,\nwhich can be very expensive for large collections. If you only need the\nfirst element of the collection, you can use `next(...)` or\n`next(iter(...)` to lazily fetch the first element. The same is true for\nthe other constructs.",
      "example": "```python\nhead = list(x)[0]\nhead = [x * x for x in range(10)][0]\n```\n\nUse instead:\n```python\nhead = next(iter(x))\nhead = next(x * x for x in range(10))\n```"
    },
    {
      "code": "RUF016",
      "name": "invalid-index-type",
      "summary": "Checks for indexed access to lists, strings, tuples, bytes, and comprehensions\nusing a type other than an integer or slice.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-index-type/",
      "whyBad": "Only integers or slices can be used as indices to these types. Using\nother types will result in a `TypeError` at runtime and a `SyntaxWarning` at\nimport time.",
      "example": "```python\nvar = [1, 2, 3][\"x\"]\n```\n\nUse instead:\n```python\nvar = [1, 2, 3][0]\n```"
    },
    {
      "code": "RUF017",
      "name": "quadratic-list-summation",
      "summary": "Checks for the use of `sum()` to flatten lists of lists, which has\nquadratic complexity.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/quadratic-list-summation/",
      "whyBad": "The use of `sum()` to flatten lists of lists is quadratic in the number of\nlists, as `sum()` creates a new list for each element in the summation.\n\nInstead, consider using another method of flattening lists to avoid\nquadratic complexity. The following methods are all linear in the number of\nlists:\n\n- `functools.reduce(operator.iadd, lists, [])`\n- `list(itertools.chain.from_iterable(lists))`\n- `[item for sublist in lists for item in sublist]`\n\nWhen fixing relevant violations, Ruff defaults to the `functools.reduce`\nform, which outperforms the other methods in [microbenchmarks].",
      "example": "```python\nlists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\njoined = sum(lists, [])\n```\n\nUse instead:\n```python\nimport functools\nimport operator\n\n\nlists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfunctools.reduce(operator.iadd, lists, [])\n```"
    },
    {
      "code": "RUF018",
      "name": "assignment-in-assert",
      "summary": "Checks for named assignment expressions (e.g., `x := 0`) in `assert`\nstatements.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assignment-in-assert/",
      "whyBad": "Named assignment expressions (also known as \"walrus operators\") are used to\nassign a value to a variable as part of a larger expression.\n\nNamed assignments are syntactically valid in `assert` statements. However,\nwhen the Python interpreter is run under the `-O` flag, `assert` statements\nare not executed. In this case, the named assignment will also be ignored,\nwhich may result in unexpected behavior (e.g., undefined variable\naccesses).",
      "example": "```python\nassert (x := 0) == 0\nprint(x)\n```\n\nUse instead:\n```python\nx = 0\nassert x == 0\nprint(x)\n```\n\nThe rule avoids flagging named expressions that define variables which are\nonly referenced from inside `assert` statements; the following will not\ntrigger the rule:\n```python\nassert (x := y**2) > 42, f\"Expected >42 but got {x}\"\n```\n\nNor will this:\n```python\nassert (x := y**2) > 42\nassert x < 1_000_000\n```"
    },
    {
      "code": "RUF019",
      "name": "unnecessary-key-check",
      "summary": "Checks for unnecessary key checks prior to accessing a dictionary.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-key-check/",
      "whyBad": "When working with dictionaries, the `get` can be used to access a value\nwithout having to check if the dictionary contains the relevant key,\nreturning `None` if the key is not present.",
      "example": "```python\nif \"key\" in dct and dct[\"key\"]:\n    ...\n```\n\nUse instead:\n```python\nif dct.get(\"key\"):\n    ...\n```"
    },
    {
      "code": "RUF020",
      "name": "never-union",
      "summary": "Checks for uses of `typing.NoReturn` and `typing.Never` in union types.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/never-union/",
      "whyBad": "`typing.NoReturn` and `typing.Never` are special types, used to indicate\nthat a function never returns, or that a type has no values.\n\nIncluding `typing.NoReturn` or `typing.Never` in a union type is redundant,\nas, e.g., `typing.Never | T` is equivalent to `T`.",
      "example": "```python\nfrom typing import Never\n\n\ndef func() -> Never | int: ...\n```\n\nUse instead:\n\n```python\ndef func() -> int: ...\n```"
    },
    {
      "code": "RUF021",
      "name": "parenthesize-chained-operators",
      "summary": "Checks for chained operators where adding parentheses could improve the\nclarity of the code.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/parenthesize-chained-operators/",
      "whyBad": "`and` always binds more tightly than `or` when chaining the two together,\nbut this can be hard to remember (and sometimes surprising).\nAdding parentheses in these situations can greatly improve code readability,\nwith no change to semantics or performance.\n\nFor example:\n```python\na, b, c = 1, 0, 2\nx = a or b and c\n\nd, e, f = 0, 1, 2\ny = d and e or f\n```\n\nUse instead:\n```python\na, b, c = 1, 0, 2\nx = a or (b and c)\n\nd, e, f = 0, 1, 2\ny = (d and e) or f\n```"
    },
    {
      "code": "RUF022",
      "name": "unsorted-dunder-all",
      "summary": "Checks for `__all__` definitions that are not ordered\naccording to an \"isort-style\" sort.\n\nAn isort-style sort orders items first according to their casing:\nSCREAMING_SNAKE_CASE names (conventionally used for global constants)\ncome first, followed by CamelCase names (conventionally used for\nclasses), followed by anything else. Within each category,\na [natural sort](https://en.wikipedia.org/wiki/Natural_sort_order)\nis used to order the elements.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unsorted-dunder-all/",
      "whyBad": "Consistency is good. Use a common convention for `__all__` to make your\ncode more readable and idiomatic.",
      "example": "```python\nimport sys\n\n__all__ = [\n    \"b\",\n    \"c\",\n    \"a\",\n]\n\nif sys.platform == \"win32\":\n    __all__ += [\"z\", \"y\"]\n```\n\nUse instead:\n```python\nimport sys\n\n__all__ = [\n    \"a\",\n    \"b\",\n    \"c\",\n]\n\nif sys.platform == \"win32\":\n    __all__ += [\"y\", \"z\"]\n```"
    },
    {
      "code": "RUF023",
      "name": "unsorted-dunder-slots",
      "summary": "Checks for `__slots__` definitions that are not ordered according to a\n[natural sort](https://en.wikipedia.org/wiki/Natural_sort_order).",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unsorted-dunder-slots/",
      "whyBad": "Consistency is good. Use a common convention for this special variable\nto make your code more readable and idiomatic.",
      "example": "```python\nclass Dog:\n    __slots__ = \"name\", \"breed\"\n```\n\nUse instead:\n```python\nclass Dog:\n    __slots__ = \"breed\", \"name\"\n```"
    },
    {
      "code": "RUF024",
      "name": "mutable-fromkeys-value",
      "summary": "Checks for mutable objects passed as a value argument to `dict.fromkeys`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/mutable-fromkeys-value/",
      "whyBad": "All values in the dictionary created by the `dict.fromkeys` method\nrefer to the same instance of the provided object. If that object is\nmodified, all values are modified, which can lead to unexpected behavior.\nFor example, if the empty list (`[]`) is provided as the default value,\nall values in the dictionary will use the same list; as such, appending to\nany one entry will append to all entries.\n\nInstead, use a comprehension to generate a dictionary with distinct\ninstances of the default value.",
      "example": "```python\ncities = dict.fromkeys([\"UK\", \"Poland\"], [])\ncities[\"UK\"].append(\"London\")\ncities[\"Poland\"].append(\"Poznan\")\nprint(cities)  # {'UK': ['London', 'Poznan'], 'Poland': ['London', 'Poznan']}\n```\n\nUse instead:\n```python\ncities = {country: [] for country in [\"UK\", \"Poland\"]}\ncities[\"UK\"].append(\"London\")\ncities[\"Poland\"].append(\"Poznan\")\nprint(cities)  # {'UK': ['London'], 'Poland': ['Poznan']}\n```"
    },
    {
      "code": "RUF026",
      "name": "default-factory-kwarg",
      "summary": "Checks for incorrect usages of `default_factory` as a keyword argument when\ninitializing a `defaultdict`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/default-factory-kwarg/",
      "whyBad": "The `defaultdict` constructor accepts a callable as its first argument.\nFor example, it's common to initialize a `defaultdict` with `int` or `list`\nvia `defaultdict(int)` or `defaultdict(list)`, to create a dictionary that\nreturns `0` or `[]` respectively when a key is missing.\n\nThe default factory _must_ be provided as a positional argument, as all\nkeyword arguments to `defaultdict` are interpreted as initial entries in\nthe dictionary. For example, `defaultdict(foo=1, bar=2)` will create a\ndictionary with `{\"foo\": 1, \"bar\": 2}` as its initial entries.\n\nAs such, `defaultdict(default_factory=list)` will create a dictionary with\n`{\"default_factory\": list}` as its initial entry, instead of a dictionary\nthat returns `[]` when a key is missing. Specifying a `default_factory`\nkeyword argument is almost always a mistake, and one that type checkers\ncan't reliably detect.",
      "example": "```python\ndefaultdict(default_factory=int)\ndefaultdict(default_factory=list)\n```\n\nUse instead:\n```python\ndefaultdict(int)\ndefaultdict(list)\n```"
    },
    {
      "code": "RUF027",
      "name": "missing-f-string-syntax",
      "summary": "Searches for strings that look like they were meant to be f-strings, but are missing an `f` prefix.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/missing-f-string-syntax/",
      "whyBad": "Expressions inside curly braces are only evaluated if the string has an `f` prefix.",
      "example": "```python\nname = \"Sarah\"\nday_of_week = \"Tuesday\"\nprint(\"Hello {name}! It is {day_of_week} today!\")\n```\n\nUse instead:\n```python\nname = \"Sarah\"\nday_of_week = \"Tuesday\"\nprint(f\"Hello {name}! It is {day_of_week} today!\")\n```"
    },
    {
      "code": "RUF028",
      "name": "invalid-formatter-suppression-comment",
      "summary": "Checks for formatter suppression comments that are ineffective or incompatible\nwith Ruff's formatter.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-formatter-suppression-comment/",
      "whyBad": "Suppression comments that do not actually prevent formatting could cause unintended changes\nwhen the formatter is run.",
      "example": "In the following example, all suppression comments would cause\na rule violation.\n\n```python\ndef decorator():\n    pass\n\n\n@decorator"
    },
    {
      "code": "RUF029",
      "name": "unused-async",
      "summary": "Checks for functions declared `async` that do not await or otherwise use features requiring the\nfunction to be declared `async`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-async/",
      "whyBad": "Declaring a function `async` when it's not is usually a mistake, and will artificially limit the\ncontexts where that function may be called. In some cases, labeling a function `async` is\nsemantically meaningful (e.g. with the trio library).",
      "example": "```python\nasync def foo():\n    bar()\n```\n\nUse instead:\n```python\ndef foo():\n    bar()\n```"
    },
    {
      "code": "RUF030",
      "name": "assert-with-print-message",
      "summary": "Checks for uses of `assert expression, print(message)`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/assert-with-print-message/",
      "whyBad": "If an `assert x, y` assertion fails, the Python interpreter raises an\n`AssertionError`, and the evaluated value of `y` is used as the contents of\nthat assertion error. The `print` function always returns `None`, however,\nso the evaluated value of a call to `print` will always be `None`.\n\nUsing a `print` call in this context will therefore output the message to\n`stdout`, before raising an empty `AssertionError(None)`. Instead, remove\nthe `print` and pass the message directly as the second expression,\nallowing `stderr` to capture the message in a well-formatted context.",
      "example": "```python\nassert False, print(\"This is a message\")\n```\n\nUse instead:\n```python\nassert False, \"This is a message\"\n```"
    },
    {
      "code": "RUF031",
      "name": "incorrectly-parenthesized-tuple-in-subscript",
      "summary": "Checks for consistent style regarding whether nonempty tuples in subscripts\nare parenthesized.\n\nThe exact nature of this violation depends on the setting\n[`lint.ruff.parenthesize-tuple-in-subscript`]. By default, the use of\nparentheses is considered a violation.\n\nThis rule is not applied inside \"typing contexts\" (type annotations,\ntype aliases and subscripted class bases), as these have their own specific\nconventions around them.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/incorrectly-parenthesized-tuple-in-subscript/",
      "whyBad": "It is good to be consistent and, depending on the codebase, one or the other\nconvention may be preferred.",
      "example": "```python\ndirections = {(0, 1): \"North\", (1, 0): \"East\", (0, -1): \"South\", (-1, 0): \"West\"}\ndirections[(0, 1)]\n```\n\nUse instead (with default setting):\n\n```python\ndirections = {(0, 1): \"North\", (1, 0): \"East\", (0, -1): \"South\", (-1, 0): \"West\"}\ndirections[0, 1]\n```"
    },
    {
      "code": "RUF032",
      "name": "decimal-from-float-literal",
      "summary": "Checks for `Decimal` calls passing a float literal.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/decimal-from-float-literal/",
      "whyBad": "Float literals have limited precision that can lead to unexpected results.\nThe `Decimal` class is designed to handle numbers with fixed-point precision,\nso a string literal should be used instead.",
      "example": "```python\nnum = Decimal(1.2345)\n```\n\nUse instead:\n```python\nnum = Decimal(\"1.2345\")\n```"
    },
    {
      "code": "RUF033",
      "name": "post-init-default",
      "summary": "Checks for `__post_init__` dataclass methods with parameter defaults.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/post-init-default/",
      "whyBad": "Adding a default value to a parameter in a `__post_init__` method has no\nimpact on whether the parameter will have a default value in the dataclass's\ngenerated `__init__` method. To create an init-only dataclass parameter with\na default value, you should use an `InitVar` field in the dataclass's class\nbody and give that `InitVar` field a default value.\n\nAs the [documentation] states:\n\n> Init-only fields are added as parameters to the generated `__init__()`\n> method, and are passed to the optional `__post_init__()` method. They are\n> not otherwise used by dataclasses.",
      "example": "```python\nfrom dataclasses import InitVar, dataclass\n\n\n@dataclass\nclass Foo:\n    bar: InitVar[int] = 0\n\n    def __post_init__(self, bar: int = 1, baz: int = 2) -> None:\n        print(bar, baz)\n\n\nfoo = Foo()  # Prints '0 2'.\n```\n\nUse instead:\n```python\nfrom dataclasses import InitVar, dataclass\n\n\n@dataclass\nclass Foo:\n    bar: InitVar[int] = 1\n    baz: InitVar[int] = 2\n\n    def __post_init__(self, bar: int, baz: int) -> None:\n        print(bar, baz)\n\n\nfoo = Foo()  # Prints '1 2'.\n```"
    },
    {
      "code": "RUF034",
      "name": "useless-if-else",
      "summary": "Checks for useless `if`-`else` conditions with identical arms.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-if-else/",
      "whyBad": "Useless `if`-`else` conditions add unnecessary complexity to the code without\nproviding any logical benefit. Assigning the value directly is clearer.",
      "example": "```python\nfoo = x if y else x\n```\n\nUse instead:\n```python\nfoo = x\n```"
    },
    {
      "code": "RUF035",
      "name": "ruff-unsafe-markup-use",
      "summary": "Checks for non-literal strings being passed to [`markupsafe.Markup`][markupsafe-markup].",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/ruff-unsafe-markup-use/",
      "whyBad": "[`markupsafe.Markup`][markupsafe-markup] does not perform any escaping,\nso passing dynamic content, like f-strings, variables or interpolated strings\nwill potentially lead to XSS vulnerabilities.\n\nInstead you should interpolate the `Markup` object.\n\nUsing [`lint.flake8-bandit.extend-markup-names`] additional objects can be\ntreated like `Markup`.\n\nThis rule was originally inspired by [flake8-markupsafe] but doesn't carve\nout any exceptions for i18n related calls by default.\n\nYou can use [`lint.flake8-bandit.allowed-markup-calls`] to specify exceptions.",
      "example": "Given:\n```python\nfrom markupsafe import Markup\n\ncontent = \"<script>alert('Hello, world!')</script>\"\nhtml = Markup(f\"<b>{content}</b>\")  # XSS\n```\n\nUse instead:\n```python\nfrom markupsafe import Markup\n\ncontent = \"<script>alert('Hello, world!')</script>\"\nhtml = Markup(\"<b>{}</b>\").format(content)  # Safe\n```\n\nGiven:\n```python\nfrom markupsafe import Markup\n\nlines = [\n    Markup(\"<b>heading</b>\"),\n    \"<script>alert('XSS attempt')</script>\",\n]\nhtml = Markup(\"<br>\".join(lines))  # XSS\n```\n\nUse instead:\n```python\nfrom markupsafe import Markup\n\nlines = [\n    Markup(\"<b>heading</b>\"),\n    \"<script>alert('XSS attempt')</script>\",\n]\nhtml = Markup(\"<br>\").join(lines)  # Safe\n```"
    },
    {
      "code": "RUF036",
      "name": "none-not-at-end-of-union",
      "summary": "Checks for type annotations where `None` is not at the end of an union.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/none-not-at-end-of-union/",
      "whyBad": "Type annotation unions are commutative, meaning that the order of the elements\ndoes not matter. The `None` literal represents the absence of a value. For\nreadability, it's preferred to write the more informative type expressions first.",
      "example": "```python\ndef func(arg: None | int): ...\n```\n\nUse instead:\n```python\ndef func(arg: int | None): ...\n```"
    },
    {
      "code": "RUF037",
      "name": "unnecessary-empty-iterable-within-deque-call",
      "summary": "Checks for usages of `collections.deque` that have an empty iterable as the first argument.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-empty-iterable-within-deque-call/",
      "whyBad": "It's unnecessary to use an empty literal as a deque's iterable, since this is already the default behavior.",
      "example": "```python\nfrom collections import deque\n\nqueue = deque(set())\nqueue = deque([], 10)\n```\n\nUse instead:\n\n```python\nfrom collections import deque\n\nqueue = deque()\nqueue = deque(maxlen=10)\n```"
    },
    {
      "code": "RUF038",
      "name": "redundant-bool-literal",
      "summary": "Checks for `Literal[True, False]` type annotations.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redundant-bool-literal/",
      "whyBad": "`Literal[True, False]` can be replaced with `bool` in type annotations,\nwhich has the same semantic meaning but is more concise and readable.\n\n`bool` type has exactly two constant instances: `True` and `False`. Static\ntype checkers such as [mypy] treat `Literal[True, False]` as equivalent to\n`bool` in a type annotation.",
      "example": "```python\nfrom typing import Literal\n\nx: Literal[True, False]\ny: Literal[True, False, \"hello\", \"world\"]\n```\n\nUse instead:\n```python\nfrom typing import Literal\n\nx: bool\ny: Literal[\"hello\", \"world\"] | bool\n```"
    },
    {
      "code": "RUF039",
      "name": "unraw-re-pattern",
      "summary": "Reports the following `re` and `regex` calls when\ntheir first arguments are not raw strings:\n\n- For `regex` and `re`: `compile`, `findall`, `finditer`,\n  `fullmatch`, `match`, `search`, `split`, `sub`, `subn`.\n- `regex`-specific: `splititer`, `subf`, `subfn`, `template`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unraw-re-pattern/",
      "whyBad": "Regular expressions should be written\nusing raw strings to avoid double escaping."
    },
    {
      "code": "RUF040",
      "name": "invalid-assert-message-literal-argument",
      "summary": "Checks for invalid use of literals in assert message arguments.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-assert-message-literal-argument/",
      "whyBad": "An assert message which is a non-string literal was likely intended\nto be used in a comparison assertion, rather than as a message.",
      "example": "```python\nfruits = [\"apples\", \"plums\", \"pears\"]\nfruits.filter(lambda fruit: fruit.startwith(\"p\"))\nassert len(fruits), 2  # True unless the list is empty\n```\n\nUse instead:\n```python\nfruits = [\"apples\", \"plums\", \"pears\"]\nfruits.filter(lambda fruit: fruit.startwith(\"p\"))\nassert len(fruits) == 2\n```"
    },
    {
      "code": "RUF041",
      "name": "unnecessary-nested-literal",
      "summary": "Checks for unnecessary nested `Literal`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-nested-literal/",
      "whyBad": "Prefer using a single `Literal`, which is equivalent and more concise.\n\nParameterization of literals by other literals is supported as an ergonomic\nfeature as proposed in [PEP 586], to enable patterns such as:\n```python\nReadOnlyMode         = Literal[\"r\", \"r+\"]\nWriteAndTruncateMode = Literal[\"w\", \"w+\", \"wt\", \"w+t\"]\nWriteNoTruncateMode  = Literal[\"r+\", \"r+t\"]\nAppendMode           = Literal[\"a\", \"a+\", \"at\", \"a+t\"]\n\nAllModes = Literal[ReadOnlyMode, WriteAndTruncateMode,\n                  WriteNoTruncateMode, AppendMode]\n```\n\nAs a consequence, type checkers also support nesting of literals\nwhich is less readable than a flat `Literal`:\n```python\nAllModes = Literal[Literal[\"r\", \"r+\"], Literal[\"w\", \"w+\", \"wt\", \"w+t\"],\n                  Literal[\"r+\", \"r+t\"], Literal[\"a\", \"a+\", \"at\", \"a+t\"]]\n```",
      "example": "```python\nAllModes = Literal[\n    Literal[\"r\", \"r+\"],\n    Literal[\"w\", \"w+\", \"wt\", \"w+t\"],\n    Literal[\"r+\", \"r+t\"],\n    Literal[\"a\", \"a+\", \"at\", \"a+t\"],\n]\n```\n\nUse instead:\n```python\nAllModes = Literal[\n    \"r\", \"r+\", \"w\", \"w+\", \"wt\", \"w+t\", \"r+\", \"r+t\", \"a\", \"a+\", \"at\", \"a+t\"\n]\n```\n\nor assign the literal to a variable as in the first example."
    },
    {
      "code": "RUF043",
      "name": "pytest-raises-ambiguous-pattern",
      "summary": "Checks for non-raw literal string arguments passed to the `match` parameter\nof `pytest.raises()` where the string contains at least one unescaped\nregex metacharacter.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/pytest-raises-ambiguous-pattern/",
      "whyBad": "The `match` argument is implicitly converted to a regex under the hood.\nIt should be made explicit whether the string is meant to be a regex or a \"plain\" pattern\nby prefixing the string with the `r` suffix, escaping the metacharacter(s)\nin the string using backslashes, or wrapping the entire string in a call to\n`re.escape()`.",
      "example": "```python\nimport pytest\n\n\nwith pytest.raises(Exception, match=\"A full sentence.\"):\n    do_thing_that_raises()\n```\n\nIf the pattern is intended to be a regular expression, use a raw string to signal this\nintention:\n\n```python\nimport pytest\n\n\nwith pytest.raises(Exception, match=r\"A full sentence.\"):\n    do_thing_that_raises()\n```\n\nAlternatively, escape any regex metacharacters with `re.escape`:\n\n```python\nimport pytest\nimport re\n\n\nwith pytest.raises(Exception, match=re.escape(\"A full sentence.\")):\n    do_thing_that_raises()\n```\n\nor directly with backslashes:\n\n```python\nimport pytest\nimport re\n\n\nwith pytest.raises(Exception, \"A full sentence\\\\.\"):\n    do_thing_that_raises()\n```"
    },
    {
      "code": "RUF045",
      "name": "implicit-class-var-in-dataclass",
      "summary": "Checks for implicit class variables in dataclasses.\n\nVariables matching the [`lint.dummy-variable-rgx`] are excluded\nfrom this rule.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/implicit-class-var-in-dataclass/",
      "whyBad": "Class variables are shared between all instances of that class.\nIn dataclasses, fields with no annotations at all\nare implicitly considered class variables, and a `TypeError` is\nraised if a user attempts to initialize an instance of the class\nwith this field.\n\n\n```python\n@dataclass\nclass C:\n    a = 1\n    b: str = \"\"\n\nC(a = 42)  # TypeError: C.__init__() got an unexpected keyword argument 'a'\n```",
      "example": "```python\n@dataclass\nclass C:\n    a = 1\n```\n\nUse instead:\n\n```python\nfrom typing import ClassVar\n\n\n@dataclass\nclass C:\n    a: ClassVar[int] = 1\n```"
    },
    {
      "code": "RUF046",
      "name": "unnecessary-cast-to-int",
      "summary": "Checks for `int` conversions of values that are already integers.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-cast-to-int/",
      "whyBad": "Such a conversion is unnecessary.",
      "example": "```python\nint(len([]))\nint(round(foo, None))\n```\n\nUse instead:\n\n```python\nlen([])\nround(foo)\n```"
    },
    {
      "code": "RUF047",
      "name": "needless-else",
      "summary": "Checks for `else` clauses that only contains `pass` and `...` statements.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/needless-else/",
      "whyBad": "Such an else clause does nothing and can be removed.",
      "example": "```python\nif foo:\n    bar()\nelse:\n    pass\n```\n\nUse instead:\n```python\nif foo:\n    bar()\n```"
    },
    {
      "code": "RUF048",
      "name": "map-int-version-parsing",
      "summary": "Checks for calls of the form `map(int, __version__.split(\".\"))`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/map-int-version-parsing/",
      "whyBad": "`__version__` does not always contain integral-like elements.\n\n```python\nimport matplotlib  # `__version__ == \"3.9.1.post-1\"` in our environment\n\n# ValueError: invalid literal for int() with base 10: 'post1'\ntuple(map(int, matplotlib.__version__.split(\".\")))\n```\n\nSee also [*Version specifiers* | Packaging spec][version-specifier].",
      "example": "```python\ntuple(map(int, matplotlib.__version__.split(\".\")))\n```\n\nUse instead:\n```python\nimport packaging.version as version\n\nversion.parse(matplotlib.__version__)\n```\n\n[version-specifier]: https://packaging.python.org/en/latest/specifications/version-specifiers/#version-specifiers"
    },
    {
      "code": "RUF049",
      "name": "dataclass-enum",
      "summary": "Checks for enum classes which are also decorated with `@dataclass`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/dataclass-enum/",
      "whyBad": "Decorating an enum with `@dataclass()` does not cause any errors at runtime,\nbut may cause erroneous results:\n\n```python\n@dataclass\nclass E(Enum):\n    A = 1\n    B = 2\n\nprint(E.A == E.B)  # True\n```",
      "example": "```python\nfrom dataclasses import dataclass\nfrom enum import Enum\n\n\n@dataclass\nclass E(Enum): ...\n```\n\nUse instead:\n\n```python\nfrom enum import Enum\n\n\nclass E(Enum): ...\n```"
    },
    {
      "code": "RUF051",
      "name": "if-key-in-dict-del",
      "summary": "Checks for `if key in dictionary: del dictionary[key]`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/if-key-in-dict-del/",
      "whyBad": "To remove a key-value pair from a dictionary, it's more concise to use `.pop(..., None)`.",
      "example": "```python\nif key in dictionary:\n    del dictionary[key]\n```\n\nUse instead:\n\n```python\ndictionary.pop(key, None)\n```"
    },
    {
      "code": "RUF052",
      "name": "used-dummy-variable",
      "summary": "Checks for \"dummy variables\" (variables that are named as if to indicate they are unused)\nthat are in fact used.\n\nBy default, \"dummy variables\" are any variables with names that start with leading\nunderscores. However, this is customisable using the [`lint.dummy-variable-rgx`] setting).",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/used-dummy-variable/",
      "whyBad": "Marking a variable with a leading underscore conveys that it is intentionally unused within the function or method.\nWhen these variables are later referenced in the code, it causes confusion and potential misunderstandings about\nthe code's intention. If a variable marked as \"unused\" is subsequently used, it suggests that either the variable\ncould be given a clearer name, or that the code is accidentally making use of the wrong variable.\n\nSometimes leading underscores are used to avoid variables shadowing other variables, Python builtins, or Python\nkeywords. However, [PEP 8] recommends to use trailing underscores for this rather than leading underscores.\n\nDunder variables are ignored by this rule, as are variables named `_`.\nOnly local variables in function scopes are flagged by the rule.",
      "example": "```python\ndef function():\n    _variable = 3\n    # important: avoid shadowing the builtin `id()` function!\n    _id = 4\n    return _variable + _id\n```\n\nUse instead:\n```python\ndef function():\n    variable = 3\n    # important: avoid shadowing the builtin `id()` function!\n    id_ = 4\n    return variable + id_\n```"
    },
    {
      "code": "RUF053",
      "name": "class-with-mixed-type-vars",
      "summary": "Checks for classes that have [PEP 695] [type parameter lists]\nwhile also inheriting from `typing.Generic` or `typing_extensions.Generic`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/class-with-mixed-type-vars/",
      "whyBad": "Such classes cause errors at runtime:\n\n```python\nfrom typing import Generic, TypeVar\n\nU = TypeVar(\"U\")\n\n# TypeError: Cannot inherit from Generic[...] multiple times.\nclass C[T](Generic[U]): ...\n```",
      "example": "```python\nfrom typing import Generic, ParamSpec, TypeVar, TypeVarTuple\n\nU = TypeVar(\"U\")\nP = ParamSpec(\"P\")\nTs = TypeVarTuple(\"Ts\")\n\n\nclass C[T](Generic[U, P, *Ts]): ...\n```\n\nUse instead:\n\n```python\nclass C[T, U, **P, *Ts]: ...\n```"
    },
    {
      "code": "RUF054",
      "name": "indented-form-feed",
      "summary": "Checks for form feed characters preceded by either a space or a tab.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/indented-form-feed/",
      "whyBad": "[The language reference][lexical-analysis-indentation] states:\n\n> A formfeed character may be present at the start of the line;\n> it will be ignored for the indentation calculations above.\n> Formfeed characters occurring elsewhere in the leading whitespace\n> have an undefined effect (for instance, they may reset the space count to zero).",
      "example": "```python\nif foo():\\n    \\fbar()\n```\n\nUse instead:\n\n```python\nif foo():\\n    bar()\n```\n\n[lexical-analysis-indentation]: https://docs.python.org/3/reference/lexical_analysis.html#indentation"
    },
    {
      "code": "RUF055",
      "name": "unnecessary-regular-expression",
      "summary": "Checks for uses of the `re` module that can be replaced with builtin `str` methods.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-regular-expression/",
      "whyBad": "Performing checks on strings directly can make the code simpler, may require\nless escaping, and will often be faster.",
      "example": "```python\nre.sub(\"abc\", \"\", s)\n```\n\nUse instead:\n\n```python\ns.replace(\"abc\", \"\")\n```"
    },
    {
      "code": "RUF056",
      "name": "falsy-dict-get-fallback",
      "summary": "Checks for `dict.get(key, falsy_value)` calls in boolean test positions.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/falsy-dict-get-fallback/",
      "whyBad": "The default fallback `None` is already falsy.",
      "example": "```python\nif dict.get(key, False):\n    ...\n```\n\nUse instead:\n\n```python\nif dict.get(key):\n    ...\n```"
    },
    {
      "code": "RUF057",
      "name": "unnecessary-round",
      "summary": "Checks for `round()` calls that have no effect on the input.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unnecessary-round/",
      "whyBad": "Rounding a value that's already an integer is unnecessary.\nIt's clearer to use the value directly.",
      "example": "```python\na = round(1, 0)\n```\n\nUse instead:\n\n```python\na = 1\n```"
    },
    {
      "code": "RUF058",
      "name": "starmap-zip",
      "summary": "Checks for `itertools.starmap` calls where the second argument is a `zip` call.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/starmap-zip/",
      "whyBad": "`zip`-ping iterables only to unpack them later from within `starmap` is unnecessary.\nFor such cases, `map()` should be used instead.",
      "example": "```python\nfrom itertools import starmap\n\n\nstarmap(func, zip(a, b))\nstarmap(func, zip(a, b, strict=True))\n```\n\nUse instead:\n\n```python\nmap(func, a, b)\nmap(func, a, b, strict=True)  # 3.14+\n```"
    },
    {
      "code": "RUF059",
      "name": "unused-unpacked-variable",
      "summary": "Checks for the presence of unused variables in unpacked assignments.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-unpacked-variable/",
      "whyBad": "A variable that is defined but never used can confuse readers.\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\n[`lint.dummy-variable-rgx`] pattern.",
      "example": "```python\ndef get_pair():\n    return 1, 2\n\n\ndef foo():\n    x, y = get_pair()\n    return x\n```\n\nUse instead:\n\n```python\ndef foo():\n    x, _ = get_pair()\n    return x\n```"
    },
    {
      "code": "RUF060",
      "name": "in-empty-collection",
      "summary": "Checks for membership tests on empty collections (such as `list`, `tuple`, `set` or `dict`).",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/in-empty-collection/",
      "whyBad": "If the collection is always empty, the check is unnecessary, and can be removed.",
      "example": "```python\nif 1 not in set():\n    print(\"got it!\")\n```\n\nUse instead:\n\n```python\nprint(\"got it!\")\n```"
    },
    {
      "code": "RUF061",
      "name": "legacy-form-pytest-raises",
      "summary": "Checks for non-contextmanager use of `pytest.raises`, `pytest.warns`, and `pytest.deprecated_call`.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/legacy-form-pytest-raises/",
      "whyBad": "The context-manager form is more readable, easier to extend, and supports additional kwargs.",
      "example": "```python\nimport pytest\n\n\nexcinfo = pytest.raises(ValueError, int, \"hello\")\npytest.warns(UserWarning, my_function, arg)\npytest.deprecated_call(my_deprecated_function, arg1, arg2)\n```\n\nUse instead:\n```python\nimport pytest\n\n\nwith pytest.raises(ValueError) as excinfo:\n    int(\"hello\")\nwith pytest.warns(UserWarning):\n    my_function(arg)\nwith pytest.deprecated_call():\n    my_deprecated_function(arg1, arg2)\n```"
    },
    {
      "code": "RUF063",
      "name": "access-annotations-from-class-dict",
      "summary": "Checks for uses of `foo.__dict__.get(\"__annotations__\")` or\n`foo.__dict__[\"__annotations__\"]` on Python 3.10+ and Python < 3.10 when\n[typing-extensions](https://docs.astral.sh/ruff/settings/#lint_typing-extensions)\nis enabled.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/access-annotations-from-class-dict/",
      "whyBad": "Starting with Python 3.14, directly accessing `__annotations__` via\n`foo.__dict__.get(\"__annotations__\")` or `foo.__dict__[\"__annotations__\"]`\nwill only return annotations if the class is defined under\n`from __future__ import annotations`.\n\nTherefore, it is better to use dedicated library functions like\n`annotationlib.get_annotations` (Python 3.14+), `inspect.get_annotations`\n(Python 3.10+), or `typing_extensions.get_annotations` (for Python < 3.10 if\n[typing-extensions](https://pypi.org/project/typing-extensions/) is\navailable).\n\nThe benefits of using these functions include:\n1.  **Avoiding Undocumented Internals:** They provide a stable, public API,\n    unlike direct `__dict__` access which relies on implementation details.\n2.  **Forward-Compatibility:** They are designed to handle changes in\n    Python's annotation system across versions, ensuring your code remains\n    robust (e.g., correctly handling the Python 3.14 behavior mentioned\n    above).\n\nSee [Python Annotations Best Practices](https://docs.python.org/3.14/howto/annotations.html)\nfor alternatives.",
      "example": "```python\nfoo.__dict__.get(\"__annotations__\", {})"
    },
    {
      "code": "RUF064",
      "name": "non-octal-permissions",
      "summary": "Checks for standard library functions which take a numeric `mode` argument\nwhere a non-octal integer literal is passed.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/non-octal-permissions/",
      "whyBad": "Numeric modes are made up of one to four octal digits. Converting a non-octal\ninteger to octal may not be the mode the author intended.",
      "example": "```python\nos.chmod(\"foo\", 644)\n```\n\nUse instead:\n\n```python\nos.chmod(\"foo\", 0o644)\n```"
    },
    {
      "code": "RUF065",
      "name": "logging-eager-conversion",
      "summary": "Checks for eager string conversion of arguments to `logging` calls.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/logging-eager-conversion/",
      "whyBad": "Arguments to `logging` calls will be formatted as strings automatically, so it\nis unnecessary and less efficient to eagerly format the arguments before passing\nthem in.",
      "example": "```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", str(user))\n```\n\nUse instead:\n```python\nimport logging\n\nlogging.basicConfig(format=\"%(message)s\", level=logging.INFO)\n\nuser = \"Maria\"\n\nlogging.info(\"%s - Something happened\", user)\n```"
    },
    {
      "code": "RUF066",
      "name": "property-without-return",
      "summary": "Detects class `@property` methods that does not have a `return` statement.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/property-without-return/",
      "whyBad": "Property methods are expected to return a computed value, a missing return in a property usually indicates an implementation mistake.",
      "example": "```python\nclass User:\n    @property\n    def full_name(self):\n        f\"{self.first_name} {self.last_name}\"\n```\n\nUse instead:\n```python\nclass User:\n    @property\n    def full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n```"
    },
    {
      "code": "RUF100",
      "name": "unused-noqa",
      "summary": "Checks for `noqa` directives that are no longer applicable.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/unused-noqa/",
      "whyBad": "A `noqa` directive that no longer matches any diagnostic violations is\nlikely included by mistake, and should be removed to avoid confusion.",
      "example": "```python\nimport foo  # noqa: F401\n\n\ndef bar():\n    foo.bar()\n```\n\nUse instead:\n```python\nimport foo\n\n\ndef bar():\n    foo.bar()\n```"
    },
    {
      "code": "RUF101",
      "name": "redirected-noqa",
      "summary": "Checks for `noqa` directives that use redirected rule codes.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/redirected-noqa/",
      "whyBad": "When one of Ruff's rule codes has been redirected, the implication is that the rule has\nbeen deprecated in favor of another rule or code. To keep your codebase\nconsistent and up-to-date, prefer the canonical rule code over the deprecated\ncode.",
      "example": "```python\nx = eval(command)  # noqa: PGH001\n```\n\nUse instead:\n```python\nx = eval(command)  # noqa: S307\n```"
    },
    {
      "code": "RUF102",
      "name": "invalid-rule-code",
      "summary": "Checks for `noqa` codes that are invalid.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "preview",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-rule-code/",
      "whyBad": "Invalid rule codes serve no purpose and may indicate outdated code suppressions.",
      "example": "```python\nimport os  # noqa: XYZ999\n```\n\nUse instead:\n```python\nimport os\n```\n\nOr if there are still valid codes needed:\n```python\nimport os  # noqa: E402\n```"
    },
    {
      "code": "RUF200",
      "name": "invalid-pyproject-toml",
      "summary": "Checks for any pyproject.toml that does not conform to the schema from the relevant PEPs.",
      "category": "Ruff-specific rules",
      "categoryCode": "RUF",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/invalid-pyproject-toml/",
      "whyBad": "Your project may contain invalid metadata or configuration without you noticing",
      "example": "```toml\n[project]\nname = \"crab\"\nversion = \"1.0.0\"\nauthors = [\"Ferris the Crab <ferris@example.org>\"]\n```\n\nUse instead:\n```toml\n[project]\nname = \"crab\"\nversion = \"1.0.0\"\nauthors = [\n  { name = \"Ferris the Crab\", email = \"ferris@example.org\" }\n]\n```"
    },
    {
      "code": "TRY002",
      "name": "raise-vanilla-class",
      "summary": "Checks for code that raises `Exception` or `BaseException` directly.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/raise-vanilla-class/",
      "whyBad": "Handling such exceptions requires the use of `except Exception` or\n`except BaseException`. These will capture almost _any_ raised exception,\nincluding failed assertions, division by zero, and more.\n\nPrefer to raise your own exception, or a more specific built-in\nexception, so that you can avoid over-capturing exceptions that you\ndon't intend to handle.",
      "example": "```python\ndef main_function():\n    if not cond:\n        raise Exception()\n\n\ndef consumer_func():\n    try:\n        do_step()\n        prepare()\n        main_function()\n    except Exception:\n        logger.error(\"Oops\")\n```\n\nUse instead:\n```python\ndef main_function():\n    if not cond:\n        raise CustomException()\n\n\ndef consumer_func():\n    try:\n        do_step()\n        prepare()\n        main_function()\n    except CustomException:\n        logger.error(\"Main function failed\")\n    except Exception:\n        logger.error(\"Oops\")\n```"
    },
    {
      "code": "TRY003",
      "name": "raise-vanilla-args",
      "summary": "Checks for long exception messages that are not defined in the exception\nclass itself.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/raise-vanilla-args/",
      "whyBad": "By formatting an exception message at the `raise` site, the exception class\nbecomes less reusable, and may now raise inconsistent messages depending on\nwhere it is raised.\n\nIf the exception message is instead defined within the exception class, it\nwill be consistent across all `raise` invocations.\n\nThis rule is not enforced for some built-in exceptions that are commonly\nraised with a message and would be unusual to subclass, such as\n`NotImplementedError`.",
      "example": "```python\nclass CantBeNegative(Exception):\n    pass\n\n\ndef foo(x):\n    if x < 0:\n        raise CantBeNegative(f\"{x} is negative\")\n```\n\nUse instead:\n```python\nclass CantBeNegative(Exception):\n    def __init__(self, number):\n        super().__init__(f\"{number} is negative\")\n\n\ndef foo(x):\n    if x < 0:\n        raise CantBeNegative(x)\n```"
    },
    {
      "code": "TRY004",
      "name": "type-check-without-type-error",
      "summary": "Checks for type checks that do not raise `TypeError`.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/type-check-without-type-error/",
      "whyBad": "The Python documentation states that `TypeError` should be raised upon\nencountering an inappropriate type.",
      "example": "```python\ndef foo(n: int):\n    if isinstance(n, int):\n        pass\n    else:\n        raise ValueError(\"n must be an integer\")\n```\n\nUse instead:\n```python\ndef foo(n: int):\n    if isinstance(n, int):\n        pass\n    else:\n        raise TypeError(\"n must be an integer\")\n```"
    },
    {
      "code": "TRY200",
      "name": "reraise-no-cause",
      "summary": "Checks for exceptions that are re-raised without specifying the cause via\nthe `from` keyword.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "removed",
      "documentUrl": "https://docs.astral.sh/ruff/rules/reraise-no-cause/",
      "whyBad": "The `from` keyword sets the `__cause__` attribute of the exception, which\nstores the \"cause\" of the exception. The availability of an exception\n\"cause\" is useful for debugging.",
      "example": "```python\ndef reciprocal(n):\n    try:\n        return 1 / n\n    except ZeroDivisionError:\n        raise ValueError()\n```\n\nUse instead:\n```python\ndef reciprocal(n):\n    try:\n        return 1 / n\n    except ZeroDivisionError as exc:\n        raise ValueError() from exc\n```"
    },
    {
      "code": "TRY201",
      "name": "verbose-raise",
      "summary": "Checks for needless exception names in `raise` statements.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/verbose-raise/",
      "whyBad": "It's redundant to specify the exception name in a `raise` statement if the\nexception is being re-raised.",
      "example": "```python\ndef foo():\n    try:\n        ...\n    except ValueError as exc:\n        raise exc\n```\n\nUse instead:\n```python\ndef foo():\n    try:\n        ...\n    except ValueError:\n        raise\n```"
    },
    {
      "code": "TRY203",
      "name": "useless-try-except",
      "summary": "Checks for immediate uses of `raise` within exception handlers.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/useless-try-except/",
      "whyBad": "Capturing an exception, only to immediately reraise it, has no effect.\nInstead, remove the error-handling code and let the exception propagate\nupwards without the unnecessary `try`-`except` block.",
      "example": "```python\ndef foo():\n    try:\n        bar()\n    except NotImplementedError:\n        raise\n```\n\nUse instead:\n```python\ndef foo():\n    bar()\n```"
    },
    {
      "code": "TRY300",
      "name": "try-consider-else",
      "summary": "Checks for `return` statements in `try` blocks.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/try-consider-else/",
      "whyBad": "The `try`-`except` statement has an `else` clause for code that should\nrun _only_ if no exceptions were raised. Returns in `try` blocks may\nexhibit confusing or unwanted behavior, such as being overridden by\ncontrol flow in `except` and `finally` blocks, or unintentionally\nsuppressing an exception.",
      "example": "```python\nimport logging\n\n\ndef reciprocal(n):\n    try:\n        rec = 1 / n\n        print(f\"reciprocal of {n} is {rec}\")\n        return rec\n    except ZeroDivisionError:\n        logging.exception(\"Exception occurred\")\n        raise\n```\n\nUse instead:\n```python\nimport logging\n\n\ndef reciprocal(n):\n    try:\n        rec = 1 / n\n    except ZeroDivisionError:\n        logging.exception(\"Exception occurred\")\n        raise\n    else:\n        print(f\"reciprocal of {n} is {rec}\")\n        return rec\n```"
    },
    {
      "code": "TRY301",
      "name": "raise-within-try",
      "summary": "Checks for `raise` statements within `try` blocks. The only `raise`s\ncaught are those that throw exceptions caught by the `try` statement itself.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/raise-within-try/",
      "whyBad": "Raising and catching exceptions within the same `try` block is redundant,\nas the code can be refactored to avoid the `try` block entirely.\n\nAlternatively, the `raise` can be moved within an inner function, making\nthe exception reusable across multiple call sites.",
      "example": "```python\ndef bar():\n    pass\n\n\ndef foo():\n    try:\n        a = bar()\n        if not a:\n            raise ValueError\n    except ValueError:\n        raise\n```\n\nUse instead:\n```python\ndef bar():\n    raise ValueError\n\n\ndef foo():\n    try:\n        a = bar()  # refactored `bar` to raise `ValueError`\n    except ValueError:\n        raise\n```"
    },
    {
      "code": "TRY400",
      "name": "error-instead-of-exception",
      "summary": "Checks for uses of `logging.error` instead of `logging.exception` when\nlogging an exception.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/error-instead-of-exception/",
      "whyBad": "`logging.exception` logs the exception and the traceback, while\n`logging.error` only logs the exception. The former is more appropriate\nwhen logging an exception, as the traceback is often useful for debugging.",
      "example": "```python\nimport logging\n\n\ndef func():\n    try:\n        raise NotImplementedError\n    except NotImplementedError:\n        logging.error(\"Exception occurred\")\n```\n\nUse instead:\n```python\nimport logging\n\n\ndef func():\n    try:\n        raise NotImplementedError\n    except NotImplementedError:\n        logging.exception(\"Exception occurred\")\n```"
    },
    {
      "code": "TRY401",
      "name": "verbose-log-message",
      "summary": "Checks for excessive logging of exception objects.",
      "category": "tryceratops",
      "categoryCode": "TRY",
      "status": "stable",
      "documentUrl": "https://docs.astral.sh/ruff/rules/verbose-log-message/",
      "whyBad": "When logging exceptions via `logging.exception`, the exception object\nis logged automatically. Including the exception object in the log\nmessage is redundant and can lead to excessive logging.",
      "example": "```python\ntry:\n    ...\nexcept ValueError as e:\n    logger.exception(f\"Found an error: {e}\")\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept ValueError:\n    logger.exception(\"Found an error\")\n```"
    }
  ]
}